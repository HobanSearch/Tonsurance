#include "../imports/stdlib.fc";

;; Storage structure
;; - admin_address: slice
;; - pricing_oracle: slice
;; - hedge_coordinator: slice
;; - primary_vault: slice
;; - keepers: cell (polymarket, perp, allianz keeper addresses)
;; - next_policy_id: int
;; - policies: dict (int -> cell)
;; - total_coverage: int

;; Error codes
const int error::unauthorized = 401;
const int error::insufficient_payment = 402;
const int error::invalid_coverage_type = 403;
const int error::invalid_duration = 404;
const int error::insufficient_pool_capacity = 405;
const int error::premium_expired = 406;

;; Op codes
const int op::create_hedged_policy = 0x63726561;  ;; "crea"
const int op::update_oracle = 0x75706f72;          ;; "upor"
const int op::update_coordinator = 0x7570636f;     ;; "upco"
const int op::update_vault = 0x75707661;           ;; "upva"
const int op::execute_hedge = 0x65786867;          ;; "exhg"

;; Coverage types
const int coverage::depeg = 1;
const int coverage::exploit = 2;
const int coverage::bridge = 3;

;; Constants
const int min_duration_days = 7;
const int max_duration_days = 365;
const int max_pool_utilization = 80;  ;; 80% max utilization
const int basis_points = 10000;
const int premium_quote_validity = 30;  ;; 30 seconds

;; Storage management
global slice g_admin_address;
global slice g_pricing_oracle;
global slice g_hedge_coordinator;
global slice g_primary_vault;
global cell g_keepers;
global int g_next_policy_id;
global cell g_policies;
global int g_total_coverage;

() load_data() impure {
    slice ds = get_data().begin_parse();
    g_admin_address = ds~load_msg_addr();
    g_pricing_oracle = ds~load_msg_addr();
    g_hedge_coordinator = ds~load_msg_addr();
    g_primary_vault = ds~load_msg_addr();
    g_keepers = ds~load_ref();
    g_next_policy_id = ds~load_uint(64);
    g_policies = ds~load_dict();
    g_total_coverage = ds~load_coins();
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(g_admin_address)
        .store_slice(g_pricing_oracle)
        .store_slice(g_hedge_coordinator)
        .store_slice(g_primary_vault)
        .store_ref(g_keepers)
        .store_uint(g_next_policy_id, 64)
        .store_dict(g_policies)
        .store_coins(g_total_coverage)
        .end_cell()
    );
}

;; Check if sender is admin
int is_admin(slice sender_addr) inline {
    return equal_slices_bits(sender_addr, g_admin_address);
}

;; Validate coverage type
() validate_coverage_type(int coverage_type) impure inline {
    throw_unless(error::invalid_coverage_type,
        (coverage_type == coverage::depeg) |
        (coverage_type == coverage::exploit) |
        (coverage_type == coverage::bridge)
    );
}

;; Validate duration
() validate_duration(int duration_days) impure inline {
    throw_unless(error::invalid_duration,
        (duration_days >= min_duration_days) &
        (duration_days <= max_duration_days)
    );
}

;; Get keeper addresses from storage
(slice, slice, slice) get_keeper_addresses() inline {
    slice ks = g_keepers.begin_parse();
    slice polymarket_keeper = ks~load_msg_addr();
    slice perp_keeper = ks~load_msg_addr();
    slice allianz_keeper = ks~load_msg_addr();
    return (polymarket_keeper, perp_keeper, allianz_keeper);
}

;; Send hedge execution message to keeper
() send_hedge_order(slice keeper_addr, int policy_id, int venue, int amount) impure {
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(keeper_addr)
        .store_coins(100000000)  ;; 0.1 TON for gas
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(op::execute_hedge, 32)
        .store_uint(policy_id, 64)
        .store_uint(venue, 8)
        .store_coins(amount)
        .end_cell();
    send_raw_message(msg, 1);
}

;; Create hedged policy with swing pricing
() create_hedged_policy(
    slice user_addr,
    int coverage_type,
    int coverage_amount,
    int duration_days,
    int expected_premium,
    int quote_timestamp
) impure {
    validate_coverage_type(coverage_type);
    validate_duration(duration_days);

    ;; Check premium quote hasn't expired (30 second window)
    int now_ts = now();
    throw_unless(error::premium_expired, (now_ts - quote_timestamp) <= premium_quote_validity);

    ;; Calculate base premium (0.8% APR)
    int base_premium = muldiv(coverage_amount, 80 * duration_days, basis_points * 365);

    ;; Get hedge costs from pricing oracle (external method call would be here)
    ;; For now, we'll calculate assuming oracle is called off-chain
    ;; In production, this would query g_pricing_oracle.calculate_hedge_cost()

    ;; For testing: assume hedge cost is 20% of coverage
    int hedge_cost = muldiv(coverage_amount, 20, 100);

    int total_premium = base_premium + hedge_cost;

    ;; Verify user paid within 2% of expected premium (slippage tolerance)
    int min_acceptable = muldiv(expected_premium, 98, 100);
    int max_acceptable = muldiv(expected_premium, 102, 100);
    throw_unless(error::insufficient_payment,
        (total_premium >= min_acceptable) & (total_premium <= max_acceptable)
    );

    ;; Check pool capacity (80% utilization limit)
    ;; Assume pool has 10M TON capacity for testing
    int pool_capacity = 10000000000000000;  ;; 10M TON in nanotons
    int new_total = g_total_coverage + coverage_amount;
    int utilization = muldiv(new_total, 100, pool_capacity);
    throw_unless(error::insufficient_pool_capacity, utilization <= max_pool_utilization);

    ;; Create policy record
    int policy_id = g_next_policy_id;
    int expiry_time = now_ts + (duration_days * 86400);

    cell policy = begin_cell()
        .store_slice(user_addr)
        .store_uint(coverage_type, 8)
        .store_coins(coverage_amount)
        .store_uint(duration_days, 16)
        .store_coins(total_premium)
        .store_uint(now_ts, 32)
        .store_uint(expiry_time, 32)
        .store_uint(1, 8)  ;; is_active
        .end_cell();

    g_policies~udict_set(64, policy_id, policy.begin_parse());
    g_next_policy_id += 1;
    g_total_coverage += coverage_amount;

    ;; Calculate hedge allocations (20% of coverage)
    int total_hedge = muldiv(coverage_amount, 20, 100);
    int poly_amount = muldiv(total_hedge, 40, 100);   ;; 40% to Polymarket
    int perp_amount = muldiv(total_hedge, 40, 100);   ;; 40% to Perps
    int allianz_amount = muldiv(total_hedge, 20, 100); ;; 20% to Allianz

    ;; Get keeper addresses
    (slice poly_keeper, slice perp_keeper, slice allianz_keeper) = get_keeper_addresses();

    ;; Send async hedge execution orders to keepers
    send_hedge_order(poly_keeper, policy_id, 1, poly_amount);
    send_hedge_order(perp_keeper, policy_id, 2, perp_amount);
    send_hedge_order(allianz_keeper, policy_id, 3, allianz_amount);
}

;; Main receiver
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();  ;; Ignore empty messages
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_addr = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == op::create_hedged_policy) {
        slice user_addr = in_msg_body~load_msg_addr();
        int coverage_type = in_msg_body~load_uint(8);
        int coverage_amount = in_msg_body~load_coins();
        int duration_days = in_msg_body~load_uint(16);
        int expected_premium = in_msg_body~load_coins();
        int quote_timestamp = in_msg_body~load_uint(32);

        create_hedged_policy(
            user_addr,
            coverage_type,
            coverage_amount,
            duration_days,
            expected_premium,
            quote_timestamp
        );

        save_data();
        return ();
    }

    if (op == op::update_oracle) {
        throw_unless(error::unauthorized, is_admin(sender_addr));
        g_pricing_oracle = in_msg_body~load_msg_addr();
        save_data();
        return ();
    }

    if (op == op::update_coordinator) {
        throw_unless(error::unauthorized, is_admin(sender_addr));
        g_hedge_coordinator = in_msg_body~load_msg_addr();
        save_data();
        return ();
    }

    if (op == op::update_vault) {
        throw_unless(error::unauthorized, is_admin(sender_addr));
        g_primary_vault = in_msg_body~load_msg_addr();
        save_data();
        return ();
    }

    throw(0xffff);  ;; Unknown operation
}

;; Get policy details
(slice, int, int, int, int, int, int, int) get_policy(int policy_id) method_id {
    load_data();

    (slice policy_data, int found) = g_policies.udict_get?(64, policy_id);
    throw_unless(404, found);

    slice user_addr = policy_data~load_msg_addr();
    int coverage_type = policy_data~load_uint(8);
    int coverage_amount = policy_data~load_coins();
    int duration_days = policy_data~load_uint(16);
    int total_premium = policy_data~load_coins();
    int created_at = policy_data~load_uint(32);
    int expiry_time = policy_data~load_uint(32);
    int is_active = policy_data~load_uint(8);

    return (
        user_addr,
        coverage_type,
        coverage_amount,
        duration_days,
        total_premium,
        created_at,
        expiry_time,
        is_active
    );
}

;; Get next policy ID
int get_next_policy_id() method_id {
    load_data();
    return g_next_policy_id;
}

;; Get total coverage
int get_total_coverage() method_id {
    load_data();
    return g_total_coverage;
}

;; Get pool utilization percentage
int get_pool_utilization() method_id {
    load_data();
    int pool_capacity = 10000000000000000;  ;; 10M TON
    return muldiv(g_total_coverage, 100, pool_capacity);
}

;; Get pricing oracle address
slice get_pricing_oracle() method_id {
    load_data();
    return g_pricing_oracle;
}

;; Get hedge coordinator address
slice get_hedge_coordinator() method_id {
    load_data();
    return g_hedge_coordinator;
}

;; Get admin address
slice get_admin_address() method_id {
    load_data();
    return g_admin_address;
}
