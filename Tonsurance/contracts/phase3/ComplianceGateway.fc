;; ComplianceGateway Contract - KYC/AML Whitelist System
;; Manages institutional investor onboarding
;; Enforces KYC/AML requirements for TradFi Buffer
;; Multi-tier compliance levels (Basic, Enhanced, Institutional)
;; Integration with third-party KYC providers (Sumsub, Chainalysis)

#include "../imports/stdlib.fc";

;; Storage structure
global slice owner_address;
global slice tradfi_buffer_address;
global cell compliance_registry;  ;; address_hash -> (status, tier, approval_time, expiry_time, kyc_provider_id)
global cell admin_list;  ;; admin_hash -> 1
global int total_approved;
global int total_rejected;
global int total_expired;

;; Compliance tiers
const int TIER_NONE = 0;
const int TIER_BASIC = 1;         ;; Up to $500k
const int TIER_ENHANCED = 2;      ;; Up to $2M
const int TIER_INSTITUTIONAL = 3;  ;; Unlimited

;; Compliance status
const int STATUS_PENDING = 0;
const int STATUS_APPROVED = 1;
const int STATUS_REJECTED = 2;
const int STATUS_EXPIRED = 3;

;; Expiry period (1 year)
const int EXPIRY_PERIOD = 31536000;

() load_data() impure {
    slice ds = get_data().begin_parse();
    owner_address = ds~load_msg_addr();
    tradfi_buffer_address = ds~load_msg_addr();
    compliance_registry = ds~load_dict();
    admin_list = ds~load_dict();
    total_approved = ds~load_uint(32);
    total_rejected = ds~load_uint(32);
    total_expired = ds~load_uint(32);
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(owner_address)
        .store_slice(tradfi_buffer_address)
        .store_dict(compliance_registry)
        .store_dict(admin_list)
        .store_uint(total_approved, 32)
        .store_uint(total_rejected, 32)
        .store_uint(total_expired, 32)
        .end_cell());
}

() check_owner(slice sender_address) impure {
    throw_unless(403, equal_slices_bits(sender_address, owner_address));
}

() check_admin(slice sender_address) impure {
    int sender_hash = slice_hash(sender_address);
    (slice admin_data, int found) = admin_list.udict_get?(267, sender_hash);
    throw_unless(403, found | equal_slices_bits(sender_address, owner_address));
}

;; Submit KYC application
() submit_kyc_application(
    slice applicant,
    int tier,
    int kyc_provider_id,
    cell kyc_data_hash
) impure {
    throw_unless(400, (tier >= TIER_BASIC) & (tier <= TIER_INSTITUTIONAL));

    int applicant_hash = slice_hash(applicant);

    ;; Check for existing application
    (slice existing, int found) = compliance_registry.udict_get?(267, applicant_hash);
    if (found) {
        int status = existing~load_uint(8);
        throw_unless(401, status != STATUS_APPROVED);  ;; Already approved
    }

    ;; Create pending application
    compliance_registry~udict_set(267, applicant_hash,
        begin_cell()
            .store_uint(STATUS_PENDING, 8)
            .store_uint(tier, 8)
            .store_uint(now(), 32)  ;; submission_time
            .store_uint(0, 32)  ;; expiry_time (set on approval)
            .store_uint(kyc_provider_id, 16)
            .store_ref(kyc_data_hash)
            .end_cell().begin_parse());

    save_data();

    emit_log(0xb0, begin_cell()
        .store_slice(applicant)
        .store_uint(tier, 8)
        .store_uint(kyc_provider_id, 16)
        .end_cell().begin_parse());
}

;; Approve KYC (admin only)
() approve_kyc(slice sender_address, slice applicant) impure {
    check_admin(sender_address);

    int applicant_hash = slice_hash(applicant);
    (slice app_data, int found) = compliance_registry.udict_get?(267, applicant_hash);
    throw_unless(404, found);

    int status = app_data~load_uint(8);
    throw_unless(400, status == STATUS_PENDING);

    int tier = app_data~load_uint(8);
    int submission_time = app_data~load_uint(32);
    app_data~skip_bits(32);  ;; Skip old expiry
    int kyc_provider_id = app_data~load_uint(16);
    cell kyc_data_hash = app_data~load_ref();

    ;; Update to approved
    int approval_time = now();
    int expiry_time = approval_time + EXPIRY_PERIOD;

    compliance_registry~udict_set(267, applicant_hash,
        begin_cell()
            .store_uint(STATUS_APPROVED, 8)
            .store_uint(tier, 8)
            .store_uint(approval_time, 32)
            .store_uint(expiry_time, 32)
            .store_uint(kyc_provider_id, 16)
            .store_ref(kyc_data_hash)
            .end_cell().begin_parse());

    total_approved += 1;
    save_data();

    emit_log(0xb1, begin_cell()
        .store_slice(applicant)
        .store_uint(tier, 8)
        .store_uint(expiry_time, 32)
        .end_cell().begin_parse());
}

;; Reject KYC (admin only)
() reject_kyc(slice sender_address, slice applicant, int reason_code) impure {
    check_admin(sender_address);

    int applicant_hash = slice_hash(applicant);
    (slice app_data, int found) = compliance_registry.udict_get?(267, applicant_hash);
    throw_unless(404, found);

    int status = app_data~load_uint(8);
    throw_unless(400, status == STATUS_PENDING);

    int tier = app_data~load_uint(8);
    int submission_time = app_data~load_uint(32);
    app_data~skip_bits(32);
    int kyc_provider_id = app_data~load_uint(16);
    cell kyc_data_hash = app_data~load_ref();

    ;; Update to rejected
    compliance_registry~udict_set(267, applicant_hash,
        begin_cell()
            .store_uint(STATUS_REJECTED, 8)
            .store_uint(tier, 8)
            .store_uint(now(), 32)
            .store_uint(reason_code, 32)
            .store_uint(kyc_provider_id, 16)
            .store_ref(kyc_data_hash)
            .end_cell().begin_parse());

    total_rejected += 1;
    save_data();

    emit_log(0xb2, begin_cell()
        .store_slice(applicant)
        .store_uint(reason_code, 32)
        .end_cell().begin_parse());
}

;; Revoke compliance (admin only)
() revoke_compliance(slice sender_address, slice investor, int reason_code) impure {
    check_admin(sender_address);

    int investor_hash = slice_hash(investor);
    (slice comp_data, int found) = compliance_registry.udict_get?(267, investor_hash);
    throw_unless(404, found);

    int status = comp_data~load_uint(8);
    throw_unless(400, status == STATUS_APPROVED);

    ;; Mark as expired
    int tier = comp_data~load_uint(8);
    compliance_registry~udict_set(267, investor_hash,
        begin_cell()
            .store_uint(STATUS_EXPIRED, 8)
            .store_uint(tier, 8)
            .store_uint(now(), 32)
            .store_uint(reason_code, 32)
            .store_uint(0, 16)
            .store_ref(begin_cell().end_cell())
            .end_cell().begin_parse());

    total_expired += 1;
    save_data();

    emit_log(0xb3, begin_cell()
        .store_slice(investor)
        .store_uint(reason_code, 32)
        .end_cell().begin_parse());
}

;; Check compliance status
() check_compliance_status(slice investor) method_id {
    load_data();
    int investor_hash = slice_hash(investor);
    (slice comp_data, int found) = compliance_registry.udict_get?(267, investor_hash);

    if (~ found) {
        return ();  ;; Not registered
    }

    int status = comp_data~load_uint(8);
    if (status != STATUS_APPROVED) {
        throw(403);  ;; Not approved
    }

    comp_data~skip_bits(8);  ;; Skip tier
    comp_data~skip_bits(32);  ;; Skip approval_time
    int expiry_time = comp_data~load_uint(32);

    ;; Check expiry
    if (now() >= expiry_time) {
        throw(410);  ;; Expired
    }

    return ();  ;; Approved and valid
}

;; Admin: Add admin
() add_admin(slice sender_address, slice admin_address) impure {
    check_owner(sender_address);
    int admin_hash = slice_hash(admin_address);
    admin_list~udict_set(267, admin_hash,
        begin_cell().store_uint(1, 1).end_cell().begin_parse());
    save_data();
}

;; Admin: Remove admin
() remove_admin(slice sender_address, slice admin_address) impure {
    check_owner(sender_address);
    int admin_hash = slice_hash(admin_address);
    admin_list~udict_delete?(267, admin_hash);
    save_data();
}

;; Admin: Set TradFi Buffer
() set_tradfi_buffer(slice sender_address, slice new_address) impure {
    check_owner(sender_address);
    tradfi_buffer_address = new_address;
    save_data();
}

;; Get methods
(int, int, int, int) get_compliance_status(slice investor) method_id {
    load_data();
    int investor_hash = slice_hash(investor);
    (slice comp_data, int found) = compliance_registry.udict_get?(267, investor_hash);

    if (~ found) {
        return (STATUS_PENDING, TIER_NONE, 0, 0);
    }

    int status = comp_data~load_uint(8);
    int tier = comp_data~load_uint(8);
    int approval_time = comp_data~load_uint(32);
    int expiry_time = comp_data~load_uint(32);

    return (status, tier, approval_time, expiry_time);
}

int is_compliant(slice investor) method_id {
    load_data();
    int investor_hash = slice_hash(investor);
    (slice comp_data, int found) = compliance_registry.udict_get?(267, investor_hash);

    if (~ found) {
        return 0;
    }

    int status = comp_data~load_uint(8);
    if (status != STATUS_APPROVED) {
        return 0;
    }

    comp_data~skip_bits(8 + 32);
    int expiry_time = comp_data~load_uint(32);

    if (now() >= expiry_time) {
        return 0;  ;; Expired
    }

    return -1;  ;; True
}

(int, int, int) get_compliance_stats() method_id {
    load_data();
    return (total_approved, total_rejected, total_expired);
}

int is_admin(slice address) method_id {
    load_data();
    int addr_hash = slice_hash(address);
    (slice admin_data, int found) = admin_list.udict_get?(267, addr_hash);
    return found | equal_slices_bits(address, owner_address);
}

;; Recv internal
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == 0x01) {  ;; submit_kyc_application
        int tier = in_msg_body~load_uint(8);
        int kyc_provider_id = in_msg_body~load_uint(16);
        cell kyc_data_hash = in_msg_body~load_ref();
        submit_kyc_application(sender_address, tier, kyc_provider_id, kyc_data_hash);
        return ();
    }

    if (op == 0x02) {  ;; approve_kyc
        slice applicant = in_msg_body~load_msg_addr();
        approve_kyc(sender_address, applicant);
        return ();
    }

    if (op == 0x03) {  ;; reject_kyc
        slice applicant = in_msg_body~load_msg_addr();
        int reason_code = in_msg_body~load_uint(32);
        reject_kyc(sender_address, applicant, reason_code);
        return ();
    }

    if (op == 0x04) {  ;; revoke_compliance
        slice investor = in_msg_body~load_msg_addr();
        int reason_code = in_msg_body~load_uint(32);
        revoke_compliance(sender_address, investor, reason_code);
        return ();
    }

    if (op == 0x10) {  ;; add_admin
        slice admin_address = in_msg_body~load_msg_addr();
        add_admin(sender_address, admin_address);
        return ();
    }

    if (op == 0x11) {  ;; remove_admin
        slice admin_address = in_msg_body~load_msg_addr();
        remove_admin(sender_address, admin_address);
        return ();
    }

    if (op == 0x12) {  ;; set_tradfi_buffer
        slice new_address = in_msg_body~load_msg_addr();
        set_tradfi_buffer(sender_address, new_address);
        return ();
    }

    throw(0xffff);
}

;; Note: emit_log() is now implemented in stdlib.fc
;; ComplianceGateway uses event logging for KYC/AML operations
