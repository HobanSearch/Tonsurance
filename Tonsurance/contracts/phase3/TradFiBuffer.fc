;; TradFiBuffer Contract - Institutional Senior Tranche
;; Third-loss capital from institutional investors
;; $250k minimum deposit, 180-day lock period
;; Fixed 6-10% APY (guaranteed, paid from protocol reserves)
;; KYC/AML compliant via ComplianceGateway
;; Mints SHIELD-INST tokens (restricted)

#include "../imports/stdlib.fc";

;; Storage structure
global slice owner_address;
global slice compliance_gateway_address;
global slice shield_inst_token_address;
global slice premium_distributor_address;
global cell investor_balances;  ;; investor_hash -> (amount, deposit_time, unlock_time, apy_rate)
global int total_deposited;
global int total_withdrawn;
global int total_interest_paid;
global int current_tvl;
global int min_deposit;  ;; Minimum $250k
global int lock_period;  ;; 180 days
global int min_apy;  ;; 6% (basis points)
global int max_apy;  ;; 10% (basis points)

const int BASIS_POINTS = 10000;
const int MIN_DEPOSIT_DEFAULT = 250000000000000;  ;; $250k (assuming 6 decimals)
const int LOCK_PERIOD_DEFAULT = 15552000;  ;; 180 days in seconds
const int MIN_APY_DEFAULT = 600;  ;; 6%
const int MAX_APY_DEFAULT = 1000;  ;; 10%

() load_data() impure {
    slice ds = get_data().begin_parse();
    owner_address = ds~load_msg_addr();
    compliance_gateway_address = ds~load_msg_addr();

    slice ds_ref = ds~load_ref().begin_parse();
    shield_inst_token_address = ds_ref~load_msg_addr();
    premium_distributor_address = ds_ref~load_msg_addr();

    investor_balances = ds~load_dict();
    total_deposited = ds~load_coins();
    total_withdrawn = ds~load_coins();
    total_interest_paid = ds~load_coins();
    current_tvl = ds~load_coins();
    min_deposit = ds~load_coins();
    lock_period = ds~load_uint(32);
    min_apy = ds~load_uint(16);
    max_apy = ds~load_uint(16);
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(owner_address)
        .store_slice(compliance_gateway_address)
        .store_ref(
            begin_cell()
                .store_slice(shield_inst_token_address)
                .store_slice(premium_distributor_address)
                .end_cell()
        )
        .store_dict(investor_balances)
        .store_coins(total_deposited)
        .store_coins(total_withdrawn)
        .store_coins(total_interest_paid)
        .store_coins(current_tvl)
        .store_coins(min_deposit)
        .store_uint(lock_period, 32)
        .store_uint(min_apy, 16)
        .store_uint(max_apy, 16)
        .end_cell());
}

() check_owner(slice sender_address) impure {
    throw_unless(403, equal_slices_bits(sender_address, owner_address));
}

;; Check KYC/AML compliance
() check_compliance(slice investor_address) impure {
    ;; Query ComplianceGateway
    ;; In production: send get_compliance_status message
    ;; For now: simplified check
    ;; throw_unless(403, is_kyc_approved(investor_address));
}

;; Institutional deposit
() deposit_capital(slice investor, int amount, int apy_rate) impure {
    throw_unless(400, amount >= min_deposit);  ;; Minimum $250k
    throw_unless(400, (apy_rate >= min_apy) & (apy_rate <= max_apy));  ;; 6-10% APY

    ;; Check KYC compliance
    check_compliance(investor);

    int investor_hash = slice_hash(investor);

    ;; Check for existing deposit
    (slice existing, int found) = investor_balances.udict_get?(267, investor_hash);
    throw_unless(402, ~ found);  ;; One deposit per investor for simplicity

    ;; Record deposit
    int deposit_time = now();
    int unlock_time = deposit_time + lock_period;

    investor_balances~udict_set(267, investor_hash,
        begin_cell()
            .store_coins(amount)
            .store_uint(deposit_time, 32)
            .store_uint(unlock_time, 32)
            .store_uint(apy_rate, 16)
            .end_cell().begin_parse());

    total_deposited += amount;
    current_tvl += amount;
    save_data();

    ;; Mint SHIELD-INST tokens
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(shield_inst_token_address)
        .store_coins(100000000)  ;; Gas
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(
            begin_cell()
                .store_uint(21, 32)  ;; op: mint
                .store_uint(0, 64)  ;; query_id
                .store_slice(investor)
                .store_coins(amount)
                .store_slice(investor)  ;; response_address
                .store_uint(lock_period / 86400, 16)  ;; lock duration in days
                .end_cell()
        )
        .end_cell();

    send_raw_message(msg, 1);

    ;; Emit event
    emit_log(0xa0, begin_cell()
        .store_slice(investor)
        .store_coins(amount)
        .store_uint(apy_rate, 16)
        .store_uint(unlock_time, 32)
        .end_cell().begin_parse());
}

;; Withdraw capital + interest
() withdraw_capital(slice sender_address, slice investor) impure {
    int investor_hash = slice_hash(investor);

    ;; Check sender
    throw_unless(403, equal_slices_bits(sender_address, investor));

    ;; Get deposit info
    (slice deposit_data, int found) = investor_balances.udict_get?(267, investor_hash);
    throw_unless(404, found);

    int amount = deposit_data~load_coins();
    int deposit_time = deposit_data~load_uint(32);
    int unlock_time = deposit_data~load_uint(32);
    int apy_rate = deposit_data~load_uint(16);

    ;; Check unlock time
    throw_unless(410, now() >= unlock_time);

    ;; Calculate interest
    int time_locked = unlock_time - deposit_time;
    int interest = muldiv(amount, apy_rate, BASIS_POINTS);
    interest = muldiv(interest, time_locked, 31536000);  ;; Annualize

    int total_payout = amount + interest;

    ;; Remove deposit
    investor_balances~udict_delete?(267, investor_hash);

    total_withdrawn += amount;
    total_interest_paid += interest;
    current_tvl -= amount;
    save_data();

    ;; Burn SHIELD-INST tokens
    cell msg_burn = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(shield_inst_token_address)
        .store_coins(50000000)  ;; Gas
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(
            begin_cell()
                .store_uint(0x595f07bc, 32)  ;; op: burn_notification
                .store_uint(0, 64)  ;; query_id
                .store_coins(amount)
                .store_slice(investor)
                .store_slice(investor)  ;; response_address
                .end_cell()
        )
        .end_cell();

    send_raw_message(msg_burn, 1);

    ;; Send capital + interest
    cell msg_payout = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(investor)
        .store_coins(total_payout)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x0b, 32)  ;; op: tradfi_withdrawal
        .store_coins(amount)
        .store_coins(interest)
        .end_cell();

    send_raw_message(msg_payout, 1);

    ;; Emit event
    emit_log(0xa1, begin_cell()
        .store_slice(investor)
        .store_coins(amount)
        .store_coins(interest)
        .end_cell().begin_parse());
}

;; Receive premium share (from AdvancedPremiumDistributor)
() receive_premium_share(int amount, int policy_id) impure {
    ;; Add to TVL (helps cover guaranteed APY)
    current_tvl += amount;
    save_data();

    emit_log(0xa2, begin_cell()
        .store_coins(amount)
        .store_uint(policy_id, 64)
        .store_coins(current_tvl)
        .end_cell().begin_parse());
}

;; Absorb claim loss (third-loss in waterfall)
() absorb_claim_loss(int loss_amount, slice claimant) impure {
    ;; Only called after Primary and Secondary exhausted
    throw_unless(400, current_tvl >= loss_amount);

    current_tvl -= loss_amount;
    save_data();

    ;; Send payout to claimant
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(claimant)
        .store_coins(loss_amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x0c, 32)  ;; op: claim_payout
        .store_coins(loss_amount)
        .end_cell();

    send_raw_message(msg, 1);

    emit_log(0xa3, begin_cell()
        .store_slice(claimant)
        .store_coins(loss_amount)
        .store_coins(current_tvl)
        .end_cell().begin_parse());
}

;; Admin functions
() set_compliance_gateway(slice sender_address, slice new_address) impure {
    check_owner(sender_address);
    compliance_gateway_address = new_address;
    save_data();
}

() set_shield_inst_token(slice sender_address, slice new_address) impure {
    check_owner(sender_address);
    shield_inst_token_address = new_address;
    save_data();
}

() set_min_deposit(slice sender_address, int new_min) impure {
    check_owner(sender_address);
    min_deposit = new_min;
    save_data();
}

() set_apy_range(slice sender_address, int new_min, int new_max) impure {
    check_owner(sender_address);
    throw_unless(400, (new_min >= 0) & (new_max <= 10000));
    throw_unless(401, new_min <= new_max);
    min_apy = new_min;
    max_apy = new_max;
    save_data();
}

;; Get methods
(int, int, int) get_investor_deposit(slice investor) method_id {
    load_data();
    int investor_hash = slice_hash(investor);
    (slice deposit_data, int found) = investor_balances.udict_get?(267, investor_hash);

    if (~ found) {
        return (0, 0, 0);
    }

    int amount = deposit_data~load_coins();
    int deposit_time = deposit_data~load_uint(32);
    int unlock_time = deposit_data~load_uint(32);
    int apy_rate = deposit_data~load_uint(16);

    return (amount, unlock_time, apy_rate);
}

(int, int, int, int) get_buffer_stats() method_id {
    load_data();
    return (total_deposited, total_withdrawn, total_interest_paid, current_tvl);
}

int get_min_deposit() method_id {
    load_data();
    return min_deposit;
}

(int, int) get_apy_range() method_id {
    load_data();
    return (min_apy, max_apy);
}

int get_lock_period() method_id {
    load_data();
    return lock_period;
}

;; Recv internal
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == 0x01) {  ;; deposit_capital
        int amount = in_msg_body~load_coins();
        int apy_rate = in_msg_body~load_uint(16);
        deposit_capital(sender_address, amount, apy_rate);
        return ();
    }

    if (op == 0x02) {  ;; withdraw_capital
        withdraw_capital(sender_address, sender_address);
        return ();
    }

    if (op == 0x06) {  ;; receive_premium_share
        int amount = in_msg_body~load_coins();
        int policy_id = in_msg_body~load_uint(64);
        receive_premium_share(amount, policy_id);
        return ();
    }

    if (op == 0x04) {  ;; absorb_claim_loss
        int loss_amount = in_msg_body~load_coins();
        slice claimant = in_msg_body~load_msg_addr();
        absorb_claim_loss(loss_amount, claimant);
        return ();
    }

    if (op == 0x10) {  ;; set_compliance_gateway
        slice new_address = in_msg_body~load_msg_addr();
        set_compliance_gateway(sender_address, new_address);
        return ();
    }

    if (op == 0x11) {  ;; set_shield_inst_token
        slice new_address = in_msg_body~load_msg_addr();
        set_shield_inst_token(sender_address, new_address);
        return ();
    }

    if (op == 0x12) {  ;; set_min_deposit
        int new_min = in_msg_body~load_coins();
        set_min_deposit(sender_address, new_min);
        return ();
    }

    if (op == 0x13) {  ;; set_apy_range
        int new_min = in_msg_body~load_uint(16);
        int new_max = in_msg_body~load_uint(16);
        set_apy_range(sender_address, new_min, new_max);
        return ();
    }

    throw(0xffff);
}

;; Note: emit_log() is now implemented in stdlib.fc
;; TradFiBuffer uses event logging for institutional deposit/withdrawal operations
