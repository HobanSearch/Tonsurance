;; ClaimsProcessor Contract - Claims Management & Verification
;; Auto-verification for USDT depeg, protocol exploits, bridge hacks
;; Admin approval for subjective claims
;; Loss waterfall: Primary → Secondary → TradFi

#include "../imports/stdlib.fc";

;; Storage structure
global slice owner_address;
global int next_claim_id;
global cell claims_dict;  ;; claim_id -> claim_data
global slice treasury_address;
global slice primary_vault_address;
global slice secondary_vault_address;
global slice tradfi_buffer_address;
global slice price_oracle_address;
global int auto_approval_threshold;  ;; Basis points
global cell verified_events;  ;; event_hash -> verified flag

;; Claim statuses
const int STATUS_PENDING = 0;
const int STATUS_APPROVED = 1;
const int STATUS_REJECTED = 2;

;; Forward declarations
() save_data() impure;
() auto_verify_claim(int claim_id, int coverage_type, int coverage_amount) impure;
() approve_claim(int claim_id, int auto_approved) impure;
() reject_claim(int claim_id) impure;
() process_payout_waterfall(slice user_address, int payout_amount) impure;

;; Helper: Check if dict has any entries (works for both null and empty dicts)
int dict_has_entries(cell dict) inline {
    if (cell_null?(dict)) {
        return 0;  ;; Null dict = no entries
    }
    (int key, slice val, int success) = dict.udict_get_min?(256);
    return success;  ;; Returns 1 if at least one entry exists
}

() load_data() impure {
    slice ds = get_data().begin_parse();
    owner_address = ds~load_msg_addr();
    next_claim_id = ds~load_uint(64);
    claims_dict = ds~load_dict();

    ;; Load vault addresses from first reference cell
    slice vaults_cell = ds~load_ref().begin_parse();
    treasury_address = vaults_cell~load_msg_addr();
    primary_vault_address = vaults_cell~load_msg_addr();
    secondary_vault_address = vaults_cell~load_msg_addr();

    ;; Load oracle addresses from second reference cell
    slice oracles_cell = ds~load_ref().begin_parse();
    tradfi_buffer_address = oracles_cell~load_msg_addr();
    price_oracle_address = oracles_cell~load_msg_addr();

    auto_approval_threshold = ds~load_uint(16);
    verified_events = ds~load_dict();
}

() save_data() impure {
    ;; Store vault addresses in first reference cell
    cell vaults = begin_cell()
        .store_slice(treasury_address)
        .store_slice(primary_vault_address)
        .store_slice(secondary_vault_address)
        .end_cell();

    ;; Store oracle addresses in second reference cell
    cell oracles = begin_cell()
        .store_slice(tradfi_buffer_address)
        .store_slice(price_oracle_address)
        .end_cell();

    set_data(begin_cell()
        .store_slice(owner_address)
        .store_uint(next_claim_id, 64)
        .store_dict(claims_dict)
        .store_ref(vaults)
        .store_ref(oracles)
        .store_uint(auto_approval_threshold, 16)
        .store_dict(verified_events)
        .end_cell());
}

() check_owner(slice sender_address) impure {
    throw_unless(403, equal_slices_bits(sender_address, owner_address));
}

;; File a claim
() file_claim(
    slice user_address,
    int policy_id,
    int coverage_type,
    int coverage_amount,
    cell evidence_cell
) impure {
    ;; Create claim
    int claim_id = next_claim_id;
    int claim_time = now();

    cell claim_data = begin_cell()
        .store_uint(claim_id, 64)
        .store_uint(policy_id, 64)
        .store_slice(user_address)
        .store_uint(coverage_type, 8)
        .store_coins(coverage_amount)
        .store_uint(claim_time, 32)
        .store_uint(STATUS_PENDING, 8)
        .store_uint(0, 1)  ;; auto_approved flag
        .store_ref(evidence_cell)
        .end_cell();

    claims_dict~udict_set(64, claim_id, claim_data.begin_parse());
    next_claim_id += 1;
    save_data();

    ;; Attempt auto-verification
    auto_verify_claim(claim_id, coverage_type, coverage_amount);

    ;; Emit event
    emit_log(0x40, begin_cell()
        .store_uint(claim_id, 64)
        .store_uint(policy_id, 64)
        .store_slice(user_address)
        .store_uint(coverage_type, 8)
        .store_coins(coverage_amount)
        .end_cell().begin_parse());
}

;; Auto-verification logic
() auto_verify_claim(int claim_id, int coverage_type, int coverage_amount) impure {
    ;; For auto-verifiable types (USDT depeg, protocol exploit, bridge hack)
    ;; Check if ANY verified event exists
    if ((coverage_type >= 1) & (coverage_type <= 3)) {
        if (dict_has_entries(verified_events)) {
            approve_claim(claim_id, 1);  ;; 1 = auto-approved
        }
    }
    ;; Otherwise, claim stays PENDING for admin review
}

;; Admin approve claim (owner only)
() admin_approve_claim(slice sender_address, int claim_id) impure {
    check_owner(sender_address);
    approve_claim(claim_id, 0);  ;; 0 = manually approved
}

;; Admin reject claim (owner only)
() admin_reject_claim(slice sender_address, int claim_id) impure {
    check_owner(sender_address);
    reject_claim(claim_id);
}

;; Approve claim and process payout with loss waterfall
() approve_claim(int claim_id, int auto_approved) impure {
    ;; Get and update claim status to APPROVED
    (slice claim_data, int found) = claims_dict.udict_get?(64, claim_id);
    throw_unless(404, found);

    ;; Parse claim
    int cid = claim_data~load_uint(64);
    int policy_id = claim_data~load_uint(64);
    slice user_address = claim_data~load_msg_addr();
    int coverage_type = claim_data~load_uint(8);
    int coverage_amount = claim_data~load_coins();
    int claim_time = claim_data~load_uint(32);
    int old_status = claim_data~load_uint(8);
    int old_auto = claim_data~load_uint(1);
    cell evidence = claim_data~load_ref();

    ;; Rebuild with APPROVED status
    cell updated_claim = begin_cell()
        .store_uint(cid, 64)
        .store_uint(policy_id, 64)
        .store_slice(user_address)
        .store_uint(coverage_type, 8)
        .store_coins(coverage_amount)
        .store_uint(claim_time, 32)
        .store_uint(STATUS_APPROVED, 8)
        .store_uint(auto_approved, 1)
        .store_ref(evidence)
        .end_cell();

    claims_dict~udict_set(64, claim_id, updated_claim.begin_parse());
    save_data();

    ;; Process payout with loss waterfall
    process_payout_waterfall(user_address, coverage_amount);

    ;; Emit approval event
    emit_log(0x43, begin_cell()
        .store_uint(claim_id, 64)
        .store_coins(coverage_amount)
        .store_uint(auto_approved, 1)
        .end_cell().begin_parse());
}

;; Loss waterfall: Primary → Secondary → TradFi
() process_payout_waterfall(slice user_address, int payout_amount) impure {
    ;; Try Primary Vault first
    ;; In production: query vault balance
    int primary_capacity = 30000000000000;  ;; Placeholder: 30M

    if (payout_amount <= primary_capacity) {
        ;; Request payout from Primary Vault
        cell msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(primary_vault_address)
            .store_coins(50000000)  ;; 0.05 TON for gas
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0x04, 32)  ;; op: absorb_claim_loss
            .store_coins(payout_amount)
            .store_slice(user_address)
            .end_cell();
        send_raw_message(msg, 1);  ;; Send with separate gas payment
    } else {
        ;; Exhaust Primary, cascade to Secondary
        cell msg_primary = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(primary_vault_address)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0x04, 32)
            .store_coins(primary_capacity)
            .store_slice(user_address)
            .end_cell();
        send_raw_message(msg_primary, 64);

        int remaining = payout_amount - primary_capacity;

        ;; Try Secondary Vault
        cell msg_secondary = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(secondary_vault_address)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0x04, 32)
            .store_coins(remaining)
            .store_slice(user_address)
            .end_cell();
        send_raw_message(msg_secondary, 64);
    }
}

;; Reject claim
() reject_claim(int claim_id) impure {
    ;; Get and update claim status to REJECTED
    (slice claim_data, int found) = claims_dict.udict_get?(64, claim_id);
    throw_unless(404, found);

    ;; Parse claim
    int cid = claim_data~load_uint(64);
    int policy_id = claim_data~load_uint(64);
    slice user_address = claim_data~load_msg_addr();
    int coverage_type = claim_data~load_uint(8);
    int coverage_amount = claim_data~load_coins();
    int claim_time = claim_data~load_uint(32);
    int old_status = claim_data~load_uint(8);
    int old_auto = claim_data~load_uint(1);
    cell evidence = claim_data~load_ref();

    ;; Rebuild with REJECTED status
    cell updated_claim = begin_cell()
        .store_uint(cid, 64)
        .store_uint(policy_id, 64)
        .store_slice(user_address)
        .store_uint(coverage_type, 8)
        .store_coins(coverage_amount)
        .store_uint(claim_time, 32)
        .store_uint(STATUS_REJECTED, 8)
        .store_uint(0, 1)  ;; not auto-approved
        .store_ref(evidence)
        .end_cell();

    claims_dict~udict_set(64, claim_id, updated_claim.begin_parse());
    save_data();

    emit_log(0x44, begin_cell()
        .store_uint(claim_id, 64)
        .end_cell().begin_parse());
}

;; Admin functions
() add_verified_event(slice sender_address, int event_hash) impure {
    check_owner(sender_address);
    verified_events~udict_set(256, event_hash,
        begin_cell().store_uint(1, 1).end_cell().begin_parse());
    save_data();
}

;; Get methods
(int, int, int) get_claim_status(int claim_id) method_id {
    load_data();
    (slice claim_data, int found) = claims_dict.udict_get?(64, claim_id);
    if (~ found) {
        return (0, 0, 0);
    }
    claim_data~skip_bits(64 + 64);  ;; Skip claim_id, policy_id
    claim_data~load_msg_addr();  ;; Properly skip variable-length address
    claim_data~skip_bits(8);  ;; Skip coverage_type
    int coverage_amount = claim_data~load_coins();
    claim_data~skip_bits(32);  ;; Skip claim_time
    int status = claim_data~load_uint(8);
    int auto_approved = claim_data~load_uint(1);
    return (status, auto_approved, coverage_amount);
}

;; Recv internal
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == 0x01) {  ;; file_claim
        int policy_id = in_msg_body~load_uint(64);
        int coverage_type = in_msg_body~load_uint(8);
        int coverage_amount = in_msg_body~load_coins();
        cell evidence = in_msg_body~load_ref();
        file_claim(sender_address, policy_id, coverage_type, coverage_amount, evidence);
        return ();
    }

    if (op == 0x02) {  ;; admin_approve_claim
        int claim_id = in_msg_body~load_uint(64);
        admin_approve_claim(sender_address, claim_id);
        return ();
    }

    if (op == 0x03) {  ;; admin_reject_claim
        int claim_id = in_msg_body~load_uint(64);
        admin_reject_claim(sender_address, claim_id);
        return ();
    }

    if (op == 0x10) {  ;; add_verified_event
        int event_hash = in_msg_body~load_uint(256);
        add_verified_event(sender_address, event_hash);
        return ();
    }

    throw(0xffff);
}

;; Note: emit_log() is now implemented in stdlib.fc
;; ClaimsProcessor uses the following event IDs for audit trail:
;; 0x40: ClaimSubmitted
;; 0x43: ClaimApproved
;; 0x44: ClaimRejected
