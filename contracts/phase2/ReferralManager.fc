;; ReferralManager Contract - 5-Level Referral Chain
;; Tracks referral chains up to 5 levels deep
;; Reward splits: L1: 60%, L2: 25%, L3: 10%, L4: 3%, L5: 2%
;; Prevents cycles and orphaned users

#include "../imports/stdlib.fc";

;; Storage structure
global slice owner_address;
global cell referral_chains;  ;; user_hash -> referrer_address
global cell referral_stats;   ;; user_hash -> (total_earned, referral_count)
global int total_referral_rewards_distributed;

;; Referral splits (in basis points)
const int SPLIT_LEVEL_1 = 6000;  ;; 60%
const int SPLIT_LEVEL_2 = 2500;  ;; 25%
const int SPLIT_LEVEL_3 = 1000;  ;; 10%
const int SPLIT_LEVEL_4 = 300;   ;; 3%
const int SPLIT_LEVEL_5 = 200;   ;; 2%
const int BASIS_POINTS = 10000;

;; Forward declarations
() save_data() impure;
() send_reward(slice referrer, int amount, int level, int policy_id) impure;

() load_data() impure {
    slice ds = get_data().begin_parse();
    owner_address = ds~load_msg_addr();
    referral_chains = ds~load_dict();
    referral_stats = ds~load_dict();
    total_referral_rewards_distributed = ds~load_coins();
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(owner_address)
        .store_dict(referral_chains)
        .store_dict(referral_stats)
        .store_coins(total_referral_rewards_distributed)
        .end_cell());
}

() check_owner(slice sender_address) impure {
    throw_unless(403, equal_slices_bits(sender_address, owner_address));
}

;; Register referral relationship
() register_referral(slice user_address, slice referrer_address) impure {
    int user_hash = slice_hash(user_address);
    int referrer_hash = slice_hash(referrer_address);

    ;; Check user doesn't already have a referrer
    (slice existing_referrer, int found) = referral_chains.udict_get?(267, user_hash);
    throw_if(400, found);  ;; User already has referrer

    ;; Prevent self-referral
    throw_if(400, user_hash == referrer_hash);

    ;; Prevent cycles - check if user is already in referrer's chain
    int check_hash = referrer_hash;
    int depth = 0;
    while (depth < 5) {
        (slice check_ref, int check_found) = referral_chains.udict_get?(267, check_hash);
        if (check_found) {
            slice check_addr = check_ref~load_msg_addr();
            int check_next_hash = slice_hash(check_addr);
            throw_if(400, check_next_hash == user_hash);  ;; Cycle detected
            check_hash = check_next_hash;
            depth += 1;
        } else {
            depth = 5;  ;; Break loop
        }
    }

    ;; Store referral relationship
    referral_chains~udict_set(267, user_hash,
        begin_cell().store_slice(referrer_address).end_cell().begin_parse());

    ;; Update referrer's referral count
    (slice stats_data, int stats_found) = referral_stats.udict_get?(267, referrer_hash);
    int total_earned = 0;
    int referral_count = 0;
    if (stats_found) {
        total_earned = stats_data~load_coins();
        referral_count = stats_data~load_uint(32);
    }
    referral_count += 1;
    referral_stats~udict_set(267, referrer_hash,
        begin_cell()
            .store_coins(total_earned)
            .store_uint(referral_count, 32)
            .end_cell().begin_parse());

    save_data();

    ;; Emit event
    emit_log(0x70, begin_cell()
        .store_slice(user_address)
        .store_slice(referrer_address)
        .end_cell().begin_parse());
}

;; Get referral chain (up to 5 levels)
(slice, slice, slice, slice, slice, int) get_referral_chain(slice user_address) inline {
    int user_hash = slice_hash(user_address);

    slice level1 = null();
    slice level2 = null();
    slice level3 = null();
    slice level4 = null();
    slice level5 = null();
    int chain_length = 0;

    ;; Level 1
    (slice ref1, int found1) = referral_chains.udict_get?(267, user_hash);
    if (found1) {
        level1 = ref1~load_msg_addr();
        chain_length = 1;

        ;; Level 2
        int ref1_hash = slice_hash(level1);
        (slice ref2, int found2) = referral_chains.udict_get?(267, ref1_hash);
        if (found2) {
            level2 = ref2~load_msg_addr();
            chain_length = 2;

            ;; Level 3
            int ref2_hash = slice_hash(level2);
            (slice ref3, int found3) = referral_chains.udict_get?(267, ref2_hash);
            if (found3) {
                level3 = ref3~load_msg_addr();
                chain_length = 3;

                ;; Level 4
                int ref3_hash = slice_hash(level3);
                (slice ref4, int found4) = referral_chains.udict_get?(267, ref3_hash);
                if (found4) {
                    level4 = ref4~load_msg_addr();
                    chain_length = 4;

                    ;; Level 5
                    int ref4_hash = slice_hash(level4);
                    (slice ref5, int found5) = referral_chains.udict_get?(267, ref4_hash);
                    if (found5) {
                        level5 = ref5~load_msg_addr();
                        chain_length = 5;
                    }
                }
            }
        }
    }

    return (level1, level2, level3, level4, level5, chain_length);
}

;; Distribute referral rewards across chain
() distribute_referral_rewards(
    int total_amount,
    slice user_address,
    int policy_id
) impure {
    ;; Get referral chain
    (slice l1, slice l2, slice l3, slice l4, slice l5, int chain_length) = get_referral_chain(user_address);

    if (chain_length == 0) {
        ;; No referrers - return funds to sender
        ;; In production: send to protocol treasury or burn
        return ();
    }

    ;; Calculate and distribute rewards based on chain length
    if (chain_length >= 1) {
        int level1_amount = muldiv(total_amount, SPLIT_LEVEL_1, BASIS_POINTS);
        send_reward(l1, level1_amount, 1, policy_id);
    }

    if (chain_length >= 2) {
        int level2_amount = muldiv(total_amount, SPLIT_LEVEL_2, BASIS_POINTS);
        send_reward(l2, level2_amount, 2, policy_id);
    }

    if (chain_length >= 3) {
        int level3_amount = muldiv(total_amount, SPLIT_LEVEL_3, BASIS_POINTS);
        send_reward(l3, level3_amount, 3, policy_id);
    }

    if (chain_length >= 4) {
        int level4_amount = muldiv(total_amount, SPLIT_LEVEL_4, BASIS_POINTS);
        send_reward(l4, level4_amount, 4, policy_id);
    }

    if (chain_length >= 5) {
        int level5_amount = muldiv(total_amount, SPLIT_LEVEL_5, BASIS_POINTS);
        send_reward(l5, level5_amount, 5, policy_id);
    }

    total_referral_rewards_distributed += total_amount;
    save_data();
}

;; Send reward to referrer
() send_reward(slice referrer, int amount, int level, int policy_id) impure {
    ;; Update referrer stats - only total_earned, not referral_count
    int referrer_hash = slice_hash(referrer);
    (slice stats_data, int found) = referral_stats.udict_get?(267, referrer_hash);

    int total_earned = 0;
    int referral_count = 0;

    if (found) {
        total_earned = stats_data~load_coins();
        referral_count = stats_data~load_uint(32);
    }

    total_earned += amount;
    ;; referral_count is NOT incremented here - it's updated in register_referral

    referral_stats~udict_set(267, referrer_hash,
        begin_cell()
            .store_coins(total_earned)
            .store_uint(referral_count, 32)
            .end_cell().begin_parse());

    ;; Send payment
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(referrer)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x07, 32)  ;; op: referral_reward_received
        .store_coins(amount)
        .store_uint(level, 8)
        .store_uint(policy_id, 64)
        .end_cell();

    send_raw_message(msg, 1);

    ;; Emit event
    emit_log(0x71, begin_cell()
        .store_slice(referrer)
        .store_coins(amount)
        .store_uint(level, 8)
        .store_uint(policy_id, 64)
        .end_cell().begin_parse());
}

;; Get methods
(int, int) get_referrer_stats(slice referrer) method_id {
    load_data();
    int referrer_hash = slice_hash(referrer);
    (slice stats_data, int found) = referral_stats.udict_get?(267, referrer_hash);

    if (~ found) {
        return (0, 0);
    }

    int total_earned = stats_data~load_coins();
    int referral_count = stats_data~load_uint(32);

    return (total_earned, referral_count);
}

slice get_direct_referrer(slice user) method_id {
    load_data();
    int user_hash = slice_hash(user);
    (slice referrer_data, int found) = referral_chains.udict_get?(267, user_hash);

    if (~ found) {
        return null();
    }

    return referrer_data~load_msg_addr();
}

(slice, slice, slice, slice, slice, int) get_full_chain(slice user) method_id {
    load_data();
    return get_referral_chain(user);
}

int get_total_referral_rewards() method_id {
    load_data();
    return total_referral_rewards_distributed;
}

;; Recv internal
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == 0x01) {  ;; register_referral
        slice user_address = in_msg_body~load_msg_addr();
        slice referrer_address = in_msg_body~load_msg_addr();
        register_referral(user_address, referrer_address);
        return ();
    }

    if (op == 0x03) {  ;; distribute_referral_rewards
        int total_amount = in_msg_body~load_coins();
        slice user_address = in_msg_body~load_msg_addr();
        int policy_id = in_msg_body~load_uint(64);
        distribute_referral_rewards(total_amount, user_address, policy_id);
        return ();
    }

    throw(0xffff);
}

;; Note: emit_log() is now implemented in stdlib.fc
;; ReferralManager uses event logging for referral reward operations
