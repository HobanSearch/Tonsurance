;; GovernanceRewards Contract - Governance Participation Incentives
;; Receives 2% of premiums from AdvancedPremiumDistributor
;; Distributes rewards to SURE token holders who vote on claims
;; Rewards proportional to voting power (staked SURE) and participation frequency
;; Penalty for not voting or voting against consensus

#include "../imports/stdlib.fc";

;; Storage structure
global slice owner_address;
global slice premium_distributor_address;
global slice claims_processor_address;
global cell voter_registry;  ;; voter_address_hash -> (total_earned, vote_count, participation_rate)
global cell pending_rewards;  ;; voter_address_hash -> pending_amount
global int total_rewards_distributed;
global int total_rewards_pending;
global int min_voting_power;  ;; Minimum SURE tokens to earn rewards
global int participation_bonus_threshold;  ;; Minimum participation rate for bonus (basis points)

;; Reward parameters
const int BASE_REWARD_PER_VOTE = 50000000;  ;; 0.05 TON base reward
const int PARTICIPATION_BONUS_MULTIPLIER = 15000;  ;; 1.5x bonus (basis points)
const int CONSENSUS_BONUS = 2000;  ;; 20% bonus for voting with majority
const int DISSENT_PENALTY = 3000;  ;; 30% penalty for voting against majority
const int BASIS_POINTS = 10000;

() load_data() impure {
    slice ds = get_data().begin_parse();
    owner_address = ds~load_msg_addr();
    premium_distributor_address = ds~load_msg_addr();
    claims_processor_address = ds~load_msg_addr();
    voter_registry = ds~load_dict();
    pending_rewards = ds~load_dict();
    total_rewards_distributed = ds~load_coins();
    total_rewards_pending = ds~load_coins();
    min_voting_power = ds~load_coins();
    participation_bonus_threshold = ds~load_uint(16);
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(owner_address)
        .store_slice(premium_distributor_address)
        .store_slice(claims_processor_address)
        .store_dict(voter_registry)
        .store_dict(pending_rewards)
        .store_coins(total_rewards_distributed)
        .store_coins(total_rewards_pending)
        .store_coins(min_voting_power)
        .store_uint(participation_bonus_threshold, 16)
        .end_cell());
}

() check_owner(slice sender_address) impure {
    throw_unless(403, equal_slices_bits(sender_address, owner_address));
}

() check_distributor(slice sender_address) impure {
    throw_unless(403, equal_slices_bits(sender_address, premium_distributor_address));
}

() check_claims_processor(slice sender_address) impure {
    throw_unless(403, equal_slices_bits(sender_address, claims_processor_address));
}

;; Receive governance share from Premium Distributor
() receive_governance_share(slice sender_address, int amount) impure {
    check_distributor(sender_address);

    ;; Add to pending rewards pool
    total_rewards_pending += amount;
    save_data();

    ;; Emit event
    emit_log(0x94, begin_cell()
        .store_coins(amount)
        .store_coins(total_rewards_pending)
        .end_cell().begin_parse());
}

;; Register voter
() register_voter(slice voter_address) impure {
    int voter_hash = slice_hash(voter_address);

    ;; Check if already registered
    (slice existing, int found) = voter_registry.udict_get?(267, voter_hash);
    if (found) {
        return ();  ;; Already registered
    }

    ;; Initialize voter stats
    voter_registry~udict_set(267, voter_hash,
        begin_cell()
            .store_coins(0)  ;; total_earned
            .store_uint(0, 32)  ;; vote_count
            .store_uint(10000, 16)  ;; participation_rate (100% default)
            .store_uint(0, 32)  ;; last_vote_time
            .end_cell().begin_parse());

    save_data();

    emit_log(0x95, begin_cell()
        .store_slice(voter_address)
        .end_cell().begin_parse());
}

;; Record vote and calculate reward
() record_vote(
    slice sender_address,
    slice voter_address,
    int voting_power,
    int voted_with_majority,
    int participation_rate
) impure {
    check_claims_processor(sender_address);

    ;; Check minimum voting power
    throw_unless(400, voting_power >= min_voting_power);

    int voter_hash = slice_hash(voter_address);

    ;; Auto-register if not registered
    (slice voter_data, int found) = voter_registry.udict_get?(267, voter_hash);
    if (~ found) {
        register_voter(voter_address);
        (voter_data, found) = voter_registry.udict_get?(267, voter_hash);
    }

    ;; Parse current stats
    int total_earned = voter_data~load_coins();
    int vote_count = voter_data~load_uint(32);
    int prev_participation = voter_data~load_uint(16);
    int last_vote_time = voter_data~load_uint(32);

    ;; Calculate reward
    int base_reward = BASE_REWARD_PER_VOTE;

    ;; Scale by voting power (linear)
    int scaled_reward = muldiv(base_reward, voting_power, min_voting_power);

    ;; Participation bonus
    if (participation_rate >= participation_bonus_threshold) {
        scaled_reward = muldiv(scaled_reward, PARTICIPATION_BONUS_MULTIPLIER, BASIS_POINTS);
    }

    ;; Consensus bonus/penalty
    if (voted_with_majority) {
        scaled_reward = muldiv(scaled_reward, BASIS_POINTS + CONSENSUS_BONUS, BASIS_POINTS);
    } else {
        scaled_reward = muldiv(scaled_reward, BASIS_POINTS - DISSENT_PENALTY, BASIS_POINTS);
    }

    ;; Check sufficient pending rewards
    throw_unless(411, total_rewards_pending >= scaled_reward);

    ;; Update voter stats
    vote_count += 1;
    total_earned += scaled_reward;

    ;; Update participation rate (exponential moving average)
    int updated_participation = muldiv(prev_participation, 90, 100) + muldiv(participation_rate, 10, 100);

    voter_registry~udict_set(267, voter_hash,
        begin_cell()
            .store_coins(total_earned)
            .store_uint(vote_count, 32)
            .store_uint(updated_participation, 16)
            .store_uint(now(), 32)
            .end_cell().begin_parse());

    ;; Add to pending rewards for voter
    (slice pending_data, int has_pending) = pending_rewards.udict_get?(267, voter_hash);
    int pending_amount = 0;
    if (has_pending) {
        pending_amount = pending_data~load_coins();
    }
    pending_amount += scaled_reward;

    pending_rewards~udict_set(267, voter_hash,
        begin_cell().store_coins(pending_amount).end_cell().begin_parse());

    total_rewards_pending -= scaled_reward;
    save_data();

    emit_log(0x96, begin_cell()
        .store_slice(voter_address)
        .store_coins(scaled_reward)
        .store_coins(voting_power)
        .store_uint(voted_with_majority, 1)
        .end_cell().begin_parse());
}

;; Claim pending rewards
() claim_rewards(slice sender_address, slice voter_address) impure {
    int voter_hash = slice_hash(voter_address);

    ;; Check sender is voter
    throw_unless(403, equal_slices_bits(sender_address, voter_address));

    ;; Get pending rewards
    (slice pending_data, int found) = pending_rewards.udict_get?(267, voter_hash);
    throw_unless(404, found);

    int pending_amount = pending_data~load_coins();
    throw_unless(400, pending_amount > 0);

    ;; Clear pending rewards
    pending_rewards~udict_delete?(267, voter_hash);

    total_rewards_distributed += pending_amount;
    save_data();

    ;; Send payment
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(voter_address)
        .store_coins(pending_amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x0a, 32)  ;; op: governance_reward_claimed
        .store_coins(pending_amount)
        .end_cell();

    send_raw_message(msg, 1);

    emit_log(0x97, begin_cell()
        .store_slice(voter_address)
        .store_coins(pending_amount)
        .end_cell().begin_parse());
}

;; Admin: Set premium distributor
() set_premium_distributor(slice sender_address, slice new_address) impure {
    check_owner(sender_address);
    premium_distributor_address = new_address;
    save_data();
}

;; Admin: Set claims processor
() set_claims_processor(slice sender_address, slice new_address) impure {
    check_owner(sender_address);
    claims_processor_address = new_address;
    save_data();
}

;; Admin: Set min voting power
() set_min_voting_power(slice sender_address, int new_min) impure {
    check_owner(sender_address);
    min_voting_power = new_min;
    save_data();
}

;; Admin: Set participation bonus threshold
() set_participation_threshold(slice sender_address, int new_threshold) impure {
    check_owner(sender_address);
    throw_unless(400, (new_threshold >= 0) & (new_threshold <= 10000));
    participation_bonus_threshold = new_threshold;
    save_data();
}

;; Get methods
(int, int, int) get_voter_stats(slice voter_address) method_id {
    load_data();
    int voter_hash = slice_hash(voter_address);
    (slice voter_data, int found) = voter_registry.udict_get?(267, voter_hash);

    if (~ found) {
        return (0, 0, 0);
    }

    int total_earned = voter_data~load_coins();
    int vote_count = voter_data~load_uint(32);
    int participation_rate = voter_data~load_uint(16);

    return (total_earned, vote_count, participation_rate);
}

int get_pending_rewards(slice voter_address) method_id {
    load_data();
    int voter_hash = slice_hash(voter_address);
    (slice pending_data, int found) = pending_rewards.udict_get?(267, voter_hash);

    if (~ found) {
        return 0;
    }

    return pending_data~load_coins();
}

(int, int) get_rewards_summary() method_id {
    load_data();
    return (total_rewards_distributed, total_rewards_pending);
}

int get_min_voting_power() method_id {
    load_data();
    return min_voting_power;
}

int get_participation_threshold() method_id {
    load_data();
    return participation_bonus_threshold;
}

;; Recv internal
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == 0x05) {  ;; receive_governance_share
        int amount = in_msg_body~load_coins();
        receive_governance_share(sender_address, amount);
        return ();
    }

    if (op == 0x01) {  ;; register_voter
        slice voter_address = in_msg_body~load_msg_addr();
        register_voter(voter_address);
        return ();
    }

    if (op == 0x02) {  ;; record_vote
        slice voter_address = in_msg_body~load_msg_addr();
        int voting_power = in_msg_body~load_coins();
        int voted_with_majority = in_msg_body~load_uint(1);
        int participation_rate = in_msg_body~load_uint(16);
        record_vote(sender_address, voter_address, voting_power, voted_with_majority, participation_rate);
        return ();
    }

    if (op == 0x03) {  ;; claim_rewards
        claim_rewards(sender_address, sender_address);
        return ();
    }

    if (op == 0x10) {  ;; set_premium_distributor
        slice new_address = in_msg_body~load_msg_addr();
        set_premium_distributor(sender_address, new_address);
        return ();
    }

    if (op == 0x11) {  ;; set_claims_processor
        slice new_address = in_msg_body~load_msg_addr();
        set_claims_processor(sender_address, new_address);
        return ();
    }

    if (op == 0x12) {  ;; set_min_voting_power
        int new_min = in_msg_body~load_coins();
        set_min_voting_power(sender_address, new_min);
        return ();
    }

    if (op == 0x13) {  ;; set_participation_threshold
        int new_threshold = in_msg_body~load_uint(16);
        set_participation_threshold(sender_address, new_threshold);
        return ();
    }

    throw(0xffff);
}

;; Note: emit_log() is now implemented in stdlib.fc
;; GovernanceRewards uses event logging for reward distribution operations
