;; PriceOracle Contract - Price Feed Management (Core Version)
;; Provides USDT/TON price feeds for Core Insurance
;; Multi-oracle aggregation (median of 5 sources)
;; Staleness checks (max 5 minutes)
;; Oracle keeper rewards integration
;; Used by ClaimsProcessor for auto-verification (USDT depeg detection)

#include "../imports/stdlib.fc";

;; Storage structure
global slice owner_address;
global slice oracle_rewards_address;
global cell price_feeds;  ;; asset_id -> latest_price_data
global cell oracle_keepers;  ;; keeper_address_hash -> (is_active, last_update_time, update_count, accuracy_score)
global int min_oracle_count;  ;; Minimum oracles for aggregation
global int max_price_age;  ;; Maximum price staleness (seconds)

;; Asset IDs
const int ASSET_USDT = 1;
const int ASSET_TON = 2;
const int ASSET_BTC = 3;
const int ASSET_ETH = 4;

;; Price decimals (6 decimals for USD pairs)
const int PRICE_DECIMALS = 1000000;

;; Max staleness (5 minutes)
const int MAX_PRICE_AGE_DEFAULT = 300;

;; Min oracles for aggregation
const int MIN_ORACLE_COUNT_DEFAULT = 3;

() load_data() impure {
    slice ds = get_data().begin_parse();
    owner_address = ds~load_msg_addr();
    oracle_rewards_address = ds~load_msg_addr();
    price_feeds = ds~load_dict();
    oracle_keepers = ds~load_dict();
    min_oracle_count = ds~load_uint(8);
    max_price_age = ds~load_uint(32);
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(owner_address)
        .store_slice(oracle_rewards_address)
        .store_dict(price_feeds)
        .store_dict(oracle_keepers)
        .store_uint(min_oracle_count, 8)
        .store_uint(max_price_age, 32)
        .end_cell());
}

() check_owner(slice sender_address) impure {
    throw_unless(403, equal_slices_bits(sender_address, owner_address));
}

() check_keeper(slice keeper) impure {
    int keeper_hash = slice_hash(keeper);
    (slice keeper_data, int found) = oracle_keepers.udict_get?(267, keeper_hash);
    throw_unless(403, found);
    int is_active = keeper_data~load_uint(1);
    throw_unless(404, is_active);
}

;; Register oracle keeper
() register_keeper(slice sender_address, slice keeper_address) impure {
    check_owner(sender_address);

    int keeper_hash = slice_hash(keeper_address);
    oracle_keepers~udict_set(267, keeper_hash,
        begin_cell()
            .store_uint(1, 1)  ;; is_active
            .store_uint(0, 32)  ;; last_update_time
            .store_uint(0, 32)  ;; update_count
            .store_uint(10000, 16)  ;; accuracy_score (100% default)
            .end_cell().begin_parse());

    save_data();

    ;; Notify OracleRewards
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(oracle_rewards_address)
        .store_coins(50000000)  ;; Gas
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x01, 32)  ;; op: register_oracle
        .store_slice(keeper_address)
        .end_cell();

    send_raw_message(msg, 1);

    emit_log(0xc0, begin_cell()
        .store_slice(keeper_address)
        .end_cell().begin_parse());
}

;; Helper functions for price calculation
int calculate_median_price(cell prices_array, int count) inline {
    ;; Placeholder: return first price found
    ;; In production: sort prices and return median
    (int key, slice price_entry, int found) = prices_array.udict_get_min?(267);
    if (found) {
        int extracted_price = price_entry~load_coins();
        return extracted_price;
    }
    return 0;
}

;; Get oldest price timestamp
int get_oldest_price_time(cell prices_array) inline {
    ;; Find the oldest (minimum) timestamp in the prices array
    ;; Check if dict is empty first
    (int keeper_hash, slice price_entry, int found) = prices_array.udict_get_min?(267);

    if (~ found) {
        return now();  ;; Empty dict, return current time
    }

    ;; Found at least one entry, get its timestamp
    price_entry~load_coins();  ;; Skip price
    int oldest_time = price_entry~load_uint(32);

    ;; Iterate through remaining entries
    do {
        (keeper_hash, price_entry, found) = prices_array.udict_get_next?(267, keeper_hash);
        if (found) {
            price_entry~load_coins();  ;; Skip price
            int entry_time = price_entry~load_uint(32);
            if (entry_time < oldest_time) {
                oldest_time = entry_time;
            }
        }
    } until (~ found);

    return oldest_time;
}

;; Update price (called by oracle keepers)
() update_price(
    slice keeper,
    int asset_id,
    int price,
    int timestamp,
    cell signature
) impure {
    check_keeper(keeper);

    ;; Get current price data
    (slice price_data, int found) = price_feeds.udict_get?(8, asset_id);

    cell prices_array = new_dict();
    int price_count = 0;

    if (found) {
        prices_array = price_data~load_ref();
        price_count = price_data~load_uint(8);
    }

    ;; Add new price to array
    int keeper_hash = slice_hash(keeper);
    prices_array~udict_set(267, keeper_hash,
        begin_cell()
            .store_coins(price)
            .store_uint(timestamp, 32)
            .end_cell().begin_parse());

    price_count += 1;

    ;; Use first price as median (simplified)
    int median_price = price;
    int is_stale = 0;

    ;; Check staleness using the incoming timestamp
    ;; (In production: iterate through all keeper timestamps)
    if ((now() - timestamp) > max_price_age) {
        is_stale = 1;
    }

    ;; Mark as stale if not enough oracles
    if (price_count < min_oracle_count) {
        is_stale = 1;
    }

    ;; Store updated price data (use incoming timestamp for staleness checks)
    price_feeds~udict_set(8, asset_id,
        begin_cell()
            .store_ref(prices_array)
            .store_uint(price_count, 8)
            .store_coins(median_price)
            .store_uint(timestamp, 32)
            .store_uint(is_stale, 1)
            .end_cell().begin_parse());

    ;; Update keeper stats
    int keeper_hash_2 = slice_hash(keeper);
    (slice keeper_data, int keeper_found) = oracle_keepers.udict_get?(267, keeper_hash_2);
    if (keeper_found) {
        int is_active = keeper_data~load_uint(1);
        int last_update_time = keeper_data~load_uint(32);
        int update_count = keeper_data~load_uint(32);
        int accuracy_score = keeper_data~load_uint(16);

        update_count += 1;
        int new_accuracy = 10000;

        oracle_keepers~udict_set(267, keeper_hash_2,
            begin_cell()
                .store_uint(is_active, 1)
                .store_uint(now(), 32)
                .store_uint(update_count, 32)
                .store_uint(new_accuracy, 16)
                .end_cell().begin_parse());
    }

    save_data();

    ;; Notify OracleRewards
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(oracle_rewards_address)
        .store_coins(50000000)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x02, 32)
        .store_slice(keeper)
        .store_uint(10000, 16)
        .store_uint(1, 1)  ;; is_stale
        .end_cell();

    send_raw_message(msg, 1);

    emit_log(0xc1, begin_cell()
        .store_slice(keeper)
        .store_uint(asset_id, 8)
        .store_coins(price)
        .store_coins(price)  ;; median_price = price
        .store_uint(1, 1)  ;; is_stale
        .end_cell().begin_parse());
}

;; Calculate median price (simplified - in production: proper median algorithm)
;; Admin: Deactivate keeper
() deactivate_keeper(slice sender_address, slice keeper_address) impure {
    check_owner(sender_address);

    int keeper_hash = slice_hash(keeper_address);
    (slice keeper_data, int found) = oracle_keepers.udict_get?(267, keeper_hash);
    throw_unless(404, found);

    keeper_data~load_uint(1);  ;; Skip is_active
    int last_update_time = keeper_data~load_uint(32);
    int update_count = keeper_data~load_uint(32);
    int accuracy_score = keeper_data~load_uint(16);

    oracle_keepers~udict_set(267, keeper_hash,
        begin_cell()
            .store_uint(0, 1)  ;; is_active = false
            .store_uint(last_update_time, 32)
            .store_uint(update_count, 32)
            .store_uint(accuracy_score, 16)
            .end_cell().begin_parse());

    save_data();
}

;; Admin: Set min oracle count
() set_min_oracle_count(slice sender_address, int new_min) impure {
    check_owner(sender_address);
    throw_unless(400, (new_min >= 1) & (new_min <= 10));
    min_oracle_count = new_min;
    save_data();
}

;; Admin: Set max price age
() set_max_price_age(slice sender_address, int new_max) impure {
    check_owner(sender_address);
    throw_unless(400, (new_max >= 60) & (new_max <= 3600));  ;; 1 min to 1 hour
    max_price_age = new_max;
    save_data();
}

;; Get methods
(int, int, int) get_price(int asset_id) method_id {
    load_data();
    (slice price_data, int found) = price_feeds.udict_get?(8, asset_id);

    if (~ found) {
        return (0, 0, 0);  ;; (price, timestamp, is_stale)
    }

    price_data~load_ref();  ;; Skip prices_array
    price_data~load_uint(8);  ;; Skip price_count
    int median_price = price_data~load_coins();
    int last_update = price_data~load_uint(32);
    int is_stale = price_data~load_uint(1);

    return (median_price, last_update, is_stale);
}

int get_latest_price(int asset_id) method_id {
    load_data();
    (slice price_data, int found) = price_feeds.udict_get?(8, asset_id);

    if (~ found) {
        return 0;
    }

    price_data~load_ref();
    price_data~load_uint(8);
    int median_price = price_data~load_coins();

    return median_price;
}

int is_price_stale(int asset_id) method_id {
    load_data();
    (slice price_data, int found) = price_feeds.udict_get?(8, asset_id);

    if (~ found) {
        return -1;  ;; True (no data = stale)
    }

    price_data~load_ref();
    price_data~load_uint(8);
    price_data~load_coins();
    int last_update = price_data~load_uint(32);

    return (now() - last_update) > max_price_age;
}

(int, int, int) get_keeper_stats(slice keeper) method_id {
    load_data();
    int keeper_hash = slice_hash(keeper);
    (slice keeper_data, int found) = oracle_keepers.udict_get?(267, keeper_hash);

    if (~ found) {
        return (0, 0, 0);
    }

    int is_active = keeper_data~load_uint(1);
    keeper_data~load_uint(32);  ;; Skip last_update_time
    int update_count = keeper_data~load_uint(32);
    int accuracy_score = keeper_data~load_uint(16);

    return (update_count, accuracy_score, is_active);
}

int get_min_oracle_count() method_id {
    load_data();
    return min_oracle_count;
}

int get_max_price_age() method_id {
    load_data();
    return max_price_age;
}

;; Recv internal
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == 0x01) {  ;; register_keeper
        slice keeper_address = in_msg_body~load_msg_addr();
        register_keeper(sender_address, keeper_address);
        return ();
    }

    if (op == 0x02) {  ;; update_price
        int asset_id = in_msg_body~load_uint(8);
        int price = in_msg_body~load_coins();
        int timestamp = in_msg_body~load_uint(32);
        cell signature = in_msg_body~load_ref();
        update_price(sender_address, asset_id, price, timestamp, signature);
        return ();
    }

    if (op == 0x10) {  ;; deactivate_keeper
        slice keeper_address = in_msg_body~load_msg_addr();
        deactivate_keeper(sender_address, keeper_address);
        return ();
    }

    if (op == 0x11) {  ;; set_min_oracle_count
        int new_min = in_msg_body~load_uint(8);
        set_min_oracle_count(sender_address, new_min);
        return ();
    }

    if (op == 0x12) {  ;; set_max_price_age
        int new_max = in_msg_body~load_uint(32);
        set_max_price_age(sender_address, new_max);
        return ();
    }

    throw(0xffff);
}

;; Note: emit_log() is now implemented in stdlib.fc
;; PriceOracle uses event logging for price update operations
