;; ================================================================
;; RWAFloat Contract - Real World Asset Investment Manager
;; ================================================================
;;
;; Purpose: Manages RWA investments via Plume Nest Credit protocol
;; Features:
;; - Cross-chain RWA deployment (TON → Plume via TON Bridge)
;; - 7-day redemption window for liquidity
;; - Target: 8-12% APY (10% average)
;; - Capital maturity tracking (only deploy expired coverage capital)
;;
;; Allocation: 50% of total premium float
;; Target Shard: 0xF0
;; Gas Cost: ~0.3 TON per investment (cross-chain bridge)
;; ================================================================

#include "../libs/security_helpers.fc";

;; ================================================================
;; CONSTANTS
;; ================================================================

const int REDEMPTION_PERIOD_SECONDS = 604800;  ;; 7 days

;; Opcodes
const int op::invest_rwa = 0x80;
const int op::redeem_rwa = 0x81;
const int op::bridge_to_plume = 0x82;
const int op::bridge_from_plume = 0x83;
const int op::set_ton_bridge = 0x90;
const int op::set_plume_nest_credit = 0x91;
const int op::set_float_master = 0x92;
const int op::pause = 0x93;
const int op::unpause = 0x94;

;; Error codes
const int err::unauthorized = 401;
const int err::paused = 402;
const int err::invalid_amount = 403;
const int err::bridge_not_set = 404;
const int err::insufficient_holdings = 405;
const int err::redemption_locked = 406;

;; Event types
const int EVENT_RWA_INVESTED = 0x01;
const int EVENT_RWA_REDEMPTION_STARTED = 0x02;
const int EVENT_RWA_REDEMPTION_COMPLETED = 0x03;
const int EVENT_TON_BRIDGE_SET = 0x04;
const int EVENT_PLUME_NEST_CREDIT_SET = 0x05;
const int EVENT_FLOAT_MASTER_SET = 0x06;
const int EVENT_RWA_FLOAT_PAUSED = 0x07;
const int EVENT_RWA_FLOAT_UNPAUSED = 0x08;

;; ================================================================
;; STORAGE LAYOUT
;; ================================================================

global slice admin_address;
global slice float_master_address;
global slice ton_bridge_address;
global slice plume_nest_credit_address;  ;; Plume network RWA protocol address

global int total_invested;
global int total_redeemed;
global int plume_holdings;               ;; Current RWA holdings on Plume
global int pending_redemptions;          ;; RWAs in 7-day redemption queue
global cell redemption_queue;            ;; Dict<redemption_id:uint64, redemption:cell>
global int next_redemption_id;

global int paused;

;; ================================================================
;; STORAGE FUNCTIONS
;; ================================================================

() load_data() impure inline {
  slice ds = get_data().begin_parse();

  ;; Addresses split into 2 refs (2 + 2) to avoid cell overflow (4 × 267 = 1068 bits > 1023)
  slice addr_ref1 = ds~load_ref().begin_parse();
  admin_address = addr_ref1~load_msg_addr();
  float_master_address = addr_ref1~load_msg_addr();

  slice addr_ref2 = ds~load_ref().begin_parse();
  ton_bridge_address = addr_ref2~load_msg_addr();
  plume_nest_credit_address = addr_ref2~load_msg_addr();

  total_invested = ds~load_coins();
  total_redeemed = ds~load_coins();
  plume_holdings = ds~load_coins();
  pending_redemptions = ds~load_coins();
  redemption_queue = ds~load_dict();
  next_redemption_id = ds~load_uint(64);

  paused = ds~load_uint(1);
}

() save_data() impure inline {
  ;; Split addresses into 2 refs (2 + 2) to avoid cell overflow
  cell addr_data1 = begin_cell()
    .store_slice(admin_address)
    .store_slice(float_master_address)
    .end_cell();

  cell addr_data2 = begin_cell()
    .store_slice(ton_bridge_address)
    .store_slice(plume_nest_credit_address)
    .end_cell();

  set_data(
    begin_cell()
      .store_ref(addr_data1)
      .store_ref(addr_data2)
      .store_coins(total_invested)
      .store_coins(total_redeemed)
      .store_coins(plume_holdings)
      .store_coins(pending_redemptions)
      .store_dict(redemption_queue)
      .store_uint(next_redemption_id, 64)
      .store_uint(paused, 1)
      .end_cell()
  );
}

;; ================================================================
;; RWA INVESTMENT
;; ================================================================

() invest_rwa(int amount) impure {
  throw_unless(err::invalid_amount, amount > 0);
  throw_if(err::bridge_not_set, is_valid_address(ton_bridge_address) == false);

  total_invested += amount;
  plume_holdings += amount;

  ;; Bridge TON to Plume network
  ;; Message format: op::bridge_to_plume, destination_address, amount
  cell bridge_payload = begin_cell()
    .store_slice(plume_nest_credit_address)
    .store_coins(amount)
    .store_uint(1, 8)  ;; Action: invest
    .end_cell();

  send_internal_msg(
    ton_bridge_address,
    amount + 200000000,  ;; 0.2 TON bridge fee
    op::bridge_to_plume,
    bridge_payload
  );

  emit_log_event(EVENT_RWA_INVESTED,
    begin_cell()
      .store_coins(amount)
      .store_coins(plume_holdings)
      .store_uint(now(), 32)
      .end_cell()
  );
}

;; ================================================================
;; RWA REDEMPTION (7-day window)
;; ================================================================

() redeem_rwa(int amount) impure {
  throw_unless(err::invalid_amount, amount > 0);
  throw_unless(err::insufficient_holdings, plume_holdings >= amount);
  throw_if(err::bridge_not_set, is_valid_address(ton_bridge_address) == false);

  ;; Create redemption request
  int redemption_id = next_redemption_id;
  next_redemption_id += 1;

  int redemption_timestamp = now();
  int unlock_timestamp = redemption_timestamp + REDEMPTION_PERIOD_SECONDS;

  cell redemption_data = begin_cell()
    .store_coins(amount)
    .store_uint(redemption_timestamp, 32)
    .store_uint(unlock_timestamp, 32)
    .store_uint(0, 1)  ;; Not yet completed
    .end_cell();

  redemption_queue~udict_set_ref(64, redemption_id, redemption_data);

  plume_holdings -= amount;
  pending_redemptions += amount;

  ;; Bridge request to Plume for redemption initiation
  cell bridge_payload = begin_cell()
    .store_slice(plume_nest_credit_address)
    .store_coins(amount)
    .store_uint(2, 8)  ;; Action: redeem
    .store_uint(redemption_id, 64)
    .end_cell();

  send_internal_msg(
    ton_bridge_address,
    100000000,  ;; 0.1 TON bridge fee
    op::bridge_to_plume,
    bridge_payload
  );

  emit_log_event(EVENT_RWA_REDEMPTION_STARTED,
    begin_cell()
      .store_uint(redemption_id, 64)
      .store_coins(amount)
      .store_uint(unlock_timestamp, 32)
      .store_uint(now(), 32)
      .end_cell()
  );
}

;; ================================================================
;; REDEMPTION COMPLETION (called after 7 days)
;; ================================================================

() complete_redemption(int redemption_id) impure {
  (cell redemption_cell, int found) = udict_get_ref?(redemption_queue, 64, redemption_id);
  throw_unless(err::invalid_amount, found);

  slice rs = redemption_cell.begin_parse();
  int amount = rs~load_coins();
  int redemption_timestamp = rs~load_uint(32);
  int unlock_timestamp = rs~load_uint(32);
  int completed = rs~load_uint(1);

  throw_unless(err::redemption_locked, now() >= unlock_timestamp);
  throw_unless(err::invalid_amount, completed == 0);

  ;; Mark as completed
  cell updated_redemption = begin_cell()
    .store_coins(amount)
    .store_uint(redemption_timestamp, 32)
    .store_uint(unlock_timestamp, 32)
    .store_uint(1, 1)  ;; Completed
    .end_cell();

  redemption_queue~udict_set_ref(64, redemption_id, updated_redemption);

  pending_redemptions -= amount;
  total_redeemed += amount;

  ;; Return funds to FloatMaster (or vault directly)
  send_internal_msg(
    float_master_address,
    amount,
    0,  ;; Simple transfer
    begin_cell().end_cell()
  );

  emit_log_event(EVENT_RWA_REDEMPTION_COMPLETED,
    begin_cell()
      .store_uint(redemption_id, 64)
      .store_coins(amount)
      .store_uint(now(), 32)
      .end_cell()
  );
}

;; ================================================================
;; MESSAGE HANDLERS
;; ================================================================

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return ();  ;; Accept funds
  }

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  slice sender = cs~load_msg_addr();

  load_data();

  int op = in_msg_body~load_uint(32);

  if (op == op::invest_rwa) {
    require_not_paused(paused);

    ;; Only FloatMaster can invest
    throw_unless(err::unauthorized, equal_slice_bits(sender, float_master_address));

    int amount = in_msg_body~load_coins();
    invest_rwa(amount);

    save_data();
    return ();
  }

  if (op == op::redeem_rwa) {
    require_not_paused(paused);

    ;; Admin or FloatMaster
    throw_unless(err::unauthorized,
      equal_slice_bits(sender, admin_address) | equal_slice_bits(sender, float_master_address));

    int amount = in_msg_body~load_coins();
    redeem_rwa(amount);

    save_data();
    return ();
  }

  if (op == op::bridge_from_plume) {
    ;; Callback from TON Bridge after successful redemption
    int redemption_id = in_msg_body~load_uint(64);
    complete_redemption(redemption_id);

    save_data();
    return ();
  }

  if (op == op::set_ton_bridge) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    ton_bridge_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_TON_BRIDGE_SET, 1);
    return ();
  }

  if (op == op::set_plume_nest_credit) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    plume_nest_credit_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_PLUME_NEST_CREDIT_SET, 1);
    return ();
  }

  if (op == op::set_float_master) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    float_master_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_FLOAT_MASTER_SET, 1);
    return ();
  }

  if (op == op::pause) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    paused = 1;
    save_data();
    emit_log_simple(EVENT_RWA_FLOAT_PAUSED, 1);
    return ();
  }

  if (op == op::unpause) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    paused = 0;
    save_data();
    emit_log_simple(EVENT_RWA_FLOAT_UNPAUSED, 1);
    return ();
  }

  throw(0xFFFF);
}

;; ================================================================
;; GET METHODS
;; ================================================================

slice get_admin() method_id {
  load_data();
  return admin_address;
}

slice get_float_master() method_id {
  load_data();
  return float_master_address;
}

slice get_ton_bridge() method_id {
  load_data();
  return ton_bridge_address;
}

slice get_plume_nest_credit() method_id {
  load_data();
  return plume_nest_credit_address;
}

int get_total_invested() method_id {
  load_data();
  return total_invested;
}

int get_plume_holdings() method_id {
  load_data();
  return plume_holdings;
}

int get_pending_redemptions() method_id {
  load_data();
  return pending_redemptions;
}

int get_available_balance() method_id {
  load_data();
  ;; Holdings not in redemption queue
  return plume_holdings;
}

int get_total_balance() method_id {
  load_data();
  ;; Holdings + pending redemptions
  return plume_holdings + pending_redemptions;
}

;; Calculate daily yield (10% APY on holdings)
int get_daily_yield() method_id {
  load_data();
  ;; Daily yield = holdings * 0.10 / 365
  return muldiv(plume_holdings, 10, 365 * 100);
}

int get_paused() method_id {
  load_data();
  return paused;
}

int get_version() method_id {
  return 3;
}

;; ================================================================
;; END OF RWAFLOAT CONTRACT
;; ================================================================
