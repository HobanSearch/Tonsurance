;; ================================================================
;; EQTBuybackManager Contract - EQT Token Buyback Executor
;; ================================================================
;;
;; Purpose: Executes EQT token buybacks when 4 conditions are met
;; Conditions:
;;   1. Protocol maturity ratio > 4.0 (Mature)
;;   2. Protocol reserve > $10M
;;   3. All vault tranches have sufficient yields
;;   4. Hedges cover >95% of active exposure
;;
;; Priority Waterfall:
;;   1. Efficient hedging (match policy exposure)
;;   2. LP vault yield funding (ensure promised returns)
;;   3. Market making (crossover arbitrage, >15% fee APY)
;;   4. EQT buyback (ONLY when all above satisfied)
;;
;; EQT 25% Cap Alignment:
;;   - When EQT tranche NAV exceeds 1.25 (25% profit), excess → protocol reserve
;;   - Protocol reserve used for buybacks (fully aligns LP and protocol incentives)
;;
;; Target Shard: 0xF0
;; Gas Cost: ~0.2 TON per buyback execution
;; ================================================================

#include "../libs/security_helpers.fc";

;; ================================================================
;; CONSTANTS
;; ================================================================

const int MIN_PROTOCOL_RESERVE = 10000000000000;  ;; $10M in nanotons
const int MIN_MATURITY_RATIO_FP = 4000000000;    ;; 4.0 (fixed-point, 9 decimals)
const int MIN_HEDGE_COVERAGE_BPS = 9500;         ;; 95%

;; Opcodes
const int op::execute_buyback = 0xAE;
const int op::check_buyback_eligibility = 0xAF;
const int op::set_float_master = 0xB0;
const int op::set_vault = 0xB1;
const int op::set_hedge_float = 0xB2;
const int op::set_eqt_token = 0xB3;
const int op::set_dex_router = 0xB4;
const int op::pause = 0xB5;
const int op::unpause = 0xB6;

;; Error codes
const int err::unauthorized = 401;
const int err::paused = 402;
const int err::not_eligible = 403;
const int err::maturity_too_low = 404;
const int err::reserve_too_low = 405;
const int err::vaults_underfunded = 406;
const int err::hedges_inadequate = 407;
const int err::invalid_amount = 408;

;; Event types
const int EVENT_BUYBACK_EXECUTED = 0x01;
const int EVENT_BUYBACK_RESULT_RECORDED = 0x02;
const int EVENT_BUYBACK_ELIGIBLE = 0x03;
const int EVENT_FLOAT_MASTER_SET = 0x04;
const int EVENT_VAULT_SET = 0x05;
const int EVENT_HEDGE_FLOAT_SET = 0x06;
const int EVENT_EQT_TOKEN_SET = 0x07;
const int EVENT_DEX_ROUTER_SET = 0x08;
const int EVENT_EQT_BUYBACK_PAUSED = 0x09;
const int EVENT_EQT_BUYBACK_UNPAUSED = 0x0A;

;; ================================================================
;; STORAGE LAYOUT
;; ================================================================

global slice admin_address;
global slice float_master_address;
global slice vault_address;
global slice hedge_float_address;
global slice eqt_token_address;       ;; EQT Jetton Master
global slice dex_router_address;      ;; DeDust router for market buys

global int total_buybacks_executed;
global int total_eqt_bought;
global int total_spent;

;; Buyback history
global cell buyback_history;          ;; Dict<buyback_id:uint64, buyback:cell>
global int next_buyback_id;

global int paused;

;; ================================================================
;; STORAGE FUNCTIONS
;; ================================================================

() load_data() impure inline {
  slice ds = get_data().begin_parse();

  ;; Addresses split into 2 refs (3 + 3) to avoid cell overflow (6 × 267 = 1602 bits > 1023)
  slice addr_ref1 = ds~load_ref().begin_parse();
  admin_address = addr_ref1~load_msg_addr();
  float_master_address = addr_ref1~load_msg_addr();
  vault_address = addr_ref1~load_msg_addr();

  slice addr_ref2 = ds~load_ref().begin_parse();
  hedge_float_address = addr_ref2~load_msg_addr();
  eqt_token_address = addr_ref2~load_msg_addr();
  dex_router_address = addr_ref2~load_msg_addr();

  total_buybacks_executed = ds~load_uint(32);
  total_eqt_bought = ds~load_coins();
  total_spent = ds~load_coins();

  buyback_history = ds~load_dict();
  next_buyback_id = ds~load_uint(64);

  paused = ds~load_uint(1);
}

() save_data() impure inline {
  ;; Split addresses into 2 refs (3 + 3) to avoid cell overflow
  cell addr_data1 = begin_cell()
    .store_slice(admin_address)
    .store_slice(float_master_address)
    .store_slice(vault_address)
    .end_cell();

  cell addr_data2 = begin_cell()
    .store_slice(hedge_float_address)
    .store_slice(eqt_token_address)
    .store_slice(dex_router_address)
    .end_cell();

  set_data(
    begin_cell()
      .store_ref(addr_data1)
      .store_ref(addr_data2)
      .store_uint(total_buybacks_executed, 32)
      .store_coins(total_eqt_bought)
      .store_coins(total_spent)
      .store_dict(buyback_history)
      .store_uint(next_buyback_id, 64)
      .store_uint(paused, 1)
      .end_cell()
  );
}

;; ================================================================
;; ELIGIBILITY CHECKS
;; ================================================================

() check_maturity_ratio(int maturity_ratio_fp) impure inline {
  ;; Maturity ratio = float / active_coverage, must be > 4.0
  throw_unless(err::maturity_too_low, maturity_ratio_fp >= MIN_MATURITY_RATIO_FP);
}

() check_protocol_reserve(int protocol_reserve) impure inline {
  ;; Protocol reserve must be > $10M
  throw_unless(err::reserve_too_low, protocol_reserve >= MIN_PROTOCOL_RESERVE);
}

() check_vault_yields(int vault_yields_sufficient) impure inline {
  ;; All 6 tranches must have accumulated sufficient yields for promised APYs
  throw_unless(err::vaults_underfunded, vault_yields_sufficient == 1);
}

() check_hedge_coverage(int total_exposure, int hedged_exposure) impure inline {
  ;; Hedges must cover >95% of active policy exposure
  if (total_exposure == 0) {
    return ();  ;; No exposure = no hedge requirement
  }

  int coverage_bps = muldiv(hedged_exposure, 10000, total_exposure);
  throw_unless(err::hedges_inadequate, coverage_bps >= MIN_HEDGE_COVERAGE_BPS);
}

;; ================================================================
;; BUYBACK EXECUTION
;; ================================================================

() execute_buyback(
  int amount,
  int maturity_ratio_fp,
  int protocol_reserve,
  int vault_yields_sufficient,
  int total_exposure,
  int hedged_exposure
) impure {
  throw_unless(err::invalid_amount, amount > 0);

  ;; Verify all 4 conditions
  check_maturity_ratio(maturity_ratio_fp);
  check_protocol_reserve(protocol_reserve);
  check_vault_yields(vault_yields_sufficient);
  check_hedge_coverage(total_exposure, hedged_exposure);

  int buyback_id = next_buyback_id;
  next_buyback_id += 1;

  ;; Execute market buy on DeDust
  ;; Swap TON → EQT token
  send_internal_msg(
    dex_router_address,
    amount + 150000000,  ;; 0.15 TON gas
    op::execute_buyback,
    begin_cell()
      .store_uint(buyback_id, 64)
      .store_slice(eqt_token_address)
      .store_coins(amount)
      .store_uint(0, 1)  ;; No slippage protection (market order)
      .end_cell()
  );

  ;; Record buyback
  cell buyback_data = begin_cell()
    .store_coins(amount)
    .store_uint(maturity_ratio_fp, 64)
    .store_coins(protocol_reserve)
    .store_uint(vault_yields_sufficient, 1)
    .store_coins(total_exposure)
    .store_coins(hedged_exposure)
    .store_uint(now(), 32)
    .store_coins(0)  ;; EQT bought (updated after swap)
    .end_cell();

  buyback_history~udict_set_ref(64, buyback_id, buyback_data);

  total_buybacks_executed += 1;
  total_spent += amount;

  emit_log_event(EVENT_BUYBACK_EXECUTED,
    begin_cell()
      .store_uint(buyback_id, 64)
      .store_coins(amount)
      .store_uint(maturity_ratio_fp, 64)
      .store_coins(protocol_reserve)
      .store_uint(now(), 32)
      .end_cell()
  );
}

;; ================================================================
;; BUYBACK RESULT CALLBACK
;; ================================================================

() record_buyback_result(int buyback_id, int eqt_bought) impure {
  ;; Called by DEX router after swap completes
  (cell buyback_cell, int found) = udict_get_ref?(buyback_history, 64, buyback_id);
  throw_unless(err::invalid_amount, found);

  slice bs = buyback_cell.begin_parse();
  int amount = bs~load_coins();
  int maturity_ratio_fp = bs~load_uint(64);
  int protocol_reserve = bs~load_coins();
  int vault_yields_sufficient = bs~load_uint(1);
  int total_exposure = bs~load_coins();
  int hedged_exposure = bs~load_coins();
  int executed_at = bs~load_uint(32);
  int old_eqt_bought = bs~load_coins();  ;; Old EQT bought (discarded)

  ;; Update with actual EQT bought
  cell updated_buyback = begin_cell()
    .store_coins(amount)
    .store_uint(maturity_ratio_fp, 64)
    .store_coins(protocol_reserve)
    .store_uint(vault_yields_sufficient, 1)
    .store_coins(total_exposure)
    .store_coins(hedged_exposure)
    .store_uint(executed_at, 32)
    .store_coins(eqt_bought)
    .end_cell();

  buyback_history~udict_set_ref(64, buyback_id, updated_buyback);

  total_eqt_bought += eqt_bought;

  emit_log_event(EVENT_BUYBACK_RESULT_RECORDED,
    begin_cell()
      .store_uint(buyback_id, 64)
      .store_coins(eqt_bought)
      .store_uint(now(), 32)
      .end_cell()
  );
}

;; ================================================================
;; MESSAGE HANDLERS
;; ================================================================

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return ();
  }

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  slice sender = cs~load_msg_addr();

  load_data();

  int op = in_msg_body~load_uint(32);

  if (op == op::execute_buyback) {
    require_not_paused(paused);

    ;; Only admin or OCaml backend
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));

    int amount = in_msg_body~load_coins();
    int maturity_ratio_fp = in_msg_body~load_uint(64);
    int protocol_reserve = in_msg_body~load_coins();
    int vault_yields_sufficient = in_msg_body~load_uint(1);
    int total_exposure = in_msg_body~load_coins();
    int hedged_exposure = in_msg_body~load_coins();

    execute_buyback(amount, maturity_ratio_fp, protocol_reserve, vault_yields_sufficient, total_exposure, hedged_exposure);

    save_data();
    return ();
  }

  if (op == op::check_buyback_eligibility) {
    require_not_paused(paused);

    ;; Public query to check if buyback is eligible
    int maturity_ratio_fp = in_msg_body~load_uint(64);
    int protocol_reserve = in_msg_body~load_coins();
    int vault_yields_sufficient = in_msg_body~load_uint(1);
    int total_exposure = in_msg_body~load_coins();
    int hedged_exposure = in_msg_body~load_coins();

    ;; Check all 4 conditions (will throw if not eligible)
    check_maturity_ratio(maturity_ratio_fp);
    check_protocol_reserve(protocol_reserve);
    check_vault_yields(vault_yields_sufficient);
    check_hedge_coverage(total_exposure, hedged_exposure);

    ;; If we reach here, all conditions met
    emit_log_simple(EVENT_BUYBACK_ELIGIBLE, 1);

    save_data();
    return ();
  }

  if (op == op::set_float_master) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    float_master_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_FLOAT_MASTER_SET, 1);
    return ();
  }

  if (op == op::set_vault) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    vault_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_VAULT_SET, 1);
    return ();
  }

  if (op == op::set_hedge_float) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    hedge_float_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_HEDGE_FLOAT_SET, 1);
    return ();
  }

  if (op == op::set_eqt_token) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    eqt_token_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_EQT_TOKEN_SET, 1);
    return ();
  }

  if (op == op::set_dex_router) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    dex_router_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_DEX_ROUTER_SET, 1);
    return ();
  }

  if (op == op::pause) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    paused = 1;
    save_data();
    emit_log_simple(EVENT_EQT_BUYBACK_PAUSED, 1);
    return ();
  }

  if (op == op::unpause) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    paused = 0;
    save_data();
    emit_log_simple(EVENT_EQT_BUYBACK_UNPAUSED, 1);
    return ();
  }

  throw(0xFFFF);
}

;; ================================================================
;; GET METHODS
;; ================================================================

slice get_admin() method_id {
  load_data();
  return admin_address;
}

slice get_float_master() method_id {
  load_data();
  return float_master_address;
}

int get_total_buybacks_executed() method_id {
  load_data();
  return total_buybacks_executed;
}

int get_total_eqt_bought() method_id {
  load_data();
  return total_eqt_bought;
}

int get_total_spent() method_id {
  load_data();
  return total_spent;
}

;; Get buyback details by ID
(int, int, int, int, int, int, int, int) get_buyback(int buyback_id) method_id {
  load_data();

  (cell buyback_cell, int found) = udict_get_ref?(buyback_history, 64, buyback_id);

  if (found == 0) {
    return (0, 0, 0, 0, 0, 0, 0, 0);
  }

  slice bs = buyback_cell.begin_parse();
  int amount = bs~load_coins();
  int maturity_ratio_fp = bs~load_uint(64);
  int protocol_reserve = bs~load_coins();
  int vault_yields_sufficient = bs~load_uint(1);
  int total_exposure = bs~load_coins();
  int hedged_exposure = bs~load_coins();
  int executed_at = bs~load_uint(32);
  int eqt_bought = bs~load_coins();

  return (amount, maturity_ratio_fp, protocol_reserve, vault_yields_sufficient, total_exposure, hedged_exposure, executed_at, eqt_bought);
}

int get_paused() method_id {
  load_data();
  return paused;
}

int get_version() method_id {
  return 3;
}

;; ================================================================
;; END OF EQTBUYBACKMANAGER CONTRACT
;; ================================================================
