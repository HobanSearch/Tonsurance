;; ================================================================
;; DeFiFloat Contract - TON DeFi Yield Manager
;; ================================================================
;;
;; Purpose: Manages DeFi positions across TON ecosystem
;; Venues: DeDust (DEX/AMM), STON.fi (AMM), Evaa (lending)
;; Features:
;; - Multi-venue yield optimization
;; - Instant liquidity (<1 minute withdrawals)
;; - Target: 5-10% APY (7% average)
;; - Dynamic rebalancing based on yields
;;
;; Allocation: 15% of total premium float
;; Target Shard: 0xF0
;; Gas Cost: ~0.15 TON per operation
;; ================================================================

#include "../libs/security_helpers.fc";

;; ================================================================
;; CONSTANTS
;; ================================================================

;; Opcodes
const int op::deploy_defi = 0x82;
const int op::withdraw_defi = 0x88;
const int op::add_liquidity_dedust = 0x89;
const int op::remove_liquidity_dedust = 0x8A;
const int op::supply_evaa = 0x8B;
const int op::withdraw_evaa = 0x8C;
const int op::swap_ston = 0x8D;
const int op::set_dedust = 0x99;
const int op::set_ston = 0x9A;
const int op::set_evaa = 0x9B;
const int op::set_float_master = 0x9C;
const int op::pause = 0x9D;
const int op::unpause = 0x9E;

;; Error codes
const int err::unauthorized = 401;
const int err::paused = 402;
const int err::invalid_amount = 403;
const int err::venue_not_set = 404;
const int err::insufficient_balance = 405;

;; Event types
const int EVENT_DEFI_DEPLOYED = 0x01;
const int EVENT_DEFI_WITHDRAWN = 0x02;
const int EVENT_DEDUST_SET = 0x03;
const int EVENT_STON_SET = 0x04;
const int EVENT_EVAA_SET = 0x05;
const int EVENT_FLOAT_MASTER_SET = 0x06;
const int EVENT_DEFI_FLOAT_PAUSED = 0x07;
const int EVENT_DEFI_FLOAT_UNPAUSED = 0x08;

;; ================================================================
;; STORAGE LAYOUT
;; ================================================================

global slice admin_address;
global slice float_master_address;
global slice dedust_router_address;
global slice ston_router_address;
global slice evaa_market_address;

global int total_deployed;
global int total_withdrawn;

;; Per-venue balances
global int dedust_liquidity;    ;; LP tokens in DeDust pools
global int ston_liquidity;      ;; LP tokens in STON pools
global int evaa_supplied;       ;; USDT supplied to Evaa lending

global int paused;

;; ================================================================
;; STORAGE FUNCTIONS
;; ================================================================

() load_data() impure inline {
  slice ds = get_data().begin_parse();

  ;; Addresses split into 2 refs (3 + 2) to avoid cell overflow (5 Ã— 267 = 1335 bits > 1023)
  slice addr_ref1 = ds~load_ref().begin_parse();
  admin_address = addr_ref1~load_msg_addr();
  float_master_address = addr_ref1~load_msg_addr();
  dedust_router_address = addr_ref1~load_msg_addr();

  slice addr_ref2 = ds~load_ref().begin_parse();
  ston_router_address = addr_ref2~load_msg_addr();
  evaa_market_address = addr_ref2~load_msg_addr();

  total_deployed = ds~load_coins();
  total_withdrawn = ds~load_coins();

  dedust_liquidity = ds~load_coins();
  ston_liquidity = ds~load_coins();
  evaa_supplied = ds~load_coins();

  paused = ds~load_uint(1);
}

() save_data() impure inline {
  ;; Split addresses into 2 refs (3 + 2) to avoid cell overflow
  cell addr_data1 = begin_cell()
    .store_slice(admin_address)
    .store_slice(float_master_address)
    .store_slice(dedust_router_address)
    .end_cell();

  cell addr_data2 = begin_cell()
    .store_slice(ston_router_address)
    .store_slice(evaa_market_address)
    .end_cell();

  set_data(
    begin_cell()
      .store_ref(addr_data1)
      .store_ref(addr_data2)
      .store_coins(total_deployed)
      .store_coins(total_withdrawn)
      .store_coins(dedust_liquidity)
      .store_coins(ston_liquidity)
      .store_coins(evaa_supplied)
      .store_uint(paused, 1)
      .end_cell()
  );
}

;; ================================================================
;; DEFI DEPLOYMENT
;; ================================================================

() deploy_defi_capital(int amount) impure {
  throw_unless(err::invalid_amount, amount > 0);

  total_deployed += amount;

  ;; Default allocation: 40% DeDust, 30% STON, 30% Evaa
  ;; OCaml backend can override with dynamic rebalancing
  int dedust_amount = muldiv(amount, 40, 100);
  int ston_amount = muldiv(amount, 30, 100);
  int evaa_amount = amount - dedust_amount - ston_amount;

  if (is_valid_address(dedust_router_address)) {
    add_liquidity_to_dedust(dedust_amount);
  }

  if (is_valid_address(ston_router_address)) {
    add_liquidity_to_ston(ston_amount);
  }

  if (is_valid_address(evaa_market_address)) {
    supply_to_evaa(evaa_amount);
  }

  emit_log_event(EVENT_DEFI_DEPLOYED,
    begin_cell()
      .store_coins(amount)
      .store_coins(dedust_amount)
      .store_coins(ston_amount)
      .store_coins(evaa_amount)
      .store_uint(now(), 32)
      .end_cell()
  );
}

;; ================================================================
;; VENUE-SPECIFIC OPERATIONS
;; ================================================================

() add_liquidity_to_dedust(int amount) impure inline {
  ;; Add liquidity to DeDust TON/USDT pool
  dedust_liquidity += amount;

  send_internal_msg(
    dedust_router_address,
    amount + 100000000,  ;; 0.1 TON gas
    op::add_liquidity_dedust,
    begin_cell()
      .store_coins(amount)
      .store_uint(1, 8)  ;; Pool ID: TON/USDT
      .end_cell()
  );
}

() remove_liquidity_from_dedust(int amount) impure inline {
  throw_unless(err::insufficient_balance, dedust_liquidity >= amount);

  dedust_liquidity -= amount;

  send_internal_msg(
    dedust_router_address,
    50000000,  ;; 0.05 TON gas
    op::remove_liquidity_dedust,
    begin_cell()
      .store_coins(amount)
      .store_uint(1, 8)  ;; Pool ID: TON/USDT
      .end_cell()
  );
}

() add_liquidity_to_ston(int amount) impure inline {
  ;; Add liquidity to STON.fi pools
  ston_liquidity += amount;

  send_internal_msg(
    ston_router_address,
    amount + 100000000,
    op::swap_ston,
    begin_cell()
      .store_coins(amount)
      .end_cell()
  );
}

() supply_to_evaa(int amount) impure inline {
  ;; Supply USDT to Evaa lending market (8% APY)
  evaa_supplied += amount;

  send_internal_msg(
    evaa_market_address,
    amount + 50000000,  ;; 0.05 TON gas
    op::supply_evaa,
    begin_cell()
      .store_coins(amount)
      .store_uint(2, 8)  ;; Asset ID: USDT
      .end_cell()
  );
}

() withdraw_from_evaa(int amount) impure inline {
  throw_unless(err::insufficient_balance, evaa_supplied >= amount);

  evaa_supplied -= amount;

  send_internal_msg(
    evaa_market_address,
    50000000,
    op::withdraw_evaa,
    begin_cell()
      .store_coins(amount)
      .store_uint(2, 8)  ;; Asset ID: USDT
      .end_cell()
  );
}

;; ================================================================
;; WITHDRAWAL (instant liquidity)
;; ================================================================

() withdraw_defi_capital(int amount) impure {
  throw_unless(err::invalid_amount, amount > 0);

  int total_available = dedust_liquidity + ston_liquidity + evaa_supplied;
  throw_unless(err::insufficient_balance, total_available >= amount);

  total_withdrawn += amount;

  ;; Withdraw proportionally from venues
  int dedust_withdrawal = 0;
  int ston_withdrawal = 0;
  int evaa_withdrawal = 0;

  if (total_available > 0) {
    dedust_withdrawal = muldiv(amount, dedust_liquidity, total_available);
    ston_withdrawal = muldiv(amount, ston_liquidity, total_available);
    evaa_withdrawal = amount - dedust_withdrawal - ston_withdrawal;
  }

  if (dedust_withdrawal > 0) {
    remove_liquidity_from_dedust(dedust_withdrawal);
  }

  if (evaa_withdrawal > 0) {
    withdraw_from_evaa(evaa_withdrawal);
  }

  ;; Return funds to FloatMaster
  send_internal_msg(
    float_master_address,
    amount,
    0,
    begin_cell().end_cell()
  );

  emit_log_event(EVENT_DEFI_WITHDRAWN,
    begin_cell()
      .store_coins(amount)
      .store_uint(now(), 32)
      .end_cell()
  );
}

;; ================================================================
;; MESSAGE HANDLERS
;; ================================================================

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return ();
  }

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  slice sender = cs~load_msg_addr();

  load_data();

  int op = in_msg_body~load_uint(32);

  if (op == op::deploy_defi) {
    require_not_paused(paused);

    throw_unless(err::unauthorized, equal_slice_bits(sender, float_master_address));

    int amount = in_msg_body~load_coins();
    deploy_defi_capital(amount);

    save_data();
    return ();
  }

  if (op == op::withdraw_defi) {
    require_not_paused(paused);

    throw_unless(err::unauthorized,
      equal_slice_bits(sender, admin_address) | equal_slice_bits(sender, float_master_address));

    int amount = in_msg_body~load_coins();
    withdraw_defi_capital(amount);

    save_data();
    return ();
  }

  if (op == op::set_dedust) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    dedust_router_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_DEDUST_SET, 1);
    return ();
  }

  if (op == op::set_ston) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    ston_router_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_STON_SET, 1);
    return ();
  }

  if (op == op::set_evaa) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    evaa_market_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_EVAA_SET, 1);
    return ();
  }

  if (op == op::set_float_master) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    float_master_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_FLOAT_MASTER_SET, 1);
    return ();
  }

  if (op == op::pause) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    paused = 1;
    save_data();
    emit_log_simple(EVENT_DEFI_FLOAT_PAUSED, 1);
    return ();
  }

  if (op == op::unpause) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, admin_address));
    paused = 0;
    save_data();
    emit_log_simple(EVENT_DEFI_FLOAT_UNPAUSED, 1);
    return ();
  }

  throw(0xFFFF);
}

;; ================================================================
;; GET METHODS
;; ================================================================

slice get_admin() method_id {
  load_data();
  return admin_address;
}

slice get_float_master() method_id {
  load_data();
  return float_master_address;
}

int get_total_deployed() method_id {
  load_data();
  return total_deployed;
}

int get_dedust_liquidity() method_id {
  load_data();
  return dedust_liquidity;
}

int get_ston_liquidity() method_id {
  load_data();
  return ston_liquidity;
}

int get_evaa_supplied() method_id {
  load_data();
  return evaa_supplied;
}

int get_total_balance() method_id {
  load_data();
  return dedust_liquidity + ston_liquidity + evaa_supplied;
}

;; Calculate daily yield (7% APY on total balance)
int get_daily_yield() method_id {
  load_data();
  int total_balance = dedust_liquidity + ston_liquidity + evaa_supplied;
  ;; Daily yield = balance * 0.07 / 365
  return muldiv(total_balance, 7, 365 * 100);
}

int get_paused() method_id {
  load_data();
  return paused;
}

int get_version() method_id {
  return 3;
}

;; ================================================================
;; END OF DEFIFLOAT CONTRACT
;; ================================================================
