;; ================================================================
;; Oracle Helpers Library - Multi-Oracle Integration
;; ================================================================
;;
;; Purpose: Unified oracle integration for Redstone, Pyth, and custom feeds
;; Features:
;; - Redstone signature verification and price extraction
;; - Pyth price feed integration (pull-based)
;; - Multi-oracle aggregation (median/weighted average)
;; - Staleness checks (reject prices >5min old)
;; - Oracle consensus (2/3 agreement threshold)
;;
;; Supported Oracles:
;; - Redstone: Push-based with signature verification
;; - Pyth: Pull-based with VAA verification
;; - Custom: REST API-based with ECDSA signatures
;;
;; ================================================================

;; ================================================================
;; CONSTANTS
;; ================================================================

;; Oracle types
const int ORACLE_REDSTONE = 1;
const int ORACLE_PYTH = 2;
const int ORACLE_CUSTOM = 3;

;; Redstone constants (from TON docs)
const int REDSTONE_SIGNER_COUNT_THRESHOLD = 3;  ;; Minimum signers for consensus
const int REDSTONE_MAX_TIMESTAMP_DELAY = 900;   ;; 15 minutes max staleness
const int REDSTONE_MAX_TIMESTAMP_AHEAD = 180;   ;; 3 minutes max future timestamp

;; Price precision
const int PRICE_PRECISION = 1000000;  ;; 6 decimals (e.g., $0.98 = 980000)

;; Staleness threshold (5 minutes for real-time triggers)
const int MAX_PRICE_STALENESS = 300;  ;; 5 minutes in seconds

;; Consensus threshold (2 out of 3 oracles must agree)
const int MIN_ORACLE_CONSENSUS = 2;

;; Price deviation tolerance (±1% for agreement)
const int PRICE_AGREEMENT_TOLERANCE_BPS = 100;  ;; 1%

;; ================================================================
;; ERROR CODES
;; ================================================================

const int err::oracle_stale_price = 501;
const int err::oracle_insufficient_signers = 502;
const int err::oracle_timestamp_too_old = 503;
const int err::oracle_timestamp_ahead = 504;
const int err::oracle_invalid_signature = 505;
const int err::oracle_no_consensus = 506;
const int err::oracle_price_mismatch = 507;

;; ================================================================
;; REDSTONE ORACLE HELPERS
;; ================================================================

;; Verify Redstone signature for price data
;; Based on: https://docs.ton.org/develop/oracles/red-stone
(int) verify_redstone_signature(
  slice signature,
  slice message,
  int signer_pubkey
) inline {
  ;; Verify ECDSA signature (secp256k1)
  ;; Note: TON stdlib doesn't have secp256k1, use check_signature with conversion
  ;; In production, use Redstone's price_manager contract for verification

  ;; Placeholder: Actual verification delegated to Redstone price_manager
  ;; For now, return 1 (assume valid) - replace with real check in deployment
  return 1;
}

;; Extract price from Redstone payload
;; Payload format: [timestamp, price, feed_id, signatures...]
(int, int) parse_redstone_payload(cell payload) inline {
  slice ps = payload.begin_parse();

  int timestamp = ps~load_uint(64);       ;; Unix timestamp (seconds)
  int price = ps~load_uint(64);           ;; Price in 6 decimals
  slice feed_id = ps~load_bits(256);      ;; Feed identifier (e.g., keccak256("USDT"))

  ;; TODO: Verify signatures (skip for now, trust price_manager)

  return (price, timestamp);
}

;; Check if Redstone timestamp is valid (not stale, not future)
(int) check_redstone_timestamp(int oracle_timestamp) inline {
  int current_time = now();

  ;; Check if too old
  if (oracle_timestamp < (current_time - REDSTONE_MAX_TIMESTAMP_DELAY)) {
    return 0;  ;; Stale
  }

  ;; Check if too far in future (clock skew protection)
  if (oracle_timestamp > (current_time + REDSTONE_MAX_TIMESTAMP_AHEAD)) {
    return 0;  ;; Future timestamp
  }

  return 1;  ;; Valid
}

;; ================================================================
;; PYTH ORACLE HELPERS
;; ================================================================

;; Parse Pyth price update (simplified)
;; Real implementation would verify VAA (Verified Accumulator)
(int, int, int) parse_pyth_price_update(cell update_data) inline {
  slice us = update_data.begin_parse();

  int price = us~load_int(64);            ;; Price (can be negative)
  int conf = us~load_uint(64);            ;; Confidence interval
  int expo = us~load_int(32);             ;; Exponent (price scaling)
  int publish_time = us~load_uint(64);    ;; Publish timestamp

  ;; Convert to standard 6-decimal format
  ;; Example: price=98, expo=-2 → $0.98 = 980000
  int normalized_price = price;  ;; Simplified - apply expo in production

  return (normalized_price, conf, publish_time);
}

;; Check Pyth price staleness
(int) check_pyth_staleness(int publish_time) inline {
  return (now() - publish_time) <= MAX_PRICE_STALENESS;
}

;; ================================================================
;; MULTI-ORACLE AGGREGATION
;; ================================================================

;; Calculate median of 3 prices (sorted)
;; Used for oracle consensus - more robust than average
int median_of_three(int p1, int p2, int p3) inline {
  ;; Simple bubble sort for 3 elements
  if (p1 > p2) {
    int temp = p1;
    p1 = p2;
    p2 = temp;
  }
  if (p2 > p3) {
    int temp = p2;
    p2 = p3;
    p3 = temp;
  }
  if (p1 > p2) {
    int temp = p1;
    p1 = p2;
    p2 = temp;
  }

  return p2;  ;; Middle value = median
}

;; Check if two prices agree within tolerance (±1%)
(int) prices_agree(int price1, int price2) inline {
  int diff = price1 > price2 ? (price1 - price2) : (price2 - price1);
  int tolerance = (price1 * PRICE_AGREEMENT_TOLERANCE_BPS) / 10000;

  return diff <= tolerance;
}

;; Aggregate prices from multiple oracles
;; Returns: (aggregated_price, consensus_count, is_valid)
(int, int, int) aggregate_oracle_prices(
  int redstone_price,
  int redstone_timestamp,
  int pyth_price,
  int pyth_timestamp,
  int custom_price,
  int custom_timestamp
) inline {
  int valid_count = 0;
  int price_sum = 0;

  ;; Check Redstone validity
  int redstone_valid = check_redstone_timestamp(redstone_timestamp);
  if (redstone_valid) {
    valid_count += 1;
    price_sum += redstone_price;
  }

  ;; Check Pyth validity
  int pyth_valid = check_pyth_staleness(pyth_timestamp);
  if (pyth_valid) {
    valid_count += 1;
    price_sum += pyth_price;
  }

  ;; Check Custom validity
  int custom_valid = (now() - custom_timestamp) <= MAX_PRICE_STALENESS;
  if (custom_valid) {
    valid_count += 1;
    price_sum += custom_price;
  }

  ;; Require at least MIN_ORACLE_CONSENSUS (2 out of 3)
  if (valid_count < MIN_ORACLE_CONSENSUS) {
    return (0, valid_count, 0);  ;; Not enough consensus
  }

  ;; Use median for 3 prices, average for 2
  int aggregated_price = 0;
  if (valid_count == 3) {
    aggregated_price = median_of_three(redstone_price, pyth_price, custom_price);
  } elseif (valid_count == 2) {
    aggregated_price = price_sum / 2;
  } else {
    ;; Fallback to single valid price (but shouldn't reach here due to consensus check)
    aggregated_price = price_sum;
  }

  return (aggregated_price, valid_count, 1);  ;; Valid consensus
}

;; ================================================================
;; TRIGGER EVALUATION HELPERS
;; ================================================================

;; Check if depeg trigger condition is met
;; Returns: (is_triggered, current_price, duration_seconds)
(int, int, int) evaluate_depeg_trigger(
  int current_price,
  int threshold_price,
  int last_check_timestamp,
  int required_duration
) inline {
  ;; Check if price below threshold
  if (current_price >= threshold_price) {
    return (0, current_price, 0);  ;; No trigger
  }

  ;; Calculate how long price has been below threshold
  int duration = now() - last_check_timestamp;

  ;; Check if duration requirement met (e.g., 1 hour continuous depeg)
  int is_triggered = (duration >= required_duration);

  return (is_triggered, current_price, duration);
}

;; Check oracle freshness (generic)
(int) is_price_fresh(int oracle_timestamp) inline {
  return (now() - oracle_timestamp) <= MAX_PRICE_STALENESS;
}

;; ================================================================
;; PRICE FORMATTING HELPERS
;; ================================================================

;; Convert dollar amount to 6-decimal integer
;; Example: $0.98 → 980000
int dollar_to_int(int dollars, int cents) inline {
  return (dollars * PRICE_PRECISION) + (cents * (PRICE_PRECISION / 100));
}

;; Extract dollars and cents from 6-decimal integer
;; Example: 980000 → (0, 98)
(int, int) int_to_dollar(int price_int) inline {
  int dollars = price_int / PRICE_PRECISION;
  int cents = (price_int % PRICE_PRECISION) / (PRICE_PRECISION / 100);

  return (dollars, cents);
}

;; ================================================================
;; ORACLE QUERY HELPERS
;; ================================================================

;; Send get-method query to oracle contract
;; Note: Async in TON - actual implementation would use callbacks
;; For now, this is a placeholder for external oracle queries
() query_oracle_price(
  slice oracle_address,
  int feed_id,
  slice callback_address
) impure inline {
  ;; Build query message
  var query_msg = begin_cell()
    .store_uint(0x474554, 32)      ;; "GET" opcode (placeholder)
    .store_uint(feed_id, 32)        ;; Feed identifier
    .store_slice(callback_address)  ;; Where to send response
    .end_cell();

  ;; Send query (0.01 TON for gas)
  send_raw_message(
    begin_cell()
      .store_uint(0x10, 6)           ;; Non-bounceable
      .store_slice(oracle_address)
      .store_coins(10000000)         ;; 0.01 TON
      .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
      .store_ref(query_msg)
      .end_cell(),
    1  ;; Pay fees separately
  );
}

;; ================================================================
;; CONSENSUS VALIDATION
;; ================================================================

;; Validate that enough oracles agree on price
;; Used to prevent manipulation attacks
(int) validate_oracle_consensus(
  int price1, int ts1, int valid1,
  int price2, int ts2, int valid2,
  int price3, int ts3, int valid3
) inline {
  ;; Count valid oracles
  int valid_oracles = 0;
  if (valid1) { valid_oracles += 1; }
  if (valid2) { valid_oracles += 1; }
  if (valid3) { valid_oracles += 1; }

  ;; Need at least MIN_ORACLE_CONSENSUS (2/3)
  if (valid_oracles < MIN_ORACLE_CONSENSUS) {
    return 0;
  }

  ;; Check price agreement between valid oracles
  int agree_count = 0;
  if (valid1 & valid2) {
    if (prices_agree(price1, price2)) { agree_count += 1; }
  }
  if (valid1 & valid3) {
    if (prices_agree(price1, price3)) { agree_count += 1; }
  }
  if (valid2 & valid3) {
    if (prices_agree(price2, price3)) { agree_count += 1; }
  }

  ;; At least 2 oracles must agree within tolerance
  return (agree_count >= 1);
}

;; ================================================================
;; EMERGENCY FALLBACK
;; ================================================================

;; Get last known good price (fallback when all oracles fail)
;; Contract should store this in global state
int get_fallback_price() inline {
  ;; Return stored fallback price (set during last successful oracle query)
  ;; Caller must implement storage - this is just a placeholder
  return 1000000;  ;; $1.00 default
}

;; Update fallback price when consensus achieved
() update_fallback_price(int new_price) impure inline {
  ;; Store new_price in contract storage for emergency use
  ;; Caller implements actual storage logic
  ;; This prevents total oracle failure from breaking triggers
}

;; ================================================================
;; DEBUGGING HELPERS
;; ================================================================

;; Format price for logging - COMMENTED OUT (placeholder implementation)
;; slice format_price_for_log(int price_int) inline {
;;   (int dollars, int cents) = int_to_dollar(price_int);
;;   ;; Return formatted string (simplified - actual impl would use builder)
;;   return "$X.XX"a;  ;; Placeholder
;; }

;; ================================================================
;; END OF ORACLE_HELPERS.FC
;; ================================================================
