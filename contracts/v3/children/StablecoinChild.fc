;; ================================================================
;; StablecoinChild Contract - Stablecoin Depeg Insurance
;; ================================================================
;;
;; Purpose: Creates and manages stablecoin depeg policies
;; Features:
;; - Policy creation with depeg parameters (threshold, duration)
;; - Premium calculation (coverage × APR × duration)
;; - Parametric trigger: price < $0.98 for 1+ hour
;; - PolicyNFT minting
;; - Premium investment via FloatMaster (50% RWA, 15% BTC, 15% DeFi, 20% Hedges)
;; - Policy registration with MasterFactory (claim coordination)
;; - Oracle monitoring and automatic claim triggering
;;
;; Flow:
;; 1. User sends premium → Premium to Float (immediate investment)
;; 2. Policy registered with MasterFactory (stores policy data)
;; 3. Oracle monitors price → Trigger on depeg > 1 hour
;; 4. Claim sent to MasterFactory → Vault withdrawal → User payout
;;
;; Target Shard: 0x10 (co-located with DepegSubFactory)
;; Gas Cost: ~0.15-0.20 TON per policy creation
;; ================================================================

#include "../libs/security_helpers.fc";
#include "../libs/factory_helpers.fc";
#include "../libs/oracle_helpers.fc";

;; ================================================================
;; STORAGE LAYOUT
;; ================================================================

global slice parent_factory_address;   ;; DepegSubFactory
global slice master_factory_address;   ;; MasterFactory
global int product_type;               ;; = 1 (PRODUCT_DEPEG)
global int asset_id;                   ;; Stablecoin ID (1=USDT, 2=USDC, etc.)
global slice policy_nft_minter_address;
global slice float_master_address;     ;; FloatMaster (receives premiums for investment)
global slice price_oracle_address;
global cell policy_registry;           ;; Dict<policy_id:uint64, policy_data:cell>
global int next_policy_id;             ;; Auto-increment policy ID
global int total_policies_created;
global int total_coverage_amount;      ;; Sum of all active coverage
global int paused;

;; Oracle monitoring state
global int last_oracle_price;          ;; Last fetched price (6 decimals)
global int last_oracle_timestamp;      ;; Last oracle update timestamp
global int depeg_start_timestamp;      ;; When current depeg started (0 if no depeg)
global cell active_policies;           ;; Dict<policy_id:uint64, escrow_addr:slice>

;; ================================================================
;; PREMIUM CALCULATION
;; ================================================================

;; Base APR for stablecoin depeg insurance (0.8% annual)
const int BASE_APR_BPS = 80;           ;; 80 basis points = 0.8%

;; Depeg trigger parameters
const int DEPEG_THRESHOLD_PRICE = 980000; ;; $0.98 (6 decimals)
const int DEPEG_DURATION_SECONDS = 3600;  ;; 1 hour

;; ================================================================
;; OPCODES
;; ================================================================

const int op::create_policy_from_factory = 0x40;
const int op::set_policy_nft_minter = 0x41;
const int op::set_float_master = 0x42;
const int op::set_price_oracle = 0x43;
const int op::pause = 0x44;
const int op::unpause = 0x45;
const int op::oracle_price_update = 0x46;      ;; Oracle relayer pushes price update

;; Downstream opcodes
const int op::mint_policy_nft = 0x50;
const int op::register_policy = 0x51;          ;; Register policy with MasterFactory
const int op::invest_premium = 0x52;           ;; Send premium to FloatMaster
const int op::process_claim = 0x53;            ;; Trigger claim processing at MasterFactory

;; ================================================================
;; ERROR CODES
;; ================================================================

const int err::unauthorized = 401;
const int err::paused = 402;
const int err::invalid_params = 403;
const int err::nft_minter_not_set = 404;
const int err::vault_not_set = 405;
const int err::oracle_not_set = 406;
const int err::insufficient_premium = 407;

;; ================================================================
;; EVENT TYPES
;; ================================================================

const int EVENT_POLICY_CREATED = 0x01;
const int EVENT_DEPEG_DETECTED = 0x02;
const int EVENT_DEPEG_RECOVERED = 0x03;
const int EVENT_POLICY_TRIGGERED = 0x04;
const int EVENT_DOWNSTREAM_FAILED = 0x05;
const int EVENT_NFT_MINTER_SET = 0x06;
const int EVENT_FLOAT_MASTER_SET = 0x07;
const int EVENT_ORACLE_SET = 0x08;
const int EVENT_CHILD_PAUSED = 0x09;
const int EVENT_CHILD_UNPAUSED = 0x0A;
const int EVENT_ORACLE_PRICE_UPDATED = 0x0B;

;; ================================================================
;; STORAGE FUNCTIONS
;; ================================================================

() load_data() impure inline {
  slice ds = get_data().begin_parse();

  parent_factory_address = ds~load_msg_addr();
  master_factory_address = ds~load_msg_addr();
  product_type = ds~load_uint(8);
  asset_id = ds~load_uint(16);

  ;; Load addresses from first reference (3 addresses = 801 bits)
  slice addr_ref1 = ds~load_ref().begin_parse();
  policy_nft_minter_address = addr_ref1~load_msg_addr();
  float_master_address = addr_ref1~load_msg_addr();
  price_oracle_address = addr_ref1~load_msg_addr();

  policy_registry = ds~load_dict();
  next_policy_id = ds~load_uint(64);
  total_policies_created = ds~load_uint(64);
  total_coverage_amount = ds~load_coins();
  paused = ds~load_uint(1);

  ;; Oracle monitoring state
  last_oracle_price = ds~load_uint(32);
  last_oracle_timestamp = ds~load_uint(32);
  depeg_start_timestamp = ds~load_uint(32);
  active_policies = ds~load_dict();
}

() save_data() impure inline {
  ;; Build address reference (3 addresses = 801 bits)
  var addr_ref1 = begin_cell()
    .store_slice(policy_nft_minter_address)
    .store_slice(float_master_address)
    .store_slice(price_oracle_address)
    .end_cell();

  set_data(
    begin_cell()
      .store_slice(parent_factory_address)
      .store_slice(master_factory_address)
      .store_uint(product_type, 8)
      .store_uint(asset_id, 16)
      .store_ref(addr_ref1)  ;; Store addresses in reference
      .store_dict(policy_registry)
      .store_uint(next_policy_id, 64)
      .store_uint(total_policies_created, 64)
      .store_coins(total_coverage_amount)
      .store_uint(paused, 1)
      ;; Oracle monitoring state
      .store_uint(last_oracle_price, 32)
      .store_uint(last_oracle_timestamp, 32)
      .store_uint(depeg_start_timestamp, 32)
      .store_dict(active_policies)
      .end_cell()
  );
}

;; ================================================================
;; FORWARD DECLARATIONS
;; ================================================================

() send_to_nft_minter(int policy_id, slice user_addr, int coverage_amount, int expiry_timestamp) impure inline;
() send_premium_to_float(int premium_amount, int policy_id, int duration_days) impure inline;
() send_register_policy_to_master_factory(int policy_id, slice user_addr, int coverage_amount, int expiry_timestamp) impure inline;
() trigger_active_policies(int trigger_price, int trigger_timestamp) impure;
() send_claim_to_master_factory(int policy_id, slice user_addr, int coverage_amount, int trigger_price, int trigger_timestamp) impure inline;
() handle_bounce(slice in_msg) impure;

;; ================================================================
;; PREMIUM CALCULATION
;; ================================================================

;; Calculate premium for depeg coverage
;; Formula: coverage_amount × APR × (duration_days / 365)
int calculate_premium(int coverage_amount, int duration_days) inline {
  ;; Premium = coverage × (APR / 10000) × (days / 365)
  ;; Use muldiv for precision: (coverage × APR × days) / (10000 × 365)
  return muldiv(coverage_amount * BASE_APR_BPS * duration_days, 1, 10000 * 365);
}

;; ================================================================
;; POLICY CREATION
;; ================================================================

() create_depeg_policy(
  slice user_addr,
  int coverage_amount,
  int duration_days,
  int user_premium_sent
) impure {
  ;; Validate parameters
  throw_unless(err::invalid_params, coverage_amount > 0);
  throw_unless(err::invalid_params, duration_days >= 7);   ;; Minimum 7 days
  throw_unless(err::invalid_params, duration_days <= 365); ;; Maximum 365 days

  ;; Validate integrations configured
  throw_if(err::nft_minter_not_set, is_valid_address(policy_nft_minter_address) == false);
  throw_if(err::vault_not_set, is_valid_address(float_master_address) == false);
  throw_if(err::oracle_not_set, is_valid_address(price_oracle_address) == false);

  ;; Calculate required premium
  int required_premium = calculate_premium(coverage_amount, duration_days);

  ;; Validate user sent enough premium (allow 1% buffer for gas)
  int min_premium = required_premium - (required_premium / 100);
  throw_unless(err::insufficient_premium, user_premium_sent >= min_premium);

  ;; Generate policy ID
  int policy_id = next_policy_id;
  next_policy_id += 1;

  ;; Calculate expiry
  int expiry_timestamp = now() + (duration_days * 86400);

  ;; Store policy data
  var policy_data = begin_cell()
    .store_slice(user_addr)
    .store_uint(asset_id, 16)
    .store_coins(coverage_amount)
    .store_uint(duration_days, 16)
    .store_coins(required_premium)
    .store_uint(now(), 32)           ;; Created at
    .store_uint(expiry_timestamp, 32) ;; Expires at
    .store_uint(0, 1)                 ;; Not claimed
    .end_cell();

  slice policy_slice = policy_data.begin_parse();
  policy_registry~udict_set(64, policy_id, policy_slice);

  ;; Update analytics
  total_policies_created += 1;
  total_coverage_amount += coverage_amount;

  ;; Send 3 parallel messages: NFT mint, Float investment, MasterFactory registration
  send_to_nft_minter(policy_id, user_addr, coverage_amount, expiry_timestamp);
  send_premium_to_float(required_premium, policy_id, duration_days);
  send_register_policy_to_master_factory(policy_id, user_addr, coverage_amount, expiry_timestamp);

  ;; Register policy for oracle monitoring (active until claimed or expired)
  slice active_policy_slice = begin_cell()
    .store_slice(user_addr)
    .store_coins(coverage_amount)
    .store_uint(expiry_timestamp, 32)
    .end_cell()
    .begin_parse();
  active_policies~udict_set(64, policy_id, active_policy_slice);

  ;; Emit event
  var event_data = begin_cell()
    .store_uint(policy_id, 64)
    .store_slice(user_addr)
    .store_uint(asset_id, 16)
    .store_coins(coverage_amount)
    .store_uint(duration_days, 16)
    .store_coins(required_premium)
    .store_uint(now(), 32)
    .end_cell();

  emit_log_event(EVENT_POLICY_CREATED, event_data);
}

;; ================================================================
;; ORACLE TRIGGER EVALUATION
;; ================================================================

;; Handle oracle price update and evaluate depeg trigger
() handle_oracle_price_update(int current_price, int oracle_timestamp) impure {
  ;; Validate price freshness
  throw_unless(err::oracle_stale_price, is_price_fresh(oracle_timestamp));

  ;; Update stored oracle state
  last_oracle_price = current_price;
  last_oracle_timestamp = oracle_timestamp;

  ;; Evaluate depeg trigger
  int depeg_start = depeg_start_timestamp;
  if (depeg_start == 0) {
    depeg_start = oracle_timestamp;
  }

  (int is_triggered, int price, int duration) = evaluate_depeg_trigger(
    current_price,
    DEPEG_THRESHOLD_PRICE,
    depeg_start,
    DEPEG_DURATION_SECONDS
  );

  if (current_price < DEPEG_THRESHOLD_PRICE) {
    ;; Price below threshold
    if (depeg_start_timestamp == 0) {
      ;; New depeg started
      depeg_start_timestamp = oracle_timestamp;

      emit_log_event(EVENT_DEPEG_DETECTED, begin_cell()
        .store_uint(current_price, 32)
        .store_uint(oracle_timestamp, 32)
        .store_uint(asset_id, 16)
        .end_cell());
    }

    if (is_triggered) {
      ;; Depeg duration requirement met - trigger all active policies
      trigger_active_policies(current_price, oracle_timestamp);

      ;; Reset depeg tracker
      depeg_start_timestamp = 0;
    }
  } else {
    ;; Price recovered above threshold
    if (depeg_start_timestamp > 0) {
      emit_log_event(EVENT_DEPEG_RECOVERED, begin_cell()
        .store_uint(current_price, 32)
        .store_uint(oracle_timestamp, 32)
        .store_uint(duration, 32)
        .end_cell());

      ;; Reset depeg tracker
      depeg_start_timestamp = 0;
    }
  }
}

;; Trigger payouts for all active policies
() trigger_active_policies(int trigger_price, int trigger_timestamp) impure {
  ;; Iterate through active policies and send claim requests to MasterFactory
  int policy_id = -1;
  slice policy_data = begin_cell().end_cell().begin_parse();
  int found = 0;
  do {
    (active_policies, policy_id, policy_data, found) = udict_delete_get_min(active_policies, 64);

    if (found) {
      slice user_addr = policy_data~load_msg_addr();
      int coverage_amount = policy_data~load_coins();
      int expiry_timestamp = policy_data~load_uint(32);

      ;; Send claim processing request to MasterFactory
      send_claim_to_master_factory(policy_id, user_addr, coverage_amount, trigger_price, trigger_timestamp);

      emit_log_event(EVENT_POLICY_TRIGGERED, begin_cell()
        .store_uint(policy_id, 64)
        .store_slice(user_addr)
        .store_uint(trigger_price, 32)
        .store_coins(coverage_amount)
        .end_cell());
    }
  } until (~ found);
}

;; Send claim processing request to MasterFactory
() send_claim_to_master_factory(
  int policy_id,
  slice user_addr,
  int coverage_amount,
  int trigger_price,
  int trigger_timestamp
) impure inline {
  var claim_msg = begin_cell()
    .store_uint(policy_id, 64)
    .store_uint(product_type, 8)     ;; PRODUCT_DEPEG
    .store_uint(asset_id, 16)         ;; Stablecoin ID
    .store_slice(user_addr)
    .store_coins(coverage_amount)
    .store_uint(trigger_price, 32)
    .store_uint(trigger_timestamp, 32)
    .store_uint(DEPEG_THRESHOLD_PRICE, 32)
    .store_uint(DEPEG_DURATION_SECONDS, 32)
    .end_cell();

  send_internal_msg(
    master_factory_address,
    50000000, ;; 0.05 TON gas for claim processing
    op::process_claim,
    claim_msg
  );
}

;; ================================================================
;; DOWNSTREAM INTEGRATIONS
;; ================================================================

;; Mint PolicyNFT
() send_to_nft_minter(
  int policy_id,
  slice user_addr,
  int coverage_amount,
  int expiry_timestamp
) impure inline {
  var nft_metadata = begin_cell()
    .store_uint(policy_id, 64)
    .store_uint(product_type, 8)     ;; DEPEG
    .store_uint(asset_id, 16)        ;; Stablecoin ID
    .store_slice(user_addr)
    .store_coins(coverage_amount)
    .store_uint(expiry_timestamp, 32)
    .store_uint(DEPEG_THRESHOLD_PRICE, 32)  ;; Trigger: $0.98
    .store_uint(DEPEG_DURATION_SECONDS, 32) ;; Duration: 1 hour
    .end_cell();

  send_internal_msg(
    policy_nft_minter_address,
    50000000, ;; 0.05 TON
    op::mint_policy_nft,
    nft_metadata
  );
}

;; Send premium to FloatMaster for immediate investment
() send_premium_to_float(
  int premium_amount,
  int policy_id,
  int duration_days
) impure inline {
  var premium_data = begin_cell()
    .store_uint(policy_id, 64)
    .store_uint(product_type, 8)     ;; PRODUCT_DEPEG
    .store_uint(asset_id, 16)         ;; Stablecoin ID
    .store_coins(premium_amount)
    .store_uint(duration_days, 16)
    ;; Float will invest:
    ;; - 50% RWA (8% APY target)
    ;; - 15% BTC (yield farming)
    ;; - 15% DeFi protocols
    ;; - 20% Hedging reserves
    .end_cell();

  send_internal_msg(
    float_master_address,
    premium_amount + 10000000, ;; Premium + 0.01 TON gas
    op::invest_premium,
    premium_data
  );
}

;; Register policy with MasterFactory for claim coordination
() send_register_policy_to_master_factory(
  int policy_id,
  slice user_addr,
  int coverage_amount,
  int expiry_timestamp
) impure inline {
  var policy_registration = begin_cell()
    .store_uint(policy_id, 64)
    .store_uint(product_type, 8)     ;; PRODUCT_DEPEG
    .store_uint(asset_id, 16)         ;; Stablecoin ID
    .store_slice(user_addr)
    .store_coins(coverage_amount)
    .store_uint(expiry_timestamp, 32)
    .store_slice(my_address())        ;; Child contract address (for callbacks)
    .store_uint(DEPEG_THRESHOLD_PRICE, 32)
    .store_uint(DEPEG_DURATION_SECONDS, 32)
    .end_cell();

  send_internal_msg(
    master_factory_address,
    20000000, ;; 0.02 TON gas for registration
    op::register_policy,
    policy_registration
  );
}

;; ================================================================
;; INTERNAL MESSAGE HANDLER
;; ================================================================

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return (); ;; Accept funds
  }

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  slice sender = cs~load_msg_addr();

  ;; Check if bounced
  if (flags & 1) {
    handle_bounce(in_msg_body);
    return ();
  }

  load_data();

  int op = in_msg_body~load_uint(32);

  if (op == op::create_policy_from_factory) {
    ;; Policy creation from parent factory
    require_not_paused(paused);

    ;; Validate sender is parent factory
    throw_unless(err::unauthorized, equal_slice_bits(sender, parent_factory_address));

    ;; Parse policy params
    slice user_addr = in_msg_body~load_msg_addr();
    cell params = in_msg_body~load_ref();
    slice params_slice = params.begin_parse();

    int coverage_amount = params_slice~load_coins();
    int duration_days = params_slice~load_uint(16);

    ;; Create policy
    create_depeg_policy(user_addr, coverage_amount, duration_days, msg_value);

    save_data();
    return ();
  }

  if (op == op::set_policy_nft_minter) {
    ;; Set NFT minter address (admin only)
    throw_unless(err::unauthorized, equal_slice_bits(sender, master_factory_address));

    slice new_minter = in_msg_body~load_msg_addr();
    policy_nft_minter_address = new_minter;

    save_data();

    emit_log_simple(EVENT_NFT_MINTER_SET, 1);
    return ();
  }

  if (op == op::set_float_master) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, master_factory_address));

    slice new_float = in_msg_body~load_msg_addr();
    float_master_address = new_float;

    save_data();

    emit_log_simple(EVENT_FLOAT_MASTER_SET, 1);
    return ();
  }

  if (op == op::set_price_oracle) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, master_factory_address));

    slice new_oracle = in_msg_body~load_msg_addr();
    price_oracle_address = new_oracle;

    save_data();

    emit_log_simple(EVENT_ORACLE_SET, 1);
    return ();
  }

  if (op == op::pause) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, parent_factory_address));

    paused = 1;
    save_data();

    emit_log_simple(EVENT_CHILD_PAUSED, 1);
    return ();
  }

  if (op == op::unpause) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, parent_factory_address));

    paused = 0;
    save_data();

    emit_log_simple(EVENT_CHILD_UNPAUSED, 1);
    return ();
  }

  if (op == op::oracle_price_update) {
    ;; Oracle relayer pushes price update
    ;; Validate sender is price_oracle_address or trusted relayer
    ;; TODO: Add proper sender validation in production
    ;; For now, accept any oracle update (add whitelist later)

    int current_price = in_msg_body~load_uint(32);      ;; Price in 6 decimals
    int oracle_timestamp = in_msg_body~load_uint(32);   ;; Unix timestamp

    ;; Handle price update and evaluate trigger
    handle_oracle_price_update(current_price, oracle_timestamp);

    save_data();

    emit_log_event(EVENT_ORACLE_PRICE_UPDATED, begin_cell()
      .store_uint(current_price, 32)
      .store_uint(oracle_timestamp, 32)
      .store_uint(asset_id, 16)
      .end_cell());

    return ();
  }

  throw(0xFFFF);
}

;; ================================================================
;; BOUNCED MESSAGE HANDLER
;; ================================================================

() handle_bounce(slice in_msg) impure {
  load_data();

  (int op, int error_code, cell payload) = parse_bounced_message(in_msg);

  if ((op == op::mint_policy_nft) | (op == op::invest_premium) | (op == op::register_policy)) {
    ;; Downstream integration failed
    ;; Log error but don't refund (policy already partially created)
    var event_data = begin_cell()
      .store_uint(op, 32)
      .store_uint(error_code, 32)
      .store_uint(now(), 32)
      .end_cell();

    emit_log_event(EVENT_DOWNSTREAM_FAILED, event_data);
  }

  save_data();
}

;; ================================================================
;; GET METHODS
;; ================================================================

slice get_parent_factory() method_id {
  load_data();
  return parent_factory_address;
}

slice get_master_factory() method_id {
  load_data();
  return master_factory_address;
}

int get_product_type() method_id {
  load_data();
  return product_type;
}

int get_asset_id() method_id {
  load_data();
  return asset_id;
}

slice get_policy_nft_minter() method_id {
  load_data();
  return policy_nft_minter_address;
}

slice get_float_master() method_id {
  load_data();
  return float_master_address;
}

slice get_price_oracle() method_id {
  load_data();
  return price_oracle_address;
}

int get_next_policy_id() method_id {
  load_data();
  return next_policy_id;
}

int get_total_policies() method_id {
  load_data();
  return total_policies_created;
}

int get_total_coverage() method_id {
  load_data();
  return total_coverage_amount;
}

int get_paused() method_id {
  load_data();
  return paused;
}

;; Get policy details by ID
(slice, int, int, int, int, int, int, int) get_policy(int policy_id) method_id {
  load_data();

  (slice policy_data, int found) = udict_get?(policy_registry, 64, policy_id);

  if (found == 0) {
    return (begin_cell().end_cell().begin_parse(), 0, 0, 0, 0, 0, 0, 0);
  }

  slice user_addr = policy_data~load_msg_addr();
  int asset = policy_data~load_uint(16);
  int coverage = policy_data~load_coins();
  int duration = policy_data~load_uint(16);
  int premium = policy_data~load_coins();
  int created_at = policy_data~load_uint(32);
  int expires_at = policy_data~load_uint(32);
  int claimed = policy_data~load_uint(1);

  return (user_addr, asset, coverage, duration, premium, created_at, expires_at, claimed);
}

;; Calculate premium quote (off-chain query)
int get_premium_quote(int coverage_amount, int duration_days) method_id {
  return calculate_premium(coverage_amount, duration_days);
}

;; Get depeg trigger parameters
(int, int) get_depeg_trigger_params() method_id {
  return (DEPEG_THRESHOLD_PRICE, DEPEG_DURATION_SECONDS);
}

int get_version() method_id {
  return 3;
}

;; ================================================================
;; END OF STABLECOINCHILD CONTRACT
;; ================================================================
