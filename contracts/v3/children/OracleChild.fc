;; ================================================================
;; OracleChild Contract - Oracle Failure Insurance
;; ================================================================
;;
;; Purpose: Creates and manages oracle failure policies
;; Features:
;; - Policy creation with staleness/deviation parameters
;; - Premium calculation (coverage × APR × duration)
;; - Parametric trigger: data stale > 30 min OR deviation > 5%
;; - Integration with oracle aggregators
;; - PolicyNFT minting and escrow creation
;;
;; Target Shard: 0x30 (co-located with OracleSubFactory)
;; Gas Cost: ~0.15-0.20 TON per policy creation
;; ================================================================

#include "../libs/security_helpers.fc";
#include "../libs/factory_helpers.fc";

;; ================================================================
;; STORAGE LAYOUT
;; ================================================================

global slice parent_factory_address;
global slice master_factory_address;
global int product_type;               ;; = 3 (PRODUCT_ORACLE)
global int asset_id;                   ;; Oracle ID (1=RedStone, 2=Pyth, etc.)
global slice policy_nft_minter_address;
global slice vault_address;
global slice oracle_monitor_address;   ;; Oracle health monitor
global cell policy_registry;
global int next_policy_id;
global int total_policies_created;
global int total_coverage_amount;
global int paused;

;; ================================================================
;; PREMIUM CALCULATION
;; ================================================================

const int BASE_APR_BPS = 150;          ;; 150 basis points = 1.5%

;; Oracle failure trigger parameters
const int ORACLE_STALENESS_THRESHOLD_SECONDS = 1800; ;; 30 minutes
const int ORACLE_DEVIATION_THRESHOLD_BPS = 500;      ;; 5% deviation

;; ================================================================
;; OPCODES
;; ================================================================

const int op::create_policy_from_factory = 0x40;
const int op::set_policy_nft_minter = 0x41;
const int op::set_vault = 0x42;
const int op::set_oracle_monitor = 0x43;
const int op::pause = 0x44;
const int op::unpause = 0x45;

const int op::mint_policy_nft = 0x50;
const int op::create_escrow = 0x51;
const int op::deposit_premium = 0x52;

;; ================================================================
;; ERROR CODES
;; ================================================================

const int err::unauthorized = 401;
const int err::paused = 402;
const int err::invalid_params = 403;
const int err::nft_minter_not_set = 404;
const int err::vault_not_set = 405;
const int err::monitor_not_set = 406;
const int err::insufficient_premium = 407;

;; ================================================================
;; EVENT TYPES
;; ================================================================

const int EVENT_POLICY_CREATED = 0x01;
const int EVENT_DOWNSTREAM_FAILED = 0x02;
const int EVENT_NFT_MINTER_SET = 0x03;
const int EVENT_VAULT_SET = 0x04;
const int EVENT_MONITOR_SET = 0x05;
const int EVENT_CHILD_PAUSED = 0x06;
const int EVENT_CHILD_UNPAUSED = 0x07;

;; ================================================================
;; STORAGE FUNCTIONS
;; ================================================================

() load_data() impure inline {
  slice ds = get_data().begin_parse();
  parent_factory_address = ds~load_msg_addr();
  master_factory_address = ds~load_msg_addr();
  product_type = ds~load_uint(8);
  asset_id = ds~load_uint(16);

  ;; Load addresses from reference (3 addresses = 801 bits)
  slice addr_ref1 = ds~load_ref().begin_parse();
  policy_nft_minter_address = addr_ref1~load_msg_addr();
  vault_address = addr_ref1~load_msg_addr();
  oracle_monitor_address = addr_ref1~load_msg_addr();

  policy_registry = ds~load_dict();
  next_policy_id = ds~load_uint(64);
  total_policies_created = ds~load_uint(64);
  total_coverage_amount = ds~load_coins();
  paused = ds~load_uint(1);
}

() save_data() impure inline {
  ;; Build address reference (3 addresses = 801 bits)
  var addr_ref1 = begin_cell()
    .store_slice(policy_nft_minter_address)
    .store_slice(vault_address)
    .store_slice(oracle_monitor_address)
    .end_cell();

  set_data(
    begin_cell()
      .store_slice(parent_factory_address)
      .store_slice(master_factory_address)
      .store_uint(product_type, 8)
      .store_uint(asset_id, 16)
      .store_ref(addr_ref1)
      .store_dict(policy_registry)
      .store_uint(next_policy_id, 64)
      .store_uint(total_policies_created, 64)
      .store_coins(total_coverage_amount)
      .store_uint(paused, 1)
      .end_cell()
  );
}

;; ================================================================
;; FORWARD DECLARATIONS
;; ================================================================

() send_to_nft_minter(int policy_id, slice user_addr, int coverage_amount, int expiry_timestamp) impure inline;
() send_to_escrow_factory(int policy_id, slice user_addr, int coverage_amount, int expiry_timestamp) impure inline;
() send_to_vault(int premium_amount) impure inline;

;; ================================================================
;; PREMIUM CALCULATION
;; ================================================================

int calculate_premium(int coverage_amount, int duration_days) inline {
  return muldiv(coverage_amount * BASE_APR_BPS * duration_days, 1, 10000 * 365);
}

;; ================================================================
;; POLICY CREATION
;; ================================================================

() create_oracle_policy(
  slice user_addr,
  int coverage_amount,
  int duration_days,
  int user_premium_sent
) impure {
  throw_unless(err::invalid_params, coverage_amount > 0);
  throw_unless(err::invalid_params, duration_days >= 7);
  throw_unless(err::invalid_params, duration_days <= 365);

  throw_if(err::nft_minter_not_set, is_valid_address(policy_nft_minter_address) == false);
  throw_if(err::vault_not_set, is_valid_address(vault_address) == false);
  throw_if(err::monitor_not_set, is_valid_address(oracle_monitor_address) == false);

  int required_premium = calculate_premium(coverage_amount, duration_days);
  int min_premium = required_premium - (required_premium / 100);
  throw_unless(err::insufficient_premium, user_premium_sent >= min_premium);

  int policy_id = next_policy_id;
  next_policy_id += 1;

  int expiry_timestamp = now() + (duration_days * 86400);

  var policy_data = begin_cell()
    .store_slice(user_addr)
    .store_uint(asset_id, 16)
    .store_coins(coverage_amount)
    .store_uint(duration_days, 16)
    .store_coins(required_premium)
    .store_uint(now(), 32)
    .store_uint(expiry_timestamp, 32)
    .store_uint(0, 1)
    .end_cell();

  slice policy_slice = policy_data.begin_parse();
  policy_registry~udict_set(64, policy_id, policy_slice);

  total_policies_created += 1;
  total_coverage_amount += coverage_amount;

  send_to_nft_minter(policy_id, user_addr, coverage_amount, expiry_timestamp);
  send_to_escrow_factory(policy_id, user_addr, coverage_amount, expiry_timestamp);
  send_to_vault(required_premium);

  var event_data = begin_cell()
    .store_uint(policy_id, 64)
    .store_slice(user_addr)
    .store_uint(asset_id, 16)
    .store_coins(coverage_amount)
    .store_uint(duration_days, 16)
    .store_coins(required_premium)
    .store_uint(now(), 32)
    .end_cell();

  emit_log_event(EVENT_POLICY_CREATED, event_data);
}

;; ================================================================
;; DOWNSTREAM INTEGRATIONS
;; ================================================================

() send_to_nft_minter(
  int policy_id,
  slice user_addr,
  int coverage_amount,
  int expiry_timestamp
) impure inline {
  var nft_metadata = begin_cell()
    .store_uint(policy_id, 64)
    .store_uint(product_type, 8)
    .store_uint(asset_id, 16)
    .store_slice(user_addr)
    .store_coins(coverage_amount)
    .store_uint(expiry_timestamp, 32)
    .store_uint(ORACLE_STALENESS_THRESHOLD_SECONDS, 32)
    .store_uint(ORACLE_DEVIATION_THRESHOLD_BPS, 16)
    .end_cell();

  send_internal_msg(
    policy_nft_minter_address,
    50000000,
    op::mint_policy_nft,
    nft_metadata
  );
}

() send_to_escrow_factory(
  int policy_id,
  slice user_addr,
  int coverage_amount,
  int expiry_timestamp
) impure inline {
  var escrow_params = begin_cell()
    .store_uint(policy_id, 64)
    .store_slice(user_addr)
    .store_coins(coverage_amount)
    .store_uint(expiry_timestamp, 32)
    .store_slice(oracle_monitor_address)
    .store_uint(ORACLE_STALENESS_THRESHOLD_SECONDS, 32)
    .store_uint(ORACLE_DEVIATION_THRESHOLD_BPS, 16)
    .store_uint(9000, 16)
    .store_uint(300, 16)
    .store_uint(200, 16)
    .store_uint(150, 16)
    .store_uint(100, 16)
    .store_uint(100, 16)
    .store_uint(100, 16)
    .store_uint(50, 16)
    .end_cell();

  send_internal_msg(
    vault_address,
    100000000,
    op::create_escrow,
    escrow_params
  );
}

() send_to_vault(int premium_amount) impure inline {
  var premium_data = begin_cell()
    .store_uint(asset_id, 16)
    .store_coins(premium_amount)
    .end_cell();

  send_internal_msg(
    vault_address,
    premium_amount + 10000000,
    op::deposit_premium,
    premium_data
  );
}

;; ================================================================
;; MESSAGE HANDLERS
;; ================================================================

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return ();
  }

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  slice sender = cs~load_msg_addr();

  if (flags & 1) {
    load_data();
    (int op, int error_code, cell payload) = parse_bounced_message(in_msg_body);
    if ((op == op::mint_policy_nft) | (op == op::create_escrow) | (op == op::deposit_premium)) {
      emit_log_event(EVENT_DOWNSTREAM_FAILED, begin_cell().store_uint(op, 32).store_uint(error_code, 32).end_cell());
    }
    save_data();
    return ();
  }

  load_data();
  int op = in_msg_body~load_uint(32);

  if (op == op::create_policy_from_factory) {
    require_not_paused(paused);
    throw_unless(err::unauthorized, equal_slice_bits(sender, parent_factory_address));

    slice user_addr = in_msg_body~load_msg_addr();
    cell params = in_msg_body~load_ref();
    slice params_slice = params.begin_parse();

    int coverage_amount = params_slice~load_coins();
    int duration_days = params_slice~load_uint(16);

    create_oracle_policy(user_addr, coverage_amount, duration_days, msg_value);

    save_data();
    return ();
  }

  if (op == op::set_policy_nft_minter) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, master_factory_address));
    policy_nft_minter_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_NFT_MINTER_SET, 1);
    return ();
  }

  if (op == op::set_vault) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, master_factory_address));
    vault_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_VAULT_SET, 1);
    return ();
  }

  if (op == op::set_oracle_monitor) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, master_factory_address));
    oracle_monitor_address = in_msg_body~load_msg_addr();
    save_data();
    emit_log_simple(EVENT_MONITOR_SET, 1);
    return ();
  }

  if (op == op::pause) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, parent_factory_address));
    paused = 1;
    save_data();
    emit_log_simple(EVENT_CHILD_PAUSED, 1);
    return ();
  }

  if (op == op::unpause) {
    throw_unless(err::unauthorized, equal_slice_bits(sender, parent_factory_address));
    paused = 0;
    save_data();
    emit_log_simple(EVENT_CHILD_UNPAUSED, 1);
    return ();
  }

  throw(0xFFFF);
}

;; ================================================================
;; GET METHODS
;; ================================================================

slice get_parent_factory() method_id {
  load_data();
  return parent_factory_address;
}

slice get_master_factory() method_id {
  load_data();
  return master_factory_address;
}

int get_product_type() method_id {
  load_data();
  return product_type;
}

int get_asset_id() method_id {
  load_data();
  return asset_id;
}

int get_next_policy_id() method_id {
  load_data();
  return next_policy_id;
}

int get_total_policies() method_id {
  load_data();
  return total_policies_created;
}

int get_total_coverage() method_id {
  load_data();
  return total_coverage_amount;
}

int get_paused() method_id {
  load_data();
  return paused;
}

slice get_policy_nft_minter() method_id {
  load_data();
  return policy_nft_minter_address;
}

slice get_vault() method_id {
  load_data();
  return vault_address;
}

slice get_oracle_monitor() method_id {
  load_data();
  return oracle_monitor_address;
}

(slice, int, int, int, int, int, int, int) get_policy(int policy_id) method_id {
  load_data();
  (slice policy_data, int found) = udict_get?(policy_registry, 64, policy_id);
  if (found == 0) {
    return (begin_cell().end_cell().begin_parse(), 0, 0, 0, 0, 0, 0, 0);
  }

  slice user_addr = policy_data~load_msg_addr();
  int asset = policy_data~load_uint(16);
  int coverage = policy_data~load_coins();
  int duration = policy_data~load_uint(16);
  int premium = policy_data~load_coins();
  int created_at = policy_data~load_uint(32);
  int expires_at = policy_data~load_uint(32);
  int claimed = policy_data~load_uint(1);

  return (user_addr, asset, coverage, duration, premium, created_at, expires_at, claimed);
}

int get_premium_quote(int coverage_amount, int duration_days) method_id {
  return calculate_premium(coverage_amount, duration_days);
}

(int, int) get_trigger_params() method_id {
  return (ORACLE_STALENESS_THRESHOLD_SECONDS, ORACLE_DEVIATION_THRESHOLD_BPS);
}

int get_version() method_id {
  return 3;
}

;; ================================================================
;; END OF ORACLECHILD CONTRACT
;; ================================================================
