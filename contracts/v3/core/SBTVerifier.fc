;; ================================================================
;; SBTVerifier Contract - KYC Verification with ZK Proofs
;; ================================================================
;;
;; Purpose: Privacy-preserving KYC verification using soulbound tokens
;; Features:
;; - Zero-knowledge proof validation (guardian service)
;; - Soulbound token (SBT) minting (TEP-62 non-transferable NFTs)
;; - Tiered KYC levels (Basic, Standard, Enhanced)
;; - Whitelist/blacklist management
;; - Access control for MasterFactory
;;
;; Target Shard: 0x00 (Core Protocol)
;; Gas Cost: ~0.01 TON per KYC verification
;; ================================================================

#include "../libs/security_helpers.fc";

;; ================================================================
;; STORAGE LAYOUT
;; ================================================================

global slice admin_address;
global int guardian_pubkey;            ;; Guardian service public key (ZK proof validation)
global cell sbt_registry;              ;; Dict<addr_hash:uint256, kyc_tier:uint8>
global cell whitelist;                 ;; Dict<addr_hash:uint256, 1>
global cell blacklist;                 ;; Dict<addr_hash:uint256, 1>
global slice master_factory_address;   ;; MasterFactory address (for access control)
global int total_sbts_minted;          ;; Total SBTs issued (analytics)
global int paused;                     ;; 0 = active, 1 = paused

;; ================================================================
;; KYC TIERS
;; ================================================================

const int KYC_TIER_NONE = 0;           ;; No KYC
const int KYC_TIER_BASIC = 1;          ;; Email + phone, $5K limit
const int KYC_TIER_STANDARD = 2;       ;; Government ID, $50K limit
const int KYC_TIER_ENHANCED = 3;       ;; Proof of address, $500K+ limit

;; ================================================================
;; OPCODES
;; ================================================================

const int op::verify_kyc_proof = 0x10;
const int op::revoke_kyc = 0x11;
const int op::set_guardian_pubkey = 0x12;
const int op::add_to_whitelist = 0x13;
const int op::remove_from_whitelist = 0x14;
const int op::add_to_blacklist = 0x15;
const int op::remove_from_blacklist = 0x16;
const int op::set_master_factory = 0x17;
const int op::pause = 0x18;
const int op::unpause = 0x19;

;; ================================================================
;; EVENT TYPES
;; ================================================================

const int EVENT_SBT_MINTED = 0x01;
const int EVENT_SBT_REVOKED = 0x02;
const int EVENT_GUARDIAN_KEY_UPDATED = 0x03;
const int EVENT_ADDED_TO_WHITELIST = 0x04;
const int EVENT_REMOVED_FROM_WHITELIST = 0x05;
const int EVENT_ADDED_TO_BLACKLIST = 0x06;
const int EVENT_REMOVED_FROM_BLACKLIST = 0x07;
const int EVENT_MASTER_FACTORY_SET = 0x08;
const int EVENT_CONTRACT_PAUSED = 0x09;
const int EVENT_CONTRACT_UNPAUSED = 0x0A;

;; ================================================================
;; ERROR CODES
;; ================================================================

const int err::unauthorized = 401;
const int err::paused = 402;
const int err::invalid_proof = 403;
const int err::blacklisted = 404;
const int err::insufficient_tier = 405;
const int err::invalid_tier = 406;

;; ================================================================
;; STORAGE FUNCTIONS
;; ================================================================

() load_data() impure inline {
  slice ds = get_data().begin_parse();

  admin_address = ds~load_msg_addr();
  guardian_pubkey = ds~load_uint(256);
  sbt_registry = ds~load_dict();
  whitelist = ds~load_dict();
  blacklist = ds~load_dict();
  master_factory_address = ds~load_msg_addr();
  total_sbts_minted = ds~load_uint(64);
  paused = ds~load_uint(1);
}

() save_data() impure inline {
  set_data(
    begin_cell()
      .store_slice(admin_address)
      .store_uint(guardian_pubkey, 256)
      .store_dict(sbt_registry)
      .store_dict(whitelist)
      .store_dict(blacklist)
      .store_slice(master_factory_address)
      .store_uint(total_sbts_minted, 64)
      .store_uint(paused, 1)
      .end_cell()
  );
}

;; ================================================================
;; FORWARD DECLARATIONS
;; ================================================================

() mint_sbt(slice user_addr, int kyc_tier) impure;

;; ================================================================
;; ZK PROOF VALIDATION
;; ================================================================

;; Verify ZK proof from guardian service
;; Proof format:
;;   user_addr (267 bits)
;;   proof_commitment (256 bits) - Hash of KYC data
;;   kyc_tier (8 bits) - 1=Basic, 2=Standard, 3=Enhanced
;;   timestamp (32 bits) - Proof generation time
;;   signature (512 bits) - Guardian signature
() verify_and_mint_sbt(slice user_addr, cell zk_proof) impure {
  slice proof_data = zk_proof.begin_parse();

  ;; Parse proof components
  slice proof_user_addr = proof_data~load_msg_addr();
  int proof_commitment = proof_data~load_uint(256);
  int kyc_tier = proof_data~load_uint(8);
  int timestamp = proof_data~load_uint(32);
  slice signature = proof_data~load_bits(512);

  ;; Validate proof corresponds to user
  throw_unless(err::invalid_proof, equal_slice_bits(user_addr, proof_user_addr));

  ;; Validate tier is valid (1-3)
  throw_unless(err::invalid_tier, kyc_tier >= KYC_TIER_BASIC);
  throw_unless(err::invalid_tier, kyc_tier <= KYC_TIER_ENHANCED);

  ;; Validate timestamp freshness (<24 hours old)
  throw_unless(err::invalid_proof, is_fresh(timestamp, 86400)); ;; 24 hours

  ;; Construct message for signature verification
  var sig_msg = begin_cell()
    .store_slice(proof_user_addr)
    .store_uint(proof_commitment, 256)
    .store_uint(kyc_tier, 8)
    .store_uint(timestamp, 32)
    .end_cell();

  int msg_hash = cell_hash(sig_msg);

  ;; Validate guardian signature
  int sig_valid = check_signature(msg_hash, signature, guardian_pubkey);
  throw_unless(err::invalid_proof, sig_valid);

  ;; Mint SBT (update registry)
  mint_sbt(user_addr, kyc_tier);

  ;; Emit event
  var event_data = begin_cell()
    .store_slice(user_addr)
    .store_uint(kyc_tier, 8)
    .store_uint(proof_commitment, 256)
    .store_uint(now(), 32)
    .end_cell();

  emit_log_event(EVENT_SBT_MINTED, event_data);
}

;; Mint soulbound token (SBT) for user
() mint_sbt(slice user_addr, int kyc_tier) impure {
  int addr_hash = slice_hash(user_addr);

  ;; Check if user already has SBT (upgrade allowed)
  (slice existing_tier_data, int found) = udict_get?(sbt_registry, 256, addr_hash);

  if (found) {
    ;; Upgrade tier if new tier is higher
    int existing_tier = existing_tier_data~load_uint(8);
    if (kyc_tier > existing_tier) {
      slice tier_slice = begin_cell().store_uint(kyc_tier, 8).end_cell().begin_parse();
      sbt_registry~udict_set(256, addr_hash, tier_slice);
    }
  } else {
    ;; First-time SBT
    slice tier_slice = begin_cell().store_uint(kyc_tier, 8).end_cell().begin_parse();
    sbt_registry~udict_set(256, addr_hash, tier_slice);
    total_sbts_minted += 1;
  }
}

;; ================================================================
;; KYC VERIFICATION
;; ================================================================

;; Check if user meets required KYC tier
;; Returns: true if user has tier >= required_tier, false otherwise
int check_user_kyc(slice user_addr, int required_tier) {
  int addr_hash = slice_hash(user_addr);

  ;; Check blacklist (always reject)
  (_, int is_blacklisted) = udict_get?(blacklist, 256, addr_hash);
  if (is_blacklisted) {
    return false;
  }

  ;; Check whitelist (always accept)
  (_, int is_whitelisted) = udict_get?(whitelist, 256, addr_hash);
  if (is_whitelisted) {
    return true;
  }

  ;; Check SBT tier
  (slice user_tier_data, int found) = udict_get?(sbt_registry, 256, addr_hash);

  if (found == 0) {
    return false; ;; No SBT, no access
  }

  int user_tier = user_tier_data~load_uint(8);
  return user_tier >= required_tier;
}

;; ================================================================
;; INTERNAL MESSAGE HANDLER
;; ================================================================

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return (); ;; Accept funds
  }

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  slice sender = cs~load_msg_addr();

  load_data();

  int op = in_msg_body~load_uint(32);

  if (op == op::verify_kyc_proof) {
    require_not_paused(paused);

    slice user_addr = in_msg_body~load_msg_addr();
    cell zk_proof = in_msg_body~load_ref();

    verify_and_mint_sbt(user_addr, zk_proof);

    save_data();
    return ();
  }

  if (op == op::revoke_kyc) {
    require_admin(sender, admin_address);

    slice user_addr = in_msg_body~load_msg_addr();
    int addr_hash = slice_hash(user_addr);

    ;; Remove SBT
    sbt_registry~udict_delete?(256, addr_hash);

    save_data();

    var event_data = begin_cell()
      .store_slice(user_addr)
      .store_uint(now(), 32)
      .end_cell();

    emit_log_event(EVENT_SBT_REVOKED, event_data);
    return ();
  }

  if (op == op::set_guardian_pubkey) {
    require_admin(sender, admin_address);

    int new_pubkey = in_msg_body~load_uint(256);
    guardian_pubkey = new_pubkey;

    save_data();

    emit_log_simple(EVENT_GUARDIAN_KEY_UPDATED, new_pubkey);
    return ();
  }

  if (op == op::add_to_whitelist) {
    require_admin(sender, admin_address);

    slice user_addr = in_msg_body~load_msg_addr();
    int addr_hash = slice_hash(user_addr);

    slice value = begin_cell().store_uint(1, 1).end_cell().begin_parse();
    whitelist~udict_set(256, addr_hash, value);

    save_data();

    var event_data = begin_cell()
      .store_slice(user_addr)
      .end_cell();

    emit_log_event(EVENT_ADDED_TO_WHITELIST, event_data);
    return ();
  }

  if (op == op::remove_from_whitelist) {
    require_admin(sender, admin_address);

    slice user_addr = in_msg_body~load_msg_addr();
    int addr_hash = slice_hash(user_addr);

    whitelist~udict_delete?(256, addr_hash);

    save_data();

    emit_log_simple(EVENT_REMOVED_FROM_WHITELIST, 1);
    return ();
  }

  if (op == op::add_to_blacklist) {
    require_admin(sender, admin_address);

    slice user_addr = in_msg_body~load_msg_addr();
    int addr_hash = slice_hash(user_addr);

    slice value = begin_cell().store_uint(1, 1).end_cell().begin_parse();
    blacklist~udict_set(256, addr_hash, value);

    save_data();

    var event_data = begin_cell()
      .store_slice(user_addr)
      .end_cell();

    emit_log_event(EVENT_ADDED_TO_BLACKLIST, event_data);
    return ();
  }

  if (op == op::remove_from_blacklist) {
    require_admin(sender, admin_address);

    slice user_addr = in_msg_body~load_msg_addr();
    int addr_hash = slice_hash(user_addr);

    blacklist~udict_delete?(256, addr_hash);

    save_data();

    emit_log_simple(EVENT_REMOVED_FROM_BLACKLIST, 1);
    return ();
  }

  if (op == op::set_master_factory) {
    require_admin(sender, admin_address);

    slice new_factory = in_msg_body~load_msg_addr();
    master_factory_address = new_factory;

    save_data();

    emit_log_simple(EVENT_MASTER_FACTORY_SET, 1);
    return ();
  }

  if (op == op::pause) {
    require_admin(sender, admin_address);

    paused = 1;
    save_data();

    emit_log_simple(EVENT_CONTRACT_PAUSED, 1);
    return ();
  }

  if (op == op::unpause) {
    require_admin(sender, admin_address);

    paused = 0;
    save_data();

    emit_log_simple(EVENT_CONTRACT_UNPAUSED, 1);
    return ();
  }

  ;; Unknown operation
  throw(0xFFFF);
}

;; ================================================================
;; GET METHODS
;; ================================================================

;; Get admin address
slice get_admin() method_id {
  load_data();
  return admin_address;
}

;; Get guardian public key
int get_guardian_pubkey() method_id {
  load_data();
  return guardian_pubkey;
}

;; Get master factory address
slice get_master_factory() method_id {
  load_data();
  return master_factory_address;
}

;; Get total SBTs minted
int get_total_sbts_minted() method_id {
  load_data();
  return total_sbts_minted;
}

;; Get paused status
int get_paused() method_id {
  load_data();
  return paused;
}

;; Get user KYC tier
;; Returns: 0=None, 1=Basic, 2=Standard, 3=Enhanced
int get_user_tier(slice user_addr) method_id {
  load_data();

  int addr_hash = slice_hash(user_addr);
  (slice tier_data, int found) = udict_get?(sbt_registry, 256, addr_hash);

  if (found == 0) {
    return KYC_TIER_NONE;
  }
  int tier = tier_data~load_uint(8);
  return tier;
}

;; Check if user has required KYC tier
;; Returns: 1 if authorized, 0 if not
int check_kyc(slice user_addr, int required_tier) method_id {
  load_data();
  return check_user_kyc(user_addr, required_tier);
}

;; Check if user is whitelisted
int is_whitelisted(slice user_addr) method_id {
  load_data();

  int addr_hash = slice_hash(user_addr);
  (_, int found) = udict_get?(whitelist, 256, addr_hash);
  if (found == 0) {
    return 0;
  }
  return 1;
}

;; Check if user is blacklisted
int is_blacklisted(slice user_addr) method_id {
  load_data();

  int addr_hash = slice_hash(user_addr);
  (_, int found) = udict_get?(blacklist, 256, addr_hash);
  if (found == 0) {
    return 0;
  }
  return 1;
}

;; Get coverage limits by tier
;; Returns: (max_coverage_usd, max_duration_days)
(int, int) get_tier_limits(int tier) method_id {
  if (tier == KYC_TIER_BASIC) {
    return (5000, 30); ;; $5K, 30 days
  }
  if (tier == KYC_TIER_STANDARD) {
    return (50000, 90); ;; $50K, 90 days
  }
  if (tier == KYC_TIER_ENHANCED) {
    return (500000, 365); ;; $500K, 365 days
  }
  return (0, 0); ;; No KYC, no coverage
}

;; Get contract version
int get_version() method_id {
  return 3; ;; V3
}

;; ================================================================
;; END OF SBTVERIFIER CONTRACT
;; ================================================================
