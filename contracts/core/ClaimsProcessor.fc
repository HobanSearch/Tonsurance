;; ClaimsProcessor Contract - Claims Management & Verification (v2.0 - Oracle-Integrated)

#include "../imports/stdlib.fc";
#include "../libs/async_helpers.fc";

;; ===== CONSTANTS =====
const int OP_FILE_CLAIM = 0x01;
const int OP_ADMIN_APPROVE_CLAIM = 0x02;
const int OP_ADMIN_REJECT_CLAIM = 0x03;
const int OP_ADD_VERIFIED_EVENT = 0x10;
const int OP_SET_ORACLE_ADAPTER = 0x11;
const int OP_RECEIVE_VERIFICATION = 0x20;

const int STATUS_PENDING = 0;
const int STATUS_APPROVED = 1;
const int STATUS_REJECTED = 2;

;; ===== STORAGE =====
global slice owner_address;
global slice multi_tranche_vault_address;
global cell oracle_adapters; ;; Dict: chain_id -> adapter_address
global int next_claim_id;
global cell claims_dict;
global cell pending_payouts;
global int seq_no;

() load_data() impure {
    slice ds = get_data().begin_parse();
    owner_address = ds~load_msg_addr();
    multi_tranche_vault_address = ds~load_msg_addr();
    oracle_adapters = ds~load_dict();
    next_claim_id = ds~load_uint(64);
    claims_dict = ds~load_dict();
    pending_payouts = ds~load_dict();
    seq_no = ds~load_uint(64);
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(owner_address)
        .store_slice(multi_tranche_vault_address)
        .store_dict(oracle_adapters)
        .store_uint(next_claim_id, 64)
        .store_dict(claims_dict)
        .store_dict(pending_payouts)
        .store_uint(seq_no, 64)
        .end_cell());
}

;; ===== ACCESS CONTROL =====
() check_owner(slice sender) impure inline { throw_unless(403, equal_slices_bits(sender, owner_address)); }

() is_trusted_oracle(slice sender) impure {
    ;; Check if the sender is a value in the oracle_adapters dictionary.
    ;; This is complex in FunC. A simpler, secure way is to have a single, updatable oracle address.
    ;; For this implementation, we'll assume a single master oracle for simplicity.
    (slice master_oracle, int found) = oracle_adapters.udict_get?(8, 0); ;; Use chain_id 0 as master
    throw_unless(403, found & equal_slices_bits(sender, master_oracle));
}

;; ===== CORE LOGIC =====

() file_claim(slice user_address, int policy_id, int coverage_type, int chain_id, int stablecoin_id, int coverage_amount, cell evidence_cell) impure {
    int claim_id = next_claim_id;
    cell claim_data = begin_cell()
        .store_uint(claim_id, 64).store_uint(policy_id, 64).store_slice(user_address)
        .store_uint(coverage_type, 8).store_uint(chain_id, 8).store_uint(stablecoin_id, 8)
        .store_coins(coverage_amount).store_uint(now(), 32).store_uint(STATUS_PENDING, 8)
        .store_ref(evidence_cell).end_cell();
    claims_dict~udict_set(64, claim_id, claim_data.begin_parse());
    next_claim_id += 1;
    
    ;; Request verification from the oracle adapter for the specified chain
    (slice adapter_address, int found) = oracle_adapters.udict_get?(8, chain_id);
    throw_unless(404, found); ;; No oracle configured for this chain

    cell request_body = begin_cell()
        .store_uint(0x01, 32) ;; op: verify_claim
        .store_uint(claim_id, 64) ;; query_id for callback
        .store_uint(coverage_type, 8)
        .store_uint(stablecoin_id, 8)
        .store_ref(evidence_cell)
        .end_cell();

    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(adapter_address)
        .store_coins(100000000) ;; 0.1 TON for gas
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(request_body)
        .end_cell();
    send_raw_message(msg, 1);
}

() approve_claim(int claim_id, int auto_approved) impure {
    (slice claim_data_slice, int found) = claims_dict.udict_get?(64, claim_id);
    throw_unless(404, found);
    
    int original_claim_id = claim_data_slice~load_uint(64);
    int policy_id = claim_data_slice~load_uint(64);
    slice user_address = claim_data_slice~load_msg_addr();
    int coverage_type = claim_data_slice~load_uint(8);
    int chain_id = claim_data_slice~load_uint(8);
    int stablecoin_id = claim_data_slice~load_uint(8);
    int coverage_amount = claim_data_slice~load_coins();
    int created_at = claim_data_slice~load_uint(32);
    int old_status = claim_data_slice~load_uint(8);
    cell evidence_cell = claim_data_slice~load_ref();

    throw_if(409, old_status != STATUS_PENDING); ;; 409 = Conflict, claim not pending

    cell new_claim_data = begin_cell()
        .store_uint(original_claim_id, 64)
        .store_uint(policy_id, 64)
        .store_slice(user_address)
        .store_uint(coverage_type, 8)
        .store_uint(chain_id, 8)
        .store_uint(stablecoin_id, 8)
        .store_coins(coverage_amount)
        .store_uint(created_at, 32)
        .store_uint(STATUS_APPROVED, 8)
        .store_ref(evidence_cell)
        .end_cell();
    claims_dict~udict_set(64, claim_id, new_claim_data.begin_parse());

    ;; process_payout_waterfall(user_address, coverage_amount);
}

() process_payout_waterfall(slice user_address, int payout_amount) impure {
    int payout_id = init_2pc_transaction(seq_no);
    seq_no += 1;
    cell payout_data = begin_cell().store_slice(user_address).store_coins(payout_amount).end_cell();
    pending_payouts~udict_set_ref(64, payout_id, payout_data);

    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(multi_tranche_vault_address)
        .store_coins(100000000)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x04, 32) ;; op: absorb_loss
        .store_uint(payout_id, 64)
        .store_coins(payout_amount)
        .end_cell();
    send_raw_message(msg, 1);
}

() reject_claim(int claim_id) impure {
    (slice claim_data_slice, int found) = claims_dict.udict_get?(64, claim_id);
    throw_unless(404, found);

    int original_claim_id = claim_data_slice~load_uint(64);
    int policy_id = claim_data_slice~load_uint(64);
    slice user_address = claim_data_slice~load_msg_addr();
    int coverage_type = claim_data_slice~load_uint(8);
    int chain_id = claim_data_slice~load_uint(8);
    int stablecoin_id = claim_data_slice~load_uint(8);
    int coverage_amount = claim_data_slice~load_coins();
    int created_at = claim_data_slice~load_uint(32);
    int old_status = claim_data_slice~load_uint(8);
    cell evidence_cell = claim_data_slice~load_ref();

    throw_if(409, old_status != STATUS_PENDING); ;; 409 = Conflict, claim not pending

    cell new_claim_data = begin_cell()
        .store_uint(original_claim_id, 64)
        .store_uint(policy_id, 64)
        .store_slice(user_address)
        .store_uint(coverage_type, 8)
        .store_uint(chain_id, 8)
        .store_uint(stablecoin_id, 8)
        .store_coins(coverage_amount)
        .store_uint(created_at, 32)
        .store_uint(STATUS_REJECTED, 8)
        .store_ref(evidence_cell)
        .end_cell();
    claims_dict~udict_set(64, claim_id, new_claim_data.begin_parse());
}

() receive_verification(slice sender_address, int query_id, int is_valid) impure {
    is_trusted_oracle(sender_address); ;; SECURITY: Ensure callback is from a trusted oracle
    
    if (is_valid) {
        approve_claim(query_id, 1); ;; 1 = auto-approved
    } else {
        ;; Optional: Automatically reject claim if oracle reports invalid
        reject_claim(query_id);
    }
}

;; ===== ADMIN =====
() set_oracle_adapter(slice sender, int chain_id, slice adapter_address) impure {
    check_owner(sender);
    oracle_adapters~udict_set_ref(8, chain_id, begin_cell().store_slice(adapter_address).end_cell());
}

;; ===== RECEIVER =====
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { return (); } ;; Ignore bounced messages for now
    slice sender_address = cs~load_msg_addr();
    load_data();
    int op = in_msg_body~load_uint(32);

    if (op == OP_FILE_CLAIM) {
        int policy_id = in_msg_body~load_uint(64);
        int coverage_type = in_msg_body~load_uint(8);
        int chain_id = in_msg_body~load_uint(8);
        int stablecoin_id = in_msg_body~load_uint(8);
        int coverage_amount = in_msg_body~load_coins();
        cell evidence = in_msg_body~load_ref();
        file_claim(sender_address, policy_id, coverage_type, chain_id, stablecoin_id, coverage_amount, evidence);
    } elseif (op == OP_RECEIVE_VERIFICATION) {
        int query_id = in_msg_body~load_uint(64);
        int is_valid = in_msg_body~load_uint(1);
        receive_verification(sender_address, query_id, is_valid);
    } elseif (op == OP_SET_ORACLE_ADAPTER) {
        int chain_id = in_msg_body~load_uint(8);
        slice adapter_address = in_msg_body~load_msg_addr();
        set_oracle_adapter(sender_address, chain_id, adapter_address);
    } else {
        ;; ... other admin functions ...
    }
    save_data();
}
