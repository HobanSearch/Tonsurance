;; PolicyShard Contract - Sharded Policy Storage (1 of 256 shards)
;; Each shard handles policies where policy_id % 256 == shard_id
;; Optimized for gas efficiency with O(log N) dict operations
;; Target: <50k gas per operation at ~4,000 policies per shard

#include "../imports/stdlib.fc";
#include "../libs/async_helpers.fc";
#include "../libs/risk_multipliers.fc";

;; ===== STORAGE STRUCTURE =====
;; shard_id: uint8 (0-255)
;; router_address: slice (only PolicyRouter can create policies)
;; owner_address: slice (admin for emergencies)
;; claims_processor_address: slice (can mark policies as claimed)
;; shard_policy_count: uint32 (policies in this shard)
;; paused: uint1 (emergency pause)
;; policies_dict: cell (dict<uint64, cell> - policy_id -> policy_data)

global int shard_id;
global slice router_address;
global slice owner_address;
global slice claims_processor_address;
global int shard_policy_count;
global int paused;
global cell policies_dict;

() load_data() impure {
    slice ds = get_data().begin_parse();
    shard_id = ds~load_uint(8);
    router_address = ds~load_msg_addr();
    owner_address = ds~load_msg_addr();
    claims_processor_address = ds~load_msg_addr();
    shard_policy_count = ds~load_uint(32);
    paused = ds~load_uint(1);
    policies_dict = ds~load_dict();
}

() save_data() impure {
    set_data(begin_cell()
        .store_uint(shard_id, 8)
        .store_slice(router_address)
        .store_slice(owner_address)
        .store_slice(claims_processor_address)
        .store_uint(shard_policy_count, 32)
        .store_uint(paused, 1)
        .store_dict(policies_dict)
        .end_cell());
}

;; ===== ACCESS CONTROL =====

() check_router(slice sender_address) impure inline {
    throw_unless(403, equal_slices_bits(sender_address, router_address));
}

() check_owner(slice sender_address) impure inline {
    throw_unless(403, equal_slices_bits(sender_address, owner_address));
}

() check_claims_processor(slice sender_address) impure inline {
    throw_unless(403, equal_slices_bits(sender_address, claims_processor_address));
}

() check_not_paused() impure inline {
    throw_if(423, paused);
}

;; ===== SHARD VALIDATION =====

;; Validate that policy_id belongs to this shard
() validate_shard_assignment(int policy_id) impure inline {
    int expected_shard = policy_id % 256;
    throw_unless(402, expected_shard == shard_id);
}

;; ===== POLICY CREATION =====

;; Create policy (called by PolicyRouter via async message)
;; Gas target: <40k gas (O(log N) insert, N = ~4,000 at 1M scale)
() create_policy_sharded(
    slice sender_address,
    int policy_id,
    slice user_address,
    int coverage_type,
    int chain_id,
    int stablecoin_id,
    int coverage_amount,
    int duration_days,
    int calculated_premium
) impure {
    ;; Security: Only PolicyRouter can call this
    check_router(sender_address);
    check_not_paused();

    ;; Validate policy_id belongs to this shard
    validate_shard_assignment(policy_id);

    ;; Check policy doesn't already exist (prevent duplicates)
    (slice existing, int found) = policies_dict.udict_get?(64, policy_id);
    throw_if(409, found);  ;; 409 = Conflict (policy already exists)

    ;; Create policy data
    int start_time = now();
    int end_time = start_time + (duration_days * 86400);
    int product_hash = calculate_product_hash(coverage_type, chain_id, stablecoin_id);

    ;; Store policy in compact format
    ;; Total size: ~512 bits (64 bytes per policy)
    cell policy_data = begin_cell()
        .store_uint(policy_id, 64)
        .store_slice(user_address)
        .store_uint(coverage_type, 8)
        .store_uint(chain_id, 8)
        .store_uint(stablecoin_id, 8)
        .store_coins(coverage_amount)
        .store_uint(start_time, 32)
        .store_uint(end_time, 32)
        .store_uint(1, 1)  ;; active flag
        .store_uint(0, 1)  ;; claimed flag
        .store_coins(calculated_premium)
        .store_uint(product_hash, 32)
        .end_cell();

    ;; Store in shard-local dict (O(log N) operation)
    policies_dict~udict_set_ref(64, policy_id, policy_data);
    shard_policy_count += 1;
    save_data();

    ;; Send confirmation back to user (async)
    ;; This confirms policy was created successfully
    cell confirmation_msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(user_address)
        .store_coins(10000000)  ;; 0.01 TON for notification
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x50, 32)  ;; op::policy_created
        .store_uint(policy_id, 64)
        .store_uint(shard_id, 8)
        .store_coins(calculated_premium)
        .end_cell();
    send_raw_message(confirmation_msg, 1);

    ;; Emit PolicyCreatedInShard event for monitoring
    emit_log(0x51, begin_cell()
        .store_uint(policy_id, 64)
        .store_uint(shard_id, 8)
        .store_slice(user_address)
        .store_uint(coverage_type, 8)
        .store_uint(chain_id, 8)
        .store_uint(stablecoin_id, 8)
        .store_coins(coverage_amount)
        .store_uint(duration_days, 16)
        .store_uint(product_hash, 32)
        .end_cell().begin_parse());
}

;; ===== POLICY QUERIES =====

;; Get policy data (O(log N) lookup)
;; Gas target: <10k gas
;; Returns: (coverage_type, chain_id, stablecoin_id, coverage_amount, premium, start_time, duration, active)
(int, int, int, int, int, int, int, int) get_policy_data(int policy_id) method_id {
    load_data();

    ;; Validate policy_id belongs to this shard
    validate_shard_assignment(policy_id);

    ;; Lookup policy (O(log N))
    (cell policy_cell, int found) = policies_dict.udict_get_ref?(64, policy_id);
    throw_unless(404, found);

    slice policy_slice = policy_cell.begin_parse();

    ;; Parse policy data
    int stored_policy_id = policy_slice~load_uint(64);
    slice user_address = policy_slice~load_msg_addr();
    int coverage_type = policy_slice~load_uint(8);
    int chain_id = policy_slice~load_uint(8);
    int stablecoin_id = policy_slice~load_uint(8);
    int coverage_amount = policy_slice~load_coins();
    int start_time = policy_slice~load_uint(32);
    int end_time = policy_slice~load_uint(32);
    int active = policy_slice~load_uint(1);
    int claimed = policy_slice~load_uint(1);
    int premium = policy_slice~load_coins();
    int product_hash = policy_slice~load_uint(32);

    ;; Calculate duration
    int duration = (end_time - start_time) / 86400;

    return (coverage_type, chain_id, stablecoin_id, coverage_amount, premium, start_time, duration, active);
}

;; Get full policy details (includes user address and claimed status)
;; Returns: (policy_id, user_address, coverage_type, chain_id, stablecoin_id, coverage_amount,
;;           start_time, end_time, active, claimed, premium, product_hash)
(int, slice, int, int, int, int, int, int, int, int, int, int) get_full_policy_data(int policy_id) method_id {
    load_data();

    validate_shard_assignment(policy_id);

    (cell policy_cell, int found) = policies_dict.udict_get_ref?(64, policy_id);
    throw_unless(404, found);

    slice policy_slice = policy_cell.begin_parse();

    int stored_policy_id = policy_slice~load_uint(64);
    slice user_address = policy_slice~load_msg_addr();
    int coverage_type = policy_slice~load_uint(8);
    int chain_id = policy_slice~load_uint(8);
    int stablecoin_id = policy_slice~load_uint(8);
    int coverage_amount = policy_slice~load_coins();
    int start_time = policy_slice~load_uint(32);
    int end_time = policy_slice~load_uint(32);
    int active = policy_slice~load_uint(1);
    int claimed = policy_slice~load_uint(1);
    int premium = policy_slice~load_coins();
    int product_hash = policy_slice~load_uint(32);

    return (stored_policy_id, user_address, coverage_type, chain_id, stablecoin_id,
            coverage_amount, start_time, end_time, active, claimed, premium, product_hash);
}

;; ===== POLICY UPDATES =====

;; Mark policy as claimed (called by ClaimsProcessor via async)
;; Gas target: <30k gas (O(log N) update)
() mark_policy_claimed(slice sender_address, int policy_id) impure {
    ;; Only ClaimsProcessor or owner can call this
    int is_claims_processor = equal_slices_bits(sender_address, claims_processor_address);
    int is_owner = equal_slices_bits(sender_address, owner_address);
    throw_unless(403, is_claims_processor | is_owner);

    validate_shard_assignment(policy_id);

    ;; Fetch policy (O(log N))
    (cell policy_cell, int found) = policies_dict.udict_get_ref?(64, policy_id);
    throw_unless(404, found);

    slice policy_slice = policy_cell.begin_parse();

    ;; Parse policy data
    int stored_policy_id = policy_slice~load_uint(64);
    slice user_address = policy_slice~load_msg_addr();
    int coverage_type = policy_slice~load_uint(8);
    int chain_id = policy_slice~load_uint(8);
    int stablecoin_id = policy_slice~load_uint(8);
    int coverage_amount = policy_slice~load_coins();
    int start_time = policy_slice~load_uint(32);
    int end_time = policy_slice~load_uint(32);
    int active = policy_slice~load_uint(1);
    int claimed = policy_slice~load_uint(1);
    int premium = policy_slice~load_coins();
    int product_hash = policy_slice~load_uint(32);

    ;; Prevent double-claiming
    throw_if(410, claimed);  ;; 410 = Already claimed

    ;; Rebuild with claimed = 1
    cell updated_policy = begin_cell()
        .store_uint(stored_policy_id, 64)
        .store_slice(user_address)
        .store_uint(coverage_type, 8)
        .store_uint(chain_id, 8)
        .store_uint(stablecoin_id, 8)
        .store_coins(coverage_amount)
        .store_uint(start_time, 32)
        .store_uint(end_time, 32)
        .store_uint(active, 1)
        .store_uint(1, 1)  ;; claimed = true
        .store_coins(premium)
        .store_uint(product_hash, 32)
        .end_cell();

    ;; Update in dict (O(log N))
    policies_dict~udict_set_ref(64, policy_id, updated_policy);
    save_data();

    ;; Emit PolicyClaimed event
    emit_log(0x52, begin_cell()
        .store_uint(policy_id, 64)
        .store_uint(shard_id, 8)
        .store_coins(coverage_amount)
        .end_cell().begin_parse());
}

;; Mark policy as inactive (expired or cancelled)
() mark_policy_inactive(slice sender_address, int policy_id) impure {
    ;; Only owner can call this
    check_owner(sender_address);

    validate_shard_assignment(policy_id);

    (cell policy_cell, int found) = policies_dict.udict_get_ref?(64, policy_id);
    throw_unless(404, found);

    slice policy_slice = policy_cell.begin_parse();

    int stored_policy_id = policy_slice~load_uint(64);
    slice user_address = policy_slice~load_msg_addr();
    int coverage_type = policy_slice~load_uint(8);
    int chain_id = policy_slice~load_uint(8);
    int stablecoin_id = policy_slice~load_uint(8);
    int coverage_amount = policy_slice~load_coins();
    int start_time = policy_slice~load_uint(32);
    int end_time = policy_slice~load_uint(32);
    int active = policy_slice~load_uint(1);
    int claimed = policy_slice~load_uint(1);
    int premium = policy_slice~load_coins();
    int product_hash = policy_slice~load_uint(32);

    ;; Rebuild with active = 0
    cell updated_policy = begin_cell()
        .store_uint(stored_policy_id, 64)
        .store_slice(user_address)
        .store_uint(coverage_type, 8)
        .store_uint(chain_id, 8)
        .store_uint(stablecoin_id, 8)
        .store_coins(coverage_amount)
        .store_uint(start_time, 32)
        .store_uint(end_time, 32)
        .store_uint(0, 1)  ;; active = false
        .store_uint(claimed, 1)
        .store_coins(premium)
        .store_uint(product_hash, 32)
        .end_cell();

    policies_dict~udict_set_ref(64, policy_id, updated_policy);
    save_data();
}

;; ===== SHARD STATISTICS =====

;; Get shard statistics for monitoring
;; Returns: (shard_id, policy_count)
(int, int) get_shard_stats() method_id {
    load_data();
    return (shard_id, shard_policy_count);
}

;; Get shard health metrics
;; Returns: (shard_id, policy_count, paused, gas_estimate)
(int, int, int, int) get_shard_health() method_id {
    load_data();

    ;; Estimate gas cost based on dict size
    ;; Rough formula: 5000 + (log2(policy_count) * 1000)
    int gas_estimate = 5000;
    int temp_count = shard_policy_count;
    while (temp_count > 1) {
        gas_estimate += 1000;
        temp_count /= 2;
    }

    return (shard_id, shard_policy_count, paused, gas_estimate);
}

;; ===== ADMIN FUNCTIONS =====

;; Emergency pause (owner only)
() pause_shard(slice sender_address) impure {
    check_owner(sender_address);
    paused = 1;
    save_data();

    emit_log(0x53, begin_cell()
        .store_uint(shard_id, 8)
        .store_uint(1, 1)  ;; paused = true
        .end_cell().begin_parse());
}

;; Resume shard (owner only)
() unpause_shard(slice sender_address) impure {
    check_owner(sender_address);
    paused = 0;
    save_data();

    emit_log(0x53, begin_cell()
        .store_uint(shard_id, 8)
        .store_uint(0, 1)  ;; paused = false
        .end_cell().begin_parse());
}

;; Update router address (owner only, for upgrades)
() update_router_address(slice sender_address, slice new_router) impure {
    check_owner(sender_address);
    router_address = new_router;
    save_data();
}

;; Update claims processor address (owner only)
() update_claims_processor(slice sender_address, slice new_claims_processor) impure {
    check_owner(sender_address);
    claims_processor_address = new_claims_processor;
    save_data();
}

;; ===== MESSAGE HANDLING =====

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {  ;; Bounce message
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == 0x60) {  ;; create_policy_sharded
        int policy_id = in_msg_body~load_uint(64);
        slice user_address = in_msg_body~load_msg_addr();
        int coverage_type = in_msg_body~load_uint(8);
        int chain_id = in_msg_body~load_uint(8);
        int stablecoin_id = in_msg_body~load_uint(8);
        int coverage_amount = in_msg_body~load_coins();
        int duration_days = in_msg_body~load_uint(16);
        int calculated_premium = in_msg_body~load_coins();

        create_policy_sharded(sender_address, policy_id, user_address, coverage_type,
                             chain_id, stablecoin_id, coverage_amount, duration_days,
                             calculated_premium);
        return ();
    }

    if (op == 0x61) {  ;; mark_policy_claimed
        int policy_id = in_msg_body~load_uint(64);
        mark_policy_claimed(sender_address, policy_id);
        return ();
    }

    if (op == 0x62) {  ;; mark_policy_inactive
        int policy_id = in_msg_body~load_uint(64);
        mark_policy_inactive(sender_address, policy_id);
        return ();
    }

    if (op == 0x70) {  ;; pause_shard
        pause_shard(sender_address);
        return ();
    }

    if (op == 0x71) {  ;; unpause_shard
        unpause_shard(sender_address);
        return ();
    }

    if (op == 0x72) {  ;; update_router_address
        slice new_router = in_msg_body~load_msg_addr();
        update_router_address(sender_address, new_router);
        return ();
    }

    if (op == 0x73) {  ;; update_claims_processor
        slice new_claims_processor = in_msg_body~load_msg_addr();
        update_claims_processor(sender_address, new_claims_processor);
        return ();
    }

    throw(0xffff);  ;; Unknown operation
}

;; ===== EVENT IDs (for emit_log) =====
;; 0x51: PolicyCreatedInShard
;; 0x52: PolicyClaimed
;; 0x53: ShardPausedUnpaused
