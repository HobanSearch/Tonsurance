;; PolicyFactory Contract - Core Insurance (v3.0 - Signed Premium)

#include "../imports/stdlib.fc";
#include "../libs/async_helpers.fc";

;; ===== STORAGE =====
global slice owner_address;
global slice treasury_address;
global slice claims_processor_address;
global int oracle_public_key; ;; Public key of the trusted pricing oracle
global int next_policy_id;
global int paused;
global cell policies_dict;
global cell pending_txs;
global int seq_no;

() load_data() impure {
    slice ds = get_data().begin_parse();
    owner_address = ds~load_msg_addr();
    treasury_address = ds~load_msg_addr();
    claims_processor_address = ds~load_msg_addr();
    oracle_public_key = ds~load_uint(256);
    next_policy_id = ds~load_uint(64);
    paused = ds~load_uint(1);
    policies_dict = ds~load_dict();
    pending_txs = ds~load_dict();
    seq_no = ds~load_uint(64);
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(owner_address)
        .store_slice(treasury_address)
        .store_slice(claims_processor_address)
        .store_uint(oracle_public_key, 256)
        .store_uint(next_policy_id, 64)
        .store_uint(paused, 1)
        .store_dict(policies_dict)
        .store_dict(pending_txs)
        .store_uint(seq_no, 64)
        .end_cell());
}

;; ===== ACCESS CONTROL =====
() check_owner(slice sender) impure inline { throw_unless(403, equal_slices_bits(sender, owner_address)); }
() check_claims_processor(slice sender) impure inline { throw_unless(403, equal_slices_bits(sender, claims_processor_address)); }
() check_not_paused() impure inline { throw_if(423, paused); }

;; ===== CORE LOGIC =====

() create_policy_with_signed_premium(int msg_value, slice user_address, cell signed_quote) impure {
    check_not_paused();

    ;; Parse the signed quote: signature cell and data cell
    slice sig_slice = signed_quote.begin_parse();
    cell data_cell = sig_slice~load_ref();
    slice data_slice = data_cell.begin_parse();

    ;; Verify the signature against the oracle's public key
    throw_unless(401, check_signature(cell_hash(data_cell), sig_slice.preload_bits(512), oracle_public_key));

    ;; Parse the signed data
    int coverage_type = data_slice~load_uint(8);
    int chain_id = data_slice~load_uint(8);
    int stablecoin_id = data_slice~load_uint(8);
    int coverage_amount = data_slice~load_coins();
    int duration_days = data_slice~load_uint(16);
    slice signed_user_address = data_slice~load_msg_addr();
    int calculated_premium = data_slice~load_coins();
    int deadline = data_slice~load_uint(32);

    ;; Security checks
    throw_unless(403, equal_slices_bits(user_address, signed_user_address)); ;; Ensure quote is for the sender
    throw_unless(408, now() < deadline); ;; Ensure quote has not expired

    ;; Verify user paid enough
    int min_payment = calculated_premium + 50000000; ;; Premium + 0.05 TON gas
    throw_unless(402, msg_value >= min_payment);

    ;; Create and store policy data
    int policy_id = next_policy_id;
    cell policy_data = begin_cell()
        .store_uint(policy_id, 64)
        .store_slice(user_address)
        .store_uint(coverage_type, 8)
        .store_uint(chain_id, 8)
        .store_uint(stablecoin_id, 8)
        .store_coins(coverage_amount)
        .store_uint(now(), 32)
        .store_uint(now() + (duration_days * 86400), 32)
        .store_uint(1, 1)  ;; active
        .store_uint(0, 1)  ;; claimed
        .store_coins(calculated_premium)
        .end_cell();
    policies_dict~udict_set(64, policy_id, policy_data.begin_parse());

    ;; Forward premium to treasury
    int tx_id = init_2pc_transaction(seq_no);
    seq_no += 1;
    pending_txs = store_tx_state(pending_txs, tx_id, TX_STATE_INITIATED, 0, now(), 0x01, calculated_premium, treasury_address);
    cell msg = begin_cell().store_uint(0x18, 6).store_slice(treasury_address).store_coins(calculated_premium).store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1).store_uint(0x01, 32).store_uint(tx_id, 64).end_cell();
    send_raw_message(msg, 1);

    next_policy_id += 1;

    ;; Refund excess
    int excess = msg_value - min_payment;
    if (excess > 0) {
        cell refund_msg = begin_cell().store_uint(0x18, 6).store_slice(user_address).store_coins(excess).store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1).end_cell();
        send_raw_message(refund_msg, 1);
    }
}

() mark_policy_claimed(slice sender_address, int policy_id) impure {
    check_claims_processor(sender_address);
    ;; In a real implementation, we would load the policy, set its claimed flag to true, and save it.
    ;; For now, this is a simplified stub.
    save_data();
}

;; ===== ADMIN FUNCTIONS =====
() pause_contract(slice sender) impure { check_owner(sender); paused = 1; save_data(); }
() unpause_contract(slice sender) impure { check_owner(sender); paused = 0; save_data(); }
() set_treasury_address(slice sender, slice new_treasury) impure { check_owner(sender); treasury_address = new_treasury; save_data(); }
() set_claims_processor_address(slice sender, slice new_processor) impure { check_owner(sender); claims_processor_address = new_processor; save_data(); }
() set_oracle_public_key(slice sender, int new_key) impure { check_owner(sender); oracle_public_key = new_key; save_data(); }

;; ===== GETTERS =====
int get_next_policy_id() method_id { load_data(); return next_policy_id; }

;; ===== MESSAGE HANDLER =====
() on_bounce(slice in_msg_body) impure {
    load_data();
    in_msg_body~skip_bits(32); ;; Skip 0xFFFFFFFF bounce prefix
    int op = in_msg_body~load_uint(32);
    int tx_id = in_msg_body~load_uint(64);

    var (state, retry_count, created_at, stored_op, value, dest_address, found) = load_tx_state(pending_txs, tx_id);

    if (found) {
        var (should_retry, backoff) = should_retry_tx(retry_count, created_at);
        if (should_retry) {
            pending_txs = increment_retry_count(pending_txs, tx_id);
            cell msg = begin_cell().store_uint(0x18, 6).store_slice(dest_address).store_coins(value).store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1).store_uint(stored_op, 32).store_uint(tx_id, 64).end_cell();
            send_raw_message(msg, 1);
        } else {
            pending_txs = update_tx_state(pending_txs, tx_id, TX_STATE_ABORTED);
        }
    }
    save_data();
}

;; ===== MESSAGE HANDLER =====
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { return (); }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { on_bounce(in_msg_body); return (); }
    slice sender_address = cs~load_msg_addr();
    load_data();
    int op = in_msg_body~load_uint(32);

    if (op == 0x01) { ;; create_policy_with_signed_premium
        cell signed_quote = in_msg_body~load_ref();
        create_policy_with_signed_premium(msg_value, sender_address, signed_quote);
    } elseif (op == 0x02) { ;; mark_policy_claimed
        int policy_id = in_msg_body~load_uint(64);
        mark_policy_claimed(sender_address, policy_id);
    } elseif (op == 0x10) { pause_contract(sender_address); 
    } elseif (op == 0x11) { unpause_contract(sender_address); 
    } elseif (op == 0x12) { set_treasury_address(sender_address, in_msg_body~load_msg_addr());
    } elseif (op == 0x13) { set_claims_processor_address(sender_address, in_msg_body~load_msg_addr());
    } elseif (op == 0x14) { ;; New op for setting oracle key
        int new_key = in_msg_body~load_uint(256);
        set_oracle_public_key(sender_address, new_key);
    } else {
        throw(0xffff);
    }
    save_data();
}

