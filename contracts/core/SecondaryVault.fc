;; SecondaryVault Contract - Second-Loss Capital Vault
;; SURE token stakers provide second-loss capital
;; 20% of total capital allocation (40% in bonding curve model)
;; 90-day lock-up period
;; Medium APY (50-100% with bonding curve)
;; Linear bonding curve: 1.0 → 1.25 USDT

#include "../imports/stdlib.fc";

;; Storage structure
global slice owner_address;
global int total_staked_sure;
global int accumulated_yield;
global int losses_absorbed;
global slice claims_processor_address;
global cell staker_data;  ;; address_hash -> (amount, stake_time, unlock_time)

;; Bonding curve parameters (linear)
global int price_min;  ;; 1.0 USDT in nanoTON
global int price_max;  ;; 1.25 USDT in nanoTON
global int max_supply;  ;; Maximum SHIELD-STAKE tokens
global int total_supply;  ;; Current supply

const int LOCK_PERIOD = 7776000;  ;; 90 days in seconds

() load_data() impure {
    slice ds = get_data().begin_parse();
    owner_address = ds~load_msg_addr();
    total_staked_sure = ds~load_coins();
    accumulated_yield = ds~load_coins();
    losses_absorbed = ds~load_coins();
    claims_processor_address = ds~load_msg_addr();
    staker_data = ds~load_dict();
    price_min = ds~load_coins();
    price_max = ds~load_coins();
    max_supply = ds~load_uint(64);
    total_supply = ds~load_uint(64);
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(owner_address)
        .store_coins(total_staked_sure)
        .store_coins(accumulated_yield)
        .store_coins(losses_absorbed)
        .store_slice(claims_processor_address)
        .store_dict(staker_data)
        .store_coins(price_min)
        .store_coins(price_max)
        .store_uint(max_supply, 64)
        .store_uint(total_supply, 64)
        .end_cell());
}

() check_owner(slice sender_address) impure {
    throw_unless(403, equal_slices_bits(sender_address, owner_address));
}

;; Calculate current token price (linear bonding curve)
;; Price = Price_min + (Price_max - Price_min) × (supply / max_supply)
int get_current_price() inline {
    if (total_supply == 0) {
        return price_min;
    }

    ;; Calculate utilization ratio with 9 decimal precision
    int utilization = muldiv(total_supply, 1000000000, max_supply);
    int price_range = price_max - price_min;
    int price_increase = muldiv(price_range, utilization, 1000000000);
    int price = price_min + price_increase;

    return price;
}

;; Calculate tokens received for stake
int calculate_tokens(int stake_amount) inline {
    int current_price = get_current_price();
    ;; Both stake_amount and current_price are in nanoTON
    ;; Result is in unit tokens (not nano)
    int tokens = stake_amount / current_price;

    throw_unless(400, total_supply + tokens <= max_supply);  ;; Max capacity

    return tokens;
}

;; Stake SURE tokens
() stake_sure(slice staker, int amount, int duration) impure {
    throw_unless(400, amount >= 100000000);  ;; Min 0.1 TON

    ;; Verify duration is 90 days
    throw_unless(401, duration == 90);

    ;; Calculate tokens with bonding curve
    int tokens = calculate_tokens(amount);

    ;; Get current stake info
    (slice stake_info, int found) = staker_data.udict_get?(267, slice_hash(staker));

    int current_stake = 0;
    int stake_time = now();
    int unlock_time = stake_time + LOCK_PERIOD;
    int current_tokens = 0;

    if (found) {
        current_stake = stake_info~load_coins();
        stake_time = stake_info~load_uint(32);
        unlock_time = stake_info~load_uint(32);
        current_tokens = stake_info~load_uint(64);
    }

    ;; Update stake
    int new_stake = current_stake + amount;
    int new_tokens = current_tokens + tokens;

    cell new_stake_data = begin_cell()
        .store_coins(new_stake)
        .store_uint(stake_time, 32)
        .store_uint(unlock_time, 32)
        .store_uint(new_tokens, 64)
        .end_cell();

    staker_data~udict_set(267, slice_hash(staker), new_stake_data.begin_parse());

    total_staked_sure += amount;
    total_supply += tokens;
    save_data();

    ;; Emit event
    emit_log(0x20, begin_cell()
        .store_slice(staker)
        .store_coins(amount)
        .store_uint(tokens, 64)
        .store_uint(unlock_time, 32)
        .end_cell().begin_parse());
}

;; Unstake SURE tokens
() unstake_sure(slice staker, int token_amount) impure {
    (slice stake_info, int found) = staker_data.udict_get?(267, slice_hash(staker));
    throw_unless(404, found);

    int current_stake = stake_info~load_coins();
    int stake_time = stake_info~load_uint(32);
    int unlock_time = stake_info~load_uint(32);
    int current_tokens = stake_info~load_uint(64);

    ;; Check lock period
    throw_unless(410, now() >= unlock_time);

    ;; Check token balance
    throw_unless(400, token_amount <= current_tokens);

    ;; Calculate SURE to return (proportional to original stake)
    ;; Return pro-rata share of original stake, not recalculated at current price
    int sure_amount = muldiv(current_stake, token_amount, current_tokens);

    ;; Calculate share of yield
    int yield_share = 0;
    if (total_staked_sure > 0) {
        yield_share = muldiv(accumulated_yield, current_stake, total_staked_sure);
    }

    ;; Subtract pro-rata losses
    int loss_share = 0;
    if (total_staked_sure > 0) {
        loss_share = muldiv(losses_absorbed, current_stake, total_staked_sure);
    }

    int total_return = sure_amount + yield_share - loss_share;

    ;; Check vault has sufficient balance
    int vault_balance = get_balance().pair_first();
    throw_unless(401, total_return <= vault_balance);

    ;; Update state
    int new_stake = current_stake - sure_amount;
    int new_tokens = current_tokens - token_amount;

    if (new_stake > 0) {
        staker_data~udict_set(267, slice_hash(staker),
            begin_cell()
                .store_coins(new_stake)
                .store_uint(stake_time, 32)
                .store_uint(unlock_time, 32)
                .store_uint(new_tokens, 64)
                .end_cell().begin_parse());
    } else {
        staker_data~udict_delete?(267, slice_hash(staker));
    }

    total_staked_sure -= sure_amount;
    total_supply -= token_amount;
    save_data();

    ;; Send funds to staker
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(staker)
        .store_coins(total_return)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .end_cell();
    send_raw_message(msg, 1);

    ;; Emit event
    emit_log(0x21, begin_cell()
        .store_slice(staker)
        .store_uint(token_amount, 64)
        .store_coins(total_return)
        .end_cell().begin_parse());
}

;; Receive premium share (from Treasury)
() receive_premium_share(int amount) impure {
    accumulated_yield += amount;
    save_data();

    emit_log(0x22, begin_cell()
        .store_coins(amount)
        .store_coins(accumulated_yield)
        .end_cell().begin_parse());
}

;; Absorb loss if needed (called by ClaimsProcessor)
;; Only triggered if Primary Vault is exhausted
() absorb_loss_if_needed(slice sender_address, int loss_amount) impure {
    throw_unless(403, equal_slices_bits(sender_address, claims_processor_address));

    int vault_balance = get_balance().pair_first() - 100000000;
    throw_unless(400, loss_amount <= vault_balance);

    losses_absorbed += loss_amount;
    save_data();

    ;; Forward funds to ClaimsProcessor
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(claims_processor_address)
        .store_coins(loss_amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x21, 32)  ;; op: secondary_vault_funds
        .end_cell();
    send_raw_message(msg, 1);

    emit_log(0x23, begin_cell()
        .store_coins(loss_amount)
        .store_coins(losses_absorbed)
        .end_cell().begin_parse());
}

;; Admin functions
() set_claims_processor(slice sender_address, slice new_processor) impure {
    check_owner(sender_address);
    claims_processor_address = new_processor;
    save_data();
}

() set_bonding_curve_params(slice sender_address, int new_price_min, int new_price_max, int new_max_supply) impure {
    check_owner(sender_address);
    price_min = new_price_min;
    price_max = new_price_max;
    max_supply = new_max_supply;
    save_data();
}

;; Get methods
(int, int, int, int) get_stake_info(slice addr) method_id {
    load_data();
    (slice stake_info, int found) = staker_data.udict_get?(267, slice_hash(addr));
    if (~ found) {
        return (0, 0, 0, 0);
    }
    int amount = stake_info~load_coins();
    int stake_time = stake_info~load_uint(32);
    int unlock_time = stake_info~load_uint(32);
    int tokens = stake_info~load_uint(64);
    return (amount, stake_time, unlock_time, tokens);
}

int get_total_staked() method_id {
    load_data();
    return total_staked_sure;
}

int get_accumulated_yield() method_id {
    load_data();
    return accumulated_yield;
}

int get_losses_absorbed() method_id {
    load_data();
    return losses_absorbed;
}

int get_current_token_price() method_id {
    load_data();
    return get_current_price();
}

(int, int, int) get_bonding_curve_params() method_id {
    load_data();
    return (price_min, price_max, max_supply);
}

int get_total_supply() method_id {
    load_data();
    return total_supply;
}

;; Recv internal
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == 0x01) {  ;; stake_sure
        int amount = in_msg_body~load_coins();
        int duration = in_msg_body~load_uint(16);
        stake_sure(sender_address, amount, duration);
        return ();
    }

    if (op == 0x02) {  ;; unstake_sure
        int token_amount = in_msg_body~load_uint(64);
        unstake_sure(sender_address, token_amount);
        return ();
    }

    if (op == 0x03) {  ;; receive_premium_share
        int amount = in_msg_body~load_coins();
        receive_premium_share(amount);
        return ();
    }

    if (op == 0x04) {  ;; absorb_loss_if_needed
        int loss_amount = in_msg_body~load_coins();
        absorb_loss_if_needed(sender_address, loss_amount);
        return ();
    }

    if (op == 0x10) {  ;; set_claims_processor
        slice new_processor = in_msg_body~load_msg_addr();
        set_claims_processor(sender_address, new_processor);
        return ();
    }

    if (op == 0x11) {  ;; set_bonding_curve_params
        int new_min = in_msg_body~load_coins();
        int new_max = in_msg_body~load_coins();
        int new_supply = in_msg_body~load_uint(64);
        set_bonding_curve_params(sender_address, new_min, new_max, new_supply);
        return ();
    }

    throw(0xffff);
}

;; Note: emit_log() is now implemented in stdlib.fc
;; SecondaryVault uses event logging for staking, unstaking, and payout operations
