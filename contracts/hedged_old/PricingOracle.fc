#include "../imports/stdlib.fc";

;; Storage structure
;; - admin_address: slice
;; - authorized_keepers: dict (slice -> bool)
;; - hedge_prices: dict (int -> cell)
;;     key: coverage_type (1=DEPEG, 2=EXPLOIT, 3=BRIDGE)
;;     value: cell containing (polymarket_odds, perp_funding_rate, allianz_quote, timestamp)
;; - last_update_time: int

;; Error codes
const int error::unauthorized = 401;
const int error::invalid_coverage_type = 402;
const int error::stale_oracle_data = 408;
const int error::invalid_price_data = 409;

;; Op codes
const int op::update_hedge_prices = 0x75706461;  ;; "upda"
const int op::add_keeper = 0x61646b70;            ;; "adkp"
const int op::remove_keeper = 0x726d6b70;         ;; "rmkp"

;; Coverage types
const int coverage::depeg = 1;
const int coverage::exploit = 2;
const int coverage::bridge = 3;

;; Constants
const int max_staleness = 300;  ;; 5 minutes in seconds
const int basis_points = 10000;

;; Storage management
global slice g_admin_address;
global cell g_authorized_keepers;
global cell g_hedge_prices;
global int g_last_update_time;

() load_data() impure {
    slice ds = get_data().begin_parse();
    g_admin_address = ds~load_msg_addr();
    g_authorized_keepers = ds~load_dict();
    g_hedge_prices = ds~load_dict();
    g_last_update_time = ds~load_uint(32);
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(g_admin_address)
        .store_dict(g_authorized_keepers)
        .store_dict(g_hedge_prices)
        .store_uint(g_last_update_time, 32)
        .end_cell()
    );
}

;; Check if sender is authorized keeper
int is_authorized_keeper(slice sender_addr) inline {
    (slice keeper, int found) = g_authorized_keepers.udict_get?(267, slice_hash(sender_addr));
    return found;
}

;; Check if sender is admin
int is_admin(slice sender_addr) inline {
    return equal_slices_bits(sender_addr, g_admin_address);
}

;; Validate coverage type
() validate_coverage_type(int coverage_type) impure inline {
    throw_unless(error::invalid_coverage_type,
        (coverage_type == coverage::depeg) |
        (coverage_type == coverage::exploit) |
        (coverage_type == coverage::bridge)
    );
}

;; Update hedge prices for a coverage type
() update_hedge_prices(
    int coverage_type,
    int polymarket_odds,      ;; Basis points (e.g., 250 = 2.5%)
    int perp_funding_rate,    ;; Basis points per day (e.g., -50 = -0.5%)
    int allianz_quote         ;; Cents per $1000 (e.g., 450 = $4.50)
) impure {
    validate_coverage_type(coverage_type);

    ;; Validate price data ranges
    throw_unless(error::invalid_price_data, (polymarket_odds >= 0) & (polymarket_odds <= 10000));
    throw_unless(error::invalid_price_data, (perp_funding_rate >= -10000) & (perp_funding_rate <= 10000));
    throw_unless(error::invalid_price_data, (allianz_quote >= 0) & (allianz_quote <= 100000));

    ;; Store prices with timestamp
    int now_ts = now();
    cell price_data = begin_cell()
        .store_uint(polymarket_odds, 32)
        .store_int(perp_funding_rate, 32)
        .store_uint(allianz_quote, 32)
        .store_uint(now_ts, 32)
        .end_cell();

    g_hedge_prices~udict_set(8, coverage_type, price_data.begin_parse());
    g_last_update_time = now_ts;
}

;; Add authorized keeper
() add_keeper(slice keeper_addr) impure {
    g_authorized_keepers~udict_set(267, slice_hash(keeper_addr), begin_cell().store_uint(1, 1).end_cell().begin_parse());
}

;; Remove authorized keeper
() remove_keeper(slice keeper_addr) impure {
    g_authorized_keepers~udict_delete?(267, slice_hash(keeper_addr));
}

;; Main receiver
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();  ;; Ignore empty messages
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_addr = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == op::update_hedge_prices) {
        throw_unless(error::unauthorized, is_authorized_keeper(sender_addr));

        int coverage_type = in_msg_body~load_uint(8);
        int polymarket_odds = in_msg_body~load_uint(32);
        int perp_funding_rate = in_msg_body~load_int(32);
        int allianz_quote = in_msg_body~load_uint(32);

        update_hedge_prices(coverage_type, polymarket_odds, perp_funding_rate, allianz_quote);

        save_data();
        return ();
    }

    if (op == op::add_keeper) {
        throw_unless(error::unauthorized, is_admin(sender_addr));

        slice keeper_addr = in_msg_body~load_msg_addr();
        add_keeper(keeper_addr);

        save_data();
        return ();
    }

    if (op == op::remove_keeper) {
        throw_unless(error::unauthorized, is_admin(sender_addr));

        slice keeper_addr = in_msg_body~load_msg_addr();
        remove_keeper(keeper_addr);

        save_data();
        return ();
    }

    throw(0xffff);  ;; Unknown operation
}

;; Get hedge prices for a coverage type
(int, int, int, int) get_hedge_prices(int coverage_type) method_id {
    load_data();
    validate_coverage_type(coverage_type);

    (slice price_data, int found) = g_hedge_prices.udict_get?(8, coverage_type);
    throw_unless(error::invalid_coverage_type, found);

    int polymarket_odds = price_data~load_uint(32);
    int perp_funding_rate = price_data~load_int(32);
    int allianz_quote = price_data~load_uint(32);
    int timestamp = price_data~load_uint(32);

    return (polymarket_odds, perp_funding_rate, allianz_quote, timestamp);
}

;; Calculate total hedge cost for a policy
;; Returns cost in nanotons
int calculate_hedge_cost(
    int coverage_type,
    int coverage_amount,    ;; In nanotons
    int duration_days
) method_id {
    load_data();

    ;; Check if oracle data is stale (>5 min old)
    int now_ts = now();
    throw_if(error::stale_oracle_data, now_ts - g_last_update_time > max_staleness);

    ;; Fetch hedge prices
    (int poly_odds, int perp_rate, int allianz_quote, int ts) = get_hedge_prices(coverage_type);

    ;; Calculate Polymarket cost (40% allocation)
    ;; Cost = coverage_amount * (odds / 10000) * 0.4
    int poly_cost = muldiv(coverage_amount, poly_odds * 40, basis_points * 100);

    ;; Calculate Perpetuals cost (40% allocation)
    ;; Cost = coverage_amount * abs(funding_rate / 10000) * duration_days * 0.4
    ;; Use absolute value since negative funding means we earn
    int abs_perp_rate = perp_rate;
    if (perp_rate < 0) {
        abs_perp_rate = - perp_rate;
    }
    int perp_cost = muldiv(coverage_amount, abs_perp_rate * duration_days * 40, basis_points * 100);

    ;; Calculate Allianz cost (20% allocation)
    ;; Quote is in cents per $1000
    ;; Cost = coverage_amount * (quote / 100000) * 0.2
    int allianz_cost = muldiv(coverage_amount, allianz_quote * 20, 100000 * 100);

    return poly_cost + perp_cost + allianz_cost;
}

;; Get last update timestamp
int get_last_update_time() method_id {
    load_data();
    return g_last_update_time;
}

;; Check if keeper is authorized
int check_keeper_authorized(slice keeper_addr) method_id {
    load_data();
    return is_authorized_keeper(keeper_addr);
}

;; Get admin address
slice get_admin_address() method_id {
    load_data();
    return g_admin_address;
}

;; Check if oracle data is fresh
int is_data_fresh() method_id {
    load_data();
    int now_ts = now();
    return (now_ts - g_last_update_time) <= max_staleness;
}
