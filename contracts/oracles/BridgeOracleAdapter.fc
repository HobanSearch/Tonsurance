;; BridgeOracleAdapter - Bridge Exploit Verification Oracle
;;
;; This adapter verifies bridge exploit claims by validating bridge health data,
;; exploit transactions, and TVL loss events.
;;
;; Coverage Type: 3 (Bridge Exploit)
;;
;; Verification Requirements:
;; 1. Bridge contract must be paused/exploited
;; 2. Exploit transaction must be confirmed on both chains
;; 3. TVL loss must match claimed amount
;; 4. Event must be reported by multiple monitoring sources
;;
;; Evidence Format:
;; - source_chain_id: uint8
;; - dest_chain_id: uint8
;; - bridge_address: slice
;; - exploit_tx_hash: uint256
;; - exploit_timestamp: uint32
;; - stolen_amount: coins
;; - monitoring_sources: uint8 (bitmap of sources that detected it)

#include "../imports/stdlib.fc";

;; ===== CONSTANTS =====

;; Operation codes
const int OP_VERIFY_CLAIM = 0x01;
const int OP_SET_CLAIMS_PROCESSOR = 0x10;
const int OP_SET_KEEPER = 0x11;
const int OP_REPORT_EXPLOIT = 0x12;
const int OP_UPDATE_BRIDGE_STATUS = 0x13;

;; Response operation
const int OP_RECEIVE_VERIFICATION = 0x20;

;; Bridge status
const int BRIDGE_STATUS_ACTIVE = 0;
const int BRIDGE_STATUS_PAUSED = 1;
const int BRIDGE_STATUS_EXPLOITED = 2;
const int BRIDGE_STATUS_DRAINED = 3;

;; Monitoring sources (bitmap)
const int SOURCE_CHAINALYSIS = 1;      ;; bit 0
const int SOURCE_CERTIK = 2;           ;; bit 1
const int SOURCE_PECKSHIELD = 4;       ;; bit 2
const int SOURCE_BLOCKSEC = 8;         ;; bit 3
const int SOURCE_DEFILLAMA = 16;       ;; bit 4

;; Error codes
const int ERR_ACCESS_DENIED = 403;
const int ERR_INVALID_EVIDENCE = 400;
const int ERR_BRIDGE_NOT_FOUND = 404;
const int ERR_EXPLOIT_NOT_FOUND = 405;
const int ERR_INSUFFICIENT_CONFIRMATION = 406;
const int ERR_AMOUNT_MISMATCH = 407;

;; Constants
const int MIN_MONITORING_SOURCES = 2;  ;; Require 2+ sources to confirm
const int MAX_CLAIM_DELAY = 86400;     ;; 24 hours after exploit

;; ===== STORAGE =====

global slice owner_address;
global slice claims_processor_address;
global slice keeper_address;
global cell bridge_registry;  ;; Dict: bridge_address_hash -> (status, tvl, last_update)
global cell exploit_events;   ;; Dict: (bridge_hash << 64 | timestamp) -> exploit_data
global int total_exploits_tracked;

() load_data() impure {
    slice ds = get_data().begin_parse();
    owner_address = ds~load_msg_addr();
    claims_processor_address = ds~load_msg_addr();
    keeper_address = ds~load_msg_addr();
    bridge_registry = ds~load_dict();
    exploit_events = ds~load_dict();
    total_exploits_tracked = ds~load_uint(32);
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(owner_address)
        .store_slice(claims_processor_address)
        .store_slice(keeper_address)
        .store_dict(bridge_registry)
        .store_dict(exploit_events)
        .store_uint(total_exploits_tracked, 32)
        .end_cell());
}

;; ===== ACCESS CONTROL =====

() check_owner(slice sender) impure inline {
    throw_unless(ERR_ACCESS_DENIED, equal_slices_bits(sender, owner_address));
}

() check_claims_processor(slice sender) impure inline {
    throw_unless(ERR_ACCESS_DENIED, equal_slices_bits(sender, claims_processor_address));
}

() check_keeper(slice sender) impure inline {
    throw_unless(ERR_ACCESS_DENIED, equal_slices_bits(sender, keeper_address));
}

;; ===== BRIDGE REGISTRY MANAGEMENT =====

() update_bridge_status(slice bridge_address, int status, int current_tvl) impure {
    int bridge_hash = slice_hash(bridge_address);
    
    cell bridge_data = begin_cell()
        .store_uint(status, 8)
        .store_coins(current_tvl)
        .store_uint(now(), 32)
        .end_cell();

    bridge_registry~udict_set_ref(256, bridge_hash, bridge_data);
}

(int, int, int, int) get_bridge_status(slice bridge_address) inline {
    ;; Returns (status, tvl, last_update, found)
    int bridge_hash = slice_hash(bridge_address);

    (slice bridge_slice, int found) = bridge_registry.udict_get?(256, bridge_hash);
    if (~ found) {
        return (0, 0, 0, 0);
    }

    slice bs = bridge_slice~load_ref().begin_parse();
    int status = bs~load_uint(8);
    int tvl = bs~load_coins();
    int last_update = bs~load_uint(32);

    return (status, tvl, last_update, -1);
}

;; ===== EXPLOIT EVENT MANAGEMENT =====

() report_exploit(
    slice bridge_address,
    int exploit_timestamp,
    int stolen_amount,
    int tx_hash_high,
    int tx_hash_low,
    int monitoring_sources
) impure {
    int bridge_hash = slice_hash(bridge_address);
    
    ;; Create composite key: (bridge_hash << 32) | exploit_timestamp
    int event_key = (bridge_hash << 32) | exploit_timestamp;

    cell exploit_data = begin_cell()
        .store_slice(bridge_address)
        .store_coins(stolen_amount)
        .store_uint(tx_hash_high, 128)
        .store_uint(tx_hash_low, 128)
        .store_uint(monitoring_sources, 8)
        .store_uint(now(), 32)  ;; Reported at
        .end_cell();

    exploit_events~udict_set_ref(96, event_key, exploit_data);
    total_exploits_tracked += 1;

    ;; Update bridge status to EXPLOITED
    var (status, tvl, last_update, found) = get_bridge_status(bridge_address);
    if (found) {
        update_bridge_status(bridge_address, BRIDGE_STATUS_EXPLOITED, tvl - stolen_amount);
    }
}

(int, int, int, int) get_exploit_event(slice bridge_address, int exploit_timestamp) inline {
    ;; Returns (stolen_amount, monitoring_sources, reported_at, found)
    int bridge_hash = slice_hash(bridge_address);
    int event_key = (bridge_hash << 32) | exploit_timestamp;

    (slice exploit_slice, int found) = exploit_events.udict_get?(96, event_key);
    if (~ found) {
        return (0, 0, 0, 0);
    }

    slice es = exploit_slice~load_ref().begin_parse();
    es~load_msg_addr();  ;; Skip bridge_address
    int stolen_amount = es~load_coins();
    es~load_uint(128);   ;; Skip tx_hash_high
    es~load_uint(128);   ;; Skip tx_hash_low
    int monitoring_sources = es~load_uint(8);
    int reported_at = es~load_uint(32);

    return (stolen_amount, monitoring_sources, reported_at, -1);
}

;; Count number of monitoring sources (bits set)
int count_sources(int source_bitmap) inline {
    int count = 0;
    int i = 0;
    while (i < 8) {
        if (source_bitmap & (1 << i)) {
            count += 1;
        }
        i += 1;
    }
    return count;
}

;; ===== CLAIM VERIFICATION LOGIC =====

() verify_bridge_claim(
    slice sender,
    int query_id,
    int coverage_type,
    int stablecoin_id,
    cell evidence_cell
) impure {
    check_claims_processor(sender);

    ;; Parse evidence
    slice evidence = evidence_cell.begin_parse();
    int source_chain_id = evidence~load_uint(8);
    int dest_chain_id = evidence~load_uint(8);
    slice bridge_address = evidence~load_msg_addr();
    int tx_hash_high = evidence~load_uint(128);
    int tx_hash_low = evidence~load_uint(128);
    int exploit_timestamp = evidence~load_uint(32);
    int claimed_amount = evidence~load_coins();

    ;; Validation 1: Check bridge exists and is exploited
    var (bridge_status, tvl, last_update, bridge_found) = get_bridge_status(bridge_address);
    throw_unless(ERR_BRIDGE_NOT_FOUND, bridge_found);
    
    int bridge_is_exploited = (bridge_status == BRIDGE_STATUS_EXPLOITED) | (bridge_status == BRIDGE_STATUS_DRAINED);

    ;; Validation 2: Check exploit event exists
    var (stolen_amount, monitoring_sources, reported_at, exploit_found) = get_exploit_event(bridge_address, exploit_timestamp);
    throw_unless(ERR_EXPLOIT_NOT_FOUND, exploit_found);

    ;; Validation 3: Check claim is within valid time window (24 hours)
    int claim_delay = now() - exploit_timestamp;
    int timely_claim = claim_delay < MAX_CLAIM_DELAY;

    ;; Validation 4: Check monitoring source consensus
    int num_sources = count_sources(monitoring_sources);
    int sufficient_confirmation = num_sources >= MIN_MONITORING_SOURCES;

    ;; Validation 5: Check claimed amount matches reported amount (allow 5% tolerance)
    int amount_diff = 0;
    if (claimed_amount > stolen_amount) {
        amount_diff = claimed_amount - stolen_amount;
    } else {
        amount_diff = stolen_amount - claimed_amount;
    }
    int max_allowed_diff = muldiv(stolen_amount, 5, 100);  ;; 5% tolerance
    int amount_matches = amount_diff <= max_allowed_diff;

    ;; Final validation: all conditions must be true
    int is_valid = bridge_is_exploited & exploit_found & timely_claim & sufficient_confirmation & amount_matches;

    ;; Send verification result back to ClaimsProcessor
    cell response_body = begin_cell()
        .store_uint(OP_RECEIVE_VERIFICATION, 32)
        .store_uint(query_id, 64)
        .store_uint(is_valid, 1)
        .end_cell();

    cell response_msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(claims_processor_address)
        .store_coins(50000000)  ;; 0.05 TON for gas
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(response_body)
        .end_cell();

    send_raw_message(response_msg, 1);

    ;; Emit verification event
    emit_log(0xBD19E,  ;; "BRIDGE" shortened
        begin_cell()
            .store_uint(query_id, 64)
            .store_uint(is_valid, 1)
            .store_coins(claimed_amount)
            .store_uint(num_sources, 8)
            .end_cell().begin_parse());
}

;; ===== ADMIN FUNCTIONS =====

() set_claims_processor(slice sender, slice new_processor) impure {
    check_owner(sender);
    claims_processor_address = new_processor;
}

() set_keeper(slice sender, slice new_keeper) impure {
    check_owner(sender);
    keeper_address = new_keeper;
}

;; ===== MESSAGE HANDLER =====

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { return (); }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { return (); }  ;; Ignore bounced messages

    slice sender_address = cs~load_msg_addr();
    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == OP_VERIFY_CLAIM) {
        int query_id = in_msg_body~load_uint(64);
        int coverage_type = in_msg_body~load_uint(8);
        int stablecoin_id = in_msg_body~load_uint(8);
        cell evidence = in_msg_body~load_ref();
        verify_bridge_claim(sender_address, query_id, coverage_type, stablecoin_id, evidence);
    } elseif (op == OP_REPORT_EXPLOIT) {
        check_keeper(sender_address);
        slice bridge_address = in_msg_body~load_msg_addr();
        int exploit_timestamp = in_msg_body~load_uint(32);
        int stolen_amount = in_msg_body~load_coins();
        int tx_hash_high = in_msg_body~load_uint(128);
        int tx_hash_low = in_msg_body~load_uint(128);
        int monitoring_sources = in_msg_body~load_uint(8);
        report_exploit(bridge_address, exploit_timestamp, stolen_amount, tx_hash_high, tx_hash_low, monitoring_sources);
    } elseif (op == OP_UPDATE_BRIDGE_STATUS) {
        check_keeper(sender_address);
        slice bridge_address = in_msg_body~load_msg_addr();
        int status = in_msg_body~load_uint(8);
        int current_tvl = in_msg_body~load_coins();
        update_bridge_status(bridge_address, status, current_tvl);
    } elseif (op == OP_SET_CLAIMS_PROCESSOR) {
        slice new_processor = in_msg_body~load_msg_addr();
        set_claims_processor(sender_address, new_processor);
    } elseif (op == OP_SET_KEEPER) {
        slice new_keeper = in_msg_body~load_msg_addr();
        set_keeper(sender_address, new_keeper);
    } else {
        throw(0xffff);
    }

    save_data();
}

;; ===== GETTERS =====

slice get_owner() method_id {
    load_data();
    return owner_address;
}

slice get_claims_processor() method_id {
    load_data();
    return claims_processor_address;
}

slice get_keeper() method_id {
    load_data();
    return keeper_address;
}

int get_total_exploits() method_id {
    load_data();
    return total_exploits_tracked;
}

(int, int, int, int) get_bridge_info(slice bridge_address) method_id {
    load_data();
    return get_bridge_status(bridge_address);
}

(int, int, int, int) get_exploit_info(slice bridge_address, int timestamp) method_id {
    load_data();
    return get_exploit_event(bridge_address, timestamp);
}
