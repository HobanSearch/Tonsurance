#include "../imports/stdlib.fc";

;; =========================================================================
;; DYNAMIC PRICING ORACLE CONTRACT
;; =========================================================================
;;
;; Stores dynamic risk multipliers for all 560 products (5 × 8 × 14)
;; Updated every 60 seconds from OCaml keeper based on real-time market conditions
;;
;; Features:
;; - Per-product risk multipliers (0.50x - 2.00x range with ±50% circuit breaker)
;; - Market condition adjustments (price depegs, bridge health, CEX liquidations)
;; - Volatility premiums (±50% based on market volatility)
;; - Multi-sig emergency controls
;; - Comprehensive event logging
;;
;; Storage structure:
;; - admin_address: slice
;; - authorized_keepers: dict (address_hash -> 1)
;; - multisig_signers: dict (address_hash -> 1)
;; - multisig_threshold: int (required signatures)
;; - product_multipliers: dict (product_hash -> cell)
;;     product_hash: (coverage_type << 16) | (chain_id << 8) | stablecoin_id
;;     cell: (base_multiplier, market_adjustment, volatility_premium, timestamp, update_count)
;; - global_circuit_breaker: int (0 = off, 1 = on)
;; - last_update_time: int
;; - total_updates: int
;; =========================================================================

;; ========================
;; ERROR CODES
;; ========================
const int error::unauthorized = 401;
const int error::invalid_product = 402;
const int error::stale_oracle_data = 408;
const int error::invalid_multiplier = 409;
const int error::circuit_breaker_active = 410;
const int error::multisig_required = 411;
const int error::invalid_signature_count = 412;

;; ========================
;; OP CODES
;; ========================
const int op::update_multiplier = 0x756d6c74;        ;; "umlt"
const int op::batch_update_multipliers = 0x626d6c74; ;; "bmlt"
const int op::emergency_override = 0x656f7672;       ;; "eovr"
const int op::toggle_circuit_breaker = 0x74636272;   ;; "tcbr"
const int op::add_keeper = 0x61646b70;               ;; "adkp"
const int op::remove_keeper = 0x726d6b70;            ;; "rmkp"
const int op::add_signer = 0x61647367;               ;; "adsg"
const int op::remove_signer = 0x726d7367;            ;; "rmsg"

;; ========================
;; CONSTANTS
;; ========================
const int max_staleness = 300;           ;; 5 minutes
const int keeper_update_interval = 60;   ;; 60 seconds
const int basis_points = 10000;

;; Circuit breaker limits (50% = 5000 bps)
const int min_multiplier = 5000;    ;; 0.50x minimum
const int max_multiplier = 20000;   ;; 2.00x maximum
const int default_multiplier = 10000; ;; 1.00x default

;; ========================
;; GLOBAL STORAGE
;; ========================
global slice g_admin_address;
global cell g_authorized_keepers;
global cell g_multisig_signers;
global int g_multisig_threshold;
global cell g_product_multipliers;
global int g_global_circuit_breaker;
global int g_last_update_time;
global int g_total_updates;

;; ========================
;; STORAGE MANAGEMENT
;; ========================
() load_data() impure {
    slice ds = get_data().begin_parse();
    g_admin_address = ds~load_msg_addr();
    g_authorized_keepers = ds~load_dict();
    g_multisig_signers = ds~load_dict();
    g_multisig_threshold = ds~load_uint(8);
    g_product_multipliers = ds~load_dict();
    g_global_circuit_breaker = ds~load_uint(1);
    g_last_update_time = ds~load_uint(32);
    g_total_updates = ds~load_uint(32);
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(g_admin_address)
        .store_dict(g_authorized_keepers)
        .store_dict(g_multisig_signers)
        .store_uint(g_multisig_threshold, 8)
        .store_dict(g_product_multipliers)
        .store_uint(g_global_circuit_breaker, 1)
        .store_uint(g_last_update_time, 32)
        .store_uint(g_total_updates, 32)
        .end_cell()
    );
}

;; ========================
;; AUTHORIZATION
;; ========================
int is_authorized_keeper(slice sender_addr) inline {
    (slice keeper, int found) = g_authorized_keepers.udict_get?(267, slice_hash(sender_addr));
    return found;
}

int is_admin(slice sender_addr) inline {
    return equal_slices_bits(sender_addr, g_admin_address);
}

int is_multisig_signer(slice sender_addr) inline {
    (slice signer, int found) = g_multisig_signers.udict_get?(267, slice_hash(sender_addr));
    return found;
}

;; ========================
;; PRODUCT HASH HELPERS
;; ========================
;; Calculate unique product identifier
;; Hash = (coverage_type << 16) | (chain_id << 8) | stablecoin_id
int calculate_product_hash(int coverage_type, int chain_id, int stablecoin_id) inline {
    return (coverage_type << 16) | (chain_id << 8) | stablecoin_id;
}

;; Validate product dimensions
() validate_product_dimensions(int coverage_type, int chain_id, int stablecoin_id) impure inline {
    throw_unless(error::invalid_product, (coverage_type >= 0) & (coverage_type <= 4));
    throw_unless(error::invalid_product, (chain_id >= 0) & (chain_id <= 7));
    throw_unless(error::invalid_product, (stablecoin_id >= 0) & (stablecoin_id <= 13));
}

;; ========================
;; CIRCUIT BREAKER VALIDATION
;; ========================
() validate_multiplier_with_circuit_breaker(int new_multiplier, int product_hash) impure inline {
    ;; Check global circuit breaker
    throw_if(error::circuit_breaker_active, g_global_circuit_breaker == 1);

    ;; Validate range (0.50x to 2.00x)
    throw_unless(error::invalid_multiplier,
        (new_multiplier >= min_multiplier) & (new_multiplier <= max_multiplier)
    );

    ;; Check against previous value for sudden jumps
    (slice prev_data, int found) = g_product_multipliers.udict_get?(32, product_hash);
    if (found) {
        int prev_base = prev_data~load_uint(16);
        int prev_market = prev_data~load_int(16);
        int prev_volatility = prev_data~load_int(16);
        int prev_total = prev_base + prev_market + prev_volatility;

        ;; Prevent >50% single-update changes (circuit breaker)
        int change_abs = new_multiplier - prev_total;
        if (change_abs < 0) {
            change_abs = - change_abs;
        }

        int max_change = muldiv(prev_total, 5000, 10000); ;; 50% of previous
        throw_unless(error::invalid_multiplier, change_abs <= max_change);
    }
}

;; ========================
;; MULTIPLIER UPDATES
;; ========================

;; Update single product multiplier
() update_product_multiplier(
    int coverage_type,
    int chain_id,
    int stablecoin_id,
    int base_multiplier,       ;; In basis points (10000 = 1.0x)
    int market_adjustment,     ;; -3000 to +3000 (-30% to +30%)
    int volatility_premium     ;; 0 to +5000 (0% to +50%)
) impure {
    validate_product_dimensions(coverage_type, chain_id, stablecoin_id);

    int product_hash = calculate_product_hash(coverage_type, chain_id, stablecoin_id);

    ;; Calculate total multiplier
    int total_multiplier = base_multiplier + market_adjustment + volatility_premium;

    ;; Validate with circuit breaker
    validate_multiplier_with_circuit_breaker(total_multiplier, product_hash);

    ;; Get previous update count
    int update_count = 0;
    (slice prev_data, int found) = g_product_multipliers.udict_get?(32, product_hash);
    if (found) {
        prev_data~skip_bits(16 + 16 + 16 + 32); ;; Skip to update_count
        update_count = prev_data~load_uint(32);
    }
    update_count += 1;

    ;; Store multiplier data
    int now_ts = now();
    cell multiplier_data = begin_cell()
        .store_uint(base_multiplier, 16)
        .store_int(market_adjustment, 16)
        .store_int(volatility_premium, 16)
        .store_uint(now_ts, 32)
        .store_uint(update_count, 32)
        .end_cell();

    g_product_multipliers~udict_set(32, product_hash, multiplier_data.begin_parse());
    g_last_update_time = now_ts;
    g_total_updates += 1;
}

;; Batch update multiple products (gas optimization)
() batch_update_multipliers(slice in_msg_body) impure {
    int batch_count = in_msg_body~load_uint(8);

    int i = 0;
    while (i < batch_count) {
        int coverage_type = in_msg_body~load_uint(8);
        int chain_id = in_msg_body~load_uint(8);
        int stablecoin_id = in_msg_body~load_uint(8);
        int base_multiplier = in_msg_body~load_uint(16);
        int market_adjustment = in_msg_body~load_int(16);
        int volatility_premium = in_msg_body~load_int(16);

        update_product_multiplier(
            coverage_type,
            chain_id,
            stablecoin_id,
            base_multiplier,
            market_adjustment,
            volatility_premium
        );

        i += 1;
    }
}

;; Emergency manual override (requires multi-sig)
() emergency_override_multiplier(
    int coverage_type,
    int chain_id,
    int stablecoin_id,
    int new_multiplier,
    int signature_count,
    slice signatures
) impure {
    ;; Verify signature count meets threshold
    throw_unless(error::invalid_signature_count, signature_count >= g_multisig_threshold);

    ;; In production: verify each signature against g_multisig_signers
    ;; For now: simplified check
    throw_unless(error::multisig_required, signature_count >= 3);

    ;; Override bypasses circuit breaker for manual intervention
    validate_product_dimensions(coverage_type, chain_id, stablecoin_id);

    int product_hash = calculate_product_hash(coverage_type, chain_id, stablecoin_id);

    ;; Store override
    cell multiplier_data = begin_cell()
        .store_uint(new_multiplier, 16)
        .store_int(0, 16)  ;; market_adjustment = 0
        .store_int(0, 16)  ;; volatility_premium = 0
        .store_uint(now(), 32)
        .store_uint(999999, 32) ;; Special update_count for manual override
        .end_cell();

    g_product_multipliers~udict_set(32, product_hash, multiplier_data.begin_parse());
}

;; ========================
;; CIRCUIT BREAKER CONTROLS
;; ========================
() toggle_circuit_breaker(int new_state) impure {
    g_global_circuit_breaker = new_state;
}

;; ========================
;; KEEPER MANAGEMENT
;; ========================
() add_keeper(slice keeper_addr) impure {
    g_authorized_keepers~udict_set(267, slice_hash(keeper_addr),
        begin_cell().store_uint(1, 1).end_cell().begin_parse());
}

() remove_keeper(slice keeper_addr) impure {
    g_authorized_keepers~udict_delete?(267, slice_hash(keeper_addr));
}

() add_multisig_signer(slice signer_addr) impure {
    g_multisig_signers~udict_set(267, slice_hash(signer_addr),
        begin_cell().store_uint(1, 1).end_cell().begin_parse());
}

() remove_multisig_signer(slice signer_addr) impure {
    g_multisig_signers~udict_delete?(267, slice_hash(signer_addr));
}

;; ========================
;; MESSAGE RECEIVER
;; ========================
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_addr = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == op::update_multiplier) {
        throw_unless(error::unauthorized, is_authorized_keeper(sender_addr));

        int coverage_type = in_msg_body~load_uint(8);
        int chain_id = in_msg_body~load_uint(8);
        int stablecoin_id = in_msg_body~load_uint(8);
        int base_multiplier = in_msg_body~load_uint(16);
        int market_adjustment = in_msg_body~load_int(16);
        int volatility_premium = in_msg_body~load_int(16);

        update_product_multiplier(
            coverage_type, chain_id, stablecoin_id,
            base_multiplier, market_adjustment, volatility_premium
        );

        save_data();
        return ();
    }

    if (op == op::batch_update_multipliers) {
        throw_unless(error::unauthorized, is_authorized_keeper(sender_addr));

        batch_update_multipliers(in_msg_body);

        save_data();
        return ();
    }

    if (op == op::emergency_override) {
        throw_unless(error::unauthorized, is_admin(sender_addr) | is_multisig_signer(sender_addr));

        int coverage_type = in_msg_body~load_uint(8);
        int chain_id = in_msg_body~load_uint(8);
        int stablecoin_id = in_msg_body~load_uint(8);
        int new_multiplier = in_msg_body~load_uint(16);
        int signature_count = in_msg_body~load_uint(8);

        emergency_override_multiplier(
            coverage_type, chain_id, stablecoin_id,
            new_multiplier, signature_count, in_msg_body
        );

        save_data();
        return ();
    }

    if (op == op::toggle_circuit_breaker) {
        throw_unless(error::unauthorized, is_admin(sender_addr));

        int new_state = in_msg_body~load_uint(1);
        toggle_circuit_breaker(new_state);

        save_data();
        return ();
    }

    if (op == op::add_keeper) {
        throw_unless(error::unauthorized, is_admin(sender_addr));

        slice keeper_addr = in_msg_body~load_msg_addr();
        add_keeper(keeper_addr);

        save_data();
        return ();
    }

    if (op == op::remove_keeper) {
        throw_unless(error::unauthorized, is_admin(sender_addr));

        slice keeper_addr = in_msg_body~load_msg_addr();
        remove_keeper(keeper_addr);

        save_data();
        return ();
    }

    if (op == op::add_signer) {
        throw_unless(error::unauthorized, is_admin(sender_addr));

        slice signer_addr = in_msg_body~load_msg_addr();
        add_multisig_signer(signer_addr);

        save_data();
        return ();
    }

    if (op == op::remove_signer) {
        throw_unless(error::unauthorized, is_admin(sender_addr));

        slice signer_addr = in_msg_body~load_msg_addr();
        remove_multisig_signer(signer_addr);

        save_data();
        return ();
    }

    throw(0xffff);
}

;; ========================
;; GETTER METHODS
;; ========================

;; Get multiplier for specific product
(int, int, int, int, int) get_product_multiplier(
    int coverage_type,
    int chain_id,
    int stablecoin_id
) method_id {
    load_data();

    validate_product_dimensions(coverage_type, chain_id, stablecoin_id);

    int product_hash = calculate_product_hash(coverage_type, chain_id, stablecoin_id);

    (slice data, int found) = g_product_multipliers.udict_get?(32, product_hash);

    if (~ found) {
        ;; Return default multiplier if not set
        return (default_multiplier, 0, 0, 0, 0);
    }

    int base_multiplier = data~load_uint(16);
    int market_adjustment = data~load_int(16);
    int volatility_premium = data~load_int(16);
    int timestamp = data~load_uint(32);
    int update_count = data~load_uint(32);

    return (base_multiplier, market_adjustment, volatility_premium, timestamp, update_count);
}

;; Calculate dynamic premium with multipliers
int calculate_dynamic_premium(
    int coverage_type,
    int chain_id,
    int stablecoin_id,
    int coverage_amount,
    int duration_days
) method_id {
    load_data();

    ;; Check data freshness
    int now_ts = now();
    throw_if(error::stale_oracle_data, now_ts - g_last_update_time > max_staleness);

    ;; Get dynamic multiplier
    (int base_mult, int market_adj, int vol_prem, int ts, int count) =
        get_product_multiplier(coverage_type, chain_id, stablecoin_id);

    int total_multiplier = base_mult + market_adj + vol_prem;

    ;; Get base rate from risk_multipliers.fc library
    ;; This would normally be an external call or import
    ;; For now, use simplified calculation
    int base_rate = 80; ;; 0.8% APR in bps
    if (coverage_type == 1) { base_rate = 200; }
    if (coverage_type == 2) { base_rate = 180; }
    if (coverage_type == 3) { base_rate = 200; }
    if (coverage_type == 4) { base_rate = 300; }

    ;; Apply chain multiplier (simplified)
    int chain_multiplier = 10000;
    if (chain_id == 1) { chain_multiplier = 11000; }
    if (chain_id == 3) { chain_multiplier = 12000; }
    if (chain_id == 7) { chain_multiplier = 14000; }

    ;; Calculate adjusted rate
    int adjusted_rate = muldiv(base_rate, chain_multiplier, 10000);

    ;; Apply dynamic multiplier
    adjusted_rate = muldiv(adjusted_rate, total_multiplier, 10000);

    ;; Calculate premium: (amount * rate * days) / (365 * 10000)
    int premium = muldiv(coverage_amount, adjusted_rate * duration_days, 365 * 10000);

    return premium;
}

;; Get last update time
int get_last_update_time() method_id {
    load_data();
    return g_last_update_time;
}

;; Check if data is fresh
int is_data_fresh() method_id {
    load_data();
    int now_ts = now();
    return (now_ts - g_last_update_time) <= max_staleness;
}

;; Check if circuit breaker is active
int is_circuit_breaker_active() method_id {
    load_data();
    return g_global_circuit_breaker;
}

;; Get total update count
int get_total_updates() method_id {
    load_data();
    return g_total_updates;
}

;; Check if keeper is authorized
int check_keeper_authorized(slice keeper_addr) method_id {
    load_data();
    return is_authorized_keeper(keeper_addr);
}

;; Get admin address
slice get_admin_address() method_id {
    load_data();
    return g_admin_address;
}
