#include "../imports/stdlib.fc";

;; Storage structure
;; - admin_address: slice
;; - factory_address: slice
;; - authorized_keepers: dict (slice -> bool)
;; - hedge_positions: dict (int -> cell)
;;     key: policy_id
;;     value: cell containing hedge position data
;; - liquidations: dict (int -> cell)
;;     key: policy_id
;;     value: cell containing liquidation status

;; Error codes
const int error::unauthorized = 401;
const int error::policy_not_found = 404;
const int error::invalid_venue = 405;
const int error::invalid_status = 406;

;; Op codes
const int op::register_hedge = 0x72656768;      ;; "regh"
const int op::liquidate_hedges = 0x6c697164;    ;; "liqd"
const int op::report_liquidation = 0x72706c64;  ;; "rpld"
const int op::update_factory = 0x75706466;      ;; "updf"
const int op::add_keeper = 0x61646b70;          ;; "adkp"
const int op::remove_keeper = 0x726d6b70;       ;; "rmkp"

;; Venue codes
const int venue::polymarket = 1;
const int venue::perpetuals = 2;
const int venue::allianz = 3;

;; Status codes
const int status::pending = 0;
const int status::filled = 1;
const int status::failed = 2;
const int status::liquidating = 3;
const int status::liquidated = 4;

;; Storage management
global slice g_admin_address;
global slice g_factory_address;
global cell g_authorized_keepers;
global cell g_hedge_positions;
global cell g_liquidations;

() load_data() impure {
    slice ds = get_data().begin_parse();
    g_admin_address = ds~load_msg_addr();
    g_factory_address = ds~load_msg_addr();
    g_authorized_keepers = ds~load_dict();
    g_hedge_positions = ds~load_dict();
    g_liquidations = ds~load_dict();
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(g_admin_address)
        .store_slice(g_factory_address)
        .store_dict(g_authorized_keepers)
        .store_dict(g_hedge_positions)
        .store_dict(g_liquidations)
        .end_cell()
    );
}

;; Check if sender is authorized keeper
int is_authorized_keeper(slice sender_addr) inline {
    (slice keeper, int found) = g_authorized_keepers.udict_get?(267, slice_hash(sender_addr));
    return found;
}

;; Check if sender is admin
int is_admin(slice sender_addr) inline {
    return equal_slices_bits(sender_addr, g_admin_address);
}

;; Check if sender is factory
int is_factory(slice sender_addr) inline {
    return equal_slices_bits(sender_addr, g_factory_address);
}

;; Validate venue
() validate_venue(int venue) impure inline {
    throw_unless(error::invalid_venue,
        (venue == venue::polymarket) |
        (venue == venue::perpetuals) |
        (venue == venue::allianz)
    );
}

;; Register a hedge position
() register_hedge(
    int policy_id,
    int venue_id,
    int amount,
    slice external_id,
    int hedge_status
) impure {
    validate_venue(venue_id);

    ;; Get existing position or create new one
    (slice position_data, int found) = g_hedge_positions.udict_get?(64, policy_id);

    cell position = begin_cell().end_cell();  ;; Initialize with empty cell
    if (found) {
        position = position_data~load_ref();
    } else {
        ;; Initialize new position
        position = begin_cell()
            .store_uint(0, 8)   ;; polymarket_status
            .store_coins(0)     ;; polymarket_amount
            .store_uint(0, 256) ;; polymarket_external_id (hash)
            .store_uint(0, 8)   ;; perp_status
            .store_coins(0)     ;; perp_amount
            .store_uint(0, 256) ;; perp_external_id
            .store_uint(0, 8)   ;; allianz_status
            .store_coins(0)     ;; allianz_amount
            .store_uint(0, 256) ;; allianz_external_id
            .end_cell();
    }

    ;; Parse existing position
    slice ps = position.begin_parse();

    int poly_status = ps~load_uint(8);
    int poly_amount = ps~load_coins();
    int poly_external_id = ps~load_uint(256);
    int perp_status = ps~load_uint(8);
    int perp_amount = ps~load_coins();
    int perp_external_id = ps~load_uint(256);
    int allianz_status = ps~load_uint(8);
    int allianz_amount = ps~load_coins();
    int allianz_external_id = ps~load_uint(256);

    ;; Update relevant venue
    if (venue_id == venue::polymarket) {
        poly_status = hedge_status;
        poly_amount = amount;
        poly_external_id = slice_hash(external_id);
    }
    if (venue_id == venue::perpetuals) {
        perp_status = hedge_status;
        perp_amount = amount;
        perp_external_id = slice_hash(external_id);
    }
    if (venue_id == venue::allianz) {
        allianz_status = hedge_status;
        allianz_amount = amount;
        allianz_external_id = slice_hash(external_id);
    }

    ;; Store updated position
    cell updated_position = begin_cell()
        .store_uint(poly_status, 8)
        .store_coins(poly_amount)
        .store_uint(poly_external_id, 256)
        .store_uint(perp_status, 8)
        .store_coins(perp_amount)
        .store_uint(perp_external_id, 256)
        .store_uint(allianz_status, 8)
        .store_coins(allianz_amount)
        .store_uint(allianz_external_id, 256)
        .end_cell();

    g_hedge_positions~udict_set(64, policy_id, begin_cell().store_ref(updated_position).end_cell().begin_parse());
}

;; Send message to keeper
() send_keeper_message(slice keeper_addr, int op, int policy_id, int venue_id, int amount) impure {
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(keeper_addr)
        .store_coins(100000000)  ;; 0.1 TON for gas
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(op, 32)
        .store_uint(policy_id, 64)
        .store_uint(venue_id, 8)
        .store_coins(amount)
        .end_cell();
    send_raw_message(msg, 1);
}

;; Liquidate hedges for a policy
() liquidate_hedges(int policy_id, slice polymarket_keeper, slice perp_keeper, slice allianz_keeper) impure {
    ;; Get hedge position
    (slice position_data, int found) = g_hedge_positions.udict_get?(64, policy_id);
    throw_unless(error::policy_not_found, found);

    cell position = position_data~load_ref();
    slice ps = position.begin_parse();

    int poly_status = ps~load_uint(8);
    int poly_amount = ps~load_coins();
    ps~skip_bits(256);  ;; Skip external_id
    int perp_status = ps~load_uint(8);
    int perp_amount = ps~load_coins();
    ps~skip_bits(256);
    int allianz_status = ps~load_uint(8);
    int allianz_amount = ps~load_coins();

    ;; Send liquidation messages to keepers
    if (poly_status == status::filled) {
        send_keeper_message(polymarket_keeper, op::liquidate_hedges, policy_id, venue::polymarket, poly_amount);
    }
    if (perp_status == status::filled) {
        send_keeper_message(perp_keeper, op::liquidate_hedges, policy_id, venue::perpetuals, perp_amount);
    }
    if (allianz_status == status::filled) {
        send_keeper_message(allianz_keeper, op::liquidate_hedges, policy_id, venue::allianz, allianz_amount);
    }

    ;; Create liquidation record
    cell liquidation = begin_cell()
        .store_uint(now(), 32)           ;; timestamp
        .store_uint(status::liquidating, 8)
        .store_coins(0)                  ;; poly_proceeds
        .store_coins(0)                  ;; perp_proceeds
        .store_coins(0)                  ;; allianz_proceeds
        .store_uint(0, 8)                ;; poly_complete
        .store_uint(0, 8)                ;; perp_complete
        .store_uint(0, 8)                ;; allianz_complete
        .end_cell();

    g_liquidations~udict_set(64, policy_id, liquidation.begin_parse());
}

;; Report liquidation proceeds
() report_liquidation(int policy_id, int venue_id, int proceeds, slice reserve_vault) impure {
    validate_venue(venue_id);

    ;; Get liquidation record
    (slice liq_data, int found) = g_liquidations.udict_get?(64, policy_id);
    throw_unless(error::policy_not_found, found);

    int timestamp = liq_data~load_uint(32);
    int liq_status = liq_data~load_uint(8);
    int poly_proceeds = liq_data~load_coins();
    int perp_proceeds = liq_data~load_coins();
    int allianz_proceeds = liq_data~load_coins();
    int poly_complete = liq_data~load_uint(8);
    int perp_complete = liq_data~load_uint(8);
    int allianz_complete = liq_data~load_uint(8);

    ;; Update proceeds for venue
    if (venue_id == venue::polymarket) {
        poly_proceeds = proceeds;
        poly_complete = 1;
    }
    if (venue_id == venue::perpetuals) {
        perp_proceeds = proceeds;
        perp_complete = 1;
    }
    if (venue_id == venue::allianz) {
        allianz_proceeds = proceeds;
        allianz_complete = 1;
    }

    ;; Check if all liquidations complete
    int all_complete = poly_complete & perp_complete & allianz_complete;

    if (all_complete) {
        liq_status = status::liquidated;

        ;; Calculate total proceeds and refill reserve vault
        int total_proceeds = poly_proceeds + perp_proceeds + allianz_proceeds;

        ;; Send proceeds to reserve vault
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(reserve_vault)
            .store_coins(total_proceeds)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0x72656669, 32)  ;; "refi" - refill op
            .store_uint(policy_id, 64)
            .end_cell();
        send_raw_message(msg, 1);
    }

    ;; Update liquidation record
    cell updated_liquidation = begin_cell()
        .store_uint(timestamp, 32)
        .store_uint(liq_status, 8)
        .store_coins(poly_proceeds)
        .store_coins(perp_proceeds)
        .store_coins(allianz_proceeds)
        .store_uint(poly_complete, 8)
        .store_uint(perp_complete, 8)
        .store_uint(allianz_complete, 8)
        .end_cell();

    g_liquidations~udict_set(64, policy_id, updated_liquidation.begin_parse());
}

;; Add authorized keeper
() add_keeper(slice keeper_addr) impure {
    g_authorized_keepers~udict_set(267, slice_hash(keeper_addr), begin_cell().store_uint(1, 1).end_cell().begin_parse());
}

;; Remove authorized keeper
() remove_keeper(slice keeper_addr) impure {
    g_authorized_keepers~udict_delete?(267, slice_hash(keeper_addr));
}

;; Main receiver
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();  ;; Ignore empty messages
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_addr = cs~load_msg_addr();

    load_data();

    int op = in_msg_body~load_uint(32);

    if (op == op::register_hedge) {
        throw_unless(error::unauthorized, is_authorized_keeper(sender_addr));

        int policy_id = in_msg_body~load_uint(64);
        int venue_id = in_msg_body~load_uint(8);
        int amount = in_msg_body~load_coins();
        slice external_id = in_msg_body~load_bits(256);
        int hedge_status = in_msg_body~load_uint(8);

        register_hedge(policy_id, venue_id, amount, external_id, hedge_status);

        save_data();
        return ();
    }

    if (op == op::liquidate_hedges) {
        throw_unless(error::unauthorized, is_factory(sender_addr));

        int policy_id = in_msg_body~load_uint(64);
        slice polymarket_keeper = in_msg_body~load_msg_addr();
        slice perp_keeper = in_msg_body~load_msg_addr();
        slice allianz_keeper = in_msg_body~load_msg_addr();

        liquidate_hedges(policy_id, polymarket_keeper, perp_keeper, allianz_keeper);

        save_data();
        return ();
    }

    if (op == op::report_liquidation) {
        throw_unless(error::unauthorized, is_authorized_keeper(sender_addr));

        int policy_id = in_msg_body~load_uint(64);
        int venue_id = in_msg_body~load_uint(8);
        int proceeds = in_msg_body~load_coins();
        slice reserve_vault = in_msg_body~load_msg_addr();

        report_liquidation(policy_id, venue_id, proceeds, reserve_vault);

        save_data();
        return ();
    }

    if (op == op::update_factory) {
        throw_unless(error::unauthorized, is_admin(sender_addr));

        g_factory_address = in_msg_body~load_msg_addr();

        save_data();
        return ();
    }

    if (op == op::add_keeper) {
        throw_unless(error::unauthorized, is_admin(sender_addr));

        slice keeper_addr = in_msg_body~load_msg_addr();
        add_keeper(keeper_addr);

        save_data();
        return ();
    }

    if (op == op::remove_keeper) {
        throw_unless(error::unauthorized, is_admin(sender_addr));

        slice keeper_addr = in_msg_body~load_msg_addr();
        remove_keeper(keeper_addr);

        save_data();
        return ();
    }

    throw(0xffff);  ;; Unknown operation
}

;; Get hedge position for a policy
(int, int, int, int, int, int, int, int, int) get_hedge_position(int policy_id) method_id {
    load_data();

    (slice position_data, int found) = g_hedge_positions.udict_get?(64, policy_id);
    throw_unless(error::policy_not_found, found);

    cell position = position_data~load_ref();
    slice ps = position.begin_parse();

    int poly_status = ps~load_uint(8);
    int poly_amount = ps~load_coins();
    ps~skip_bits(256);  ;; Skip external_id
    int perp_status = ps~load_uint(8);
    int perp_amount = ps~load_coins();
    ps~skip_bits(256);
    int allianz_status = ps~load_uint(8);
    int allianz_amount = ps~load_coins();
    ps~skip_bits(256);

    return (
        poly_status,
        poly_amount,
        perp_status,
        perp_amount,
        allianz_status,
        allianz_amount,
        0,  ;; reserved
        0,  ;; reserved
        0   ;; reserved
    );
}

;; Get liquidation status for a policy
(int, int, int, int, int) get_liquidation_status(int policy_id) method_id {
    load_data();

    (slice liq_data, int found) = g_liquidations.udict_get?(64, policy_id);
    throw_unless(error::policy_not_found, found);

    int timestamp = liq_data~load_uint(32);
    int liq_status = liq_data~load_uint(8);
    int poly_proceeds = liq_data~load_coins();
    int perp_proceeds = liq_data~load_coins();
    int allianz_proceeds = liq_data~load_coins();

    return (timestamp, liq_status, poly_proceeds, perp_proceeds, allianz_proceeds);
}

;; Get total proceeds from liquidation
int get_total_liquidation_proceeds(int policy_id) method_id {
    load_data();

    (slice liq_data, int found) = g_liquidations.udict_get?(64, policy_id);
    throw_unless(error::policy_not_found, found);

    liq_data~skip_bits(32 + 8);  ;; Skip timestamp and status
    int poly_proceeds = liq_data~load_coins();
    int perp_proceeds = liq_data~load_coins();
    int allianz_proceeds = liq_data~load_coins();

    return poly_proceeds + perp_proceeds + allianz_proceeds;
}

;; Check if keeper is authorized
int check_keeper_authorized(slice keeper_addr) method_id {
    load_data();
    return is_authorized_keeper(keeper_addr);
}

;; Get admin address
slice get_admin_address() method_id {
    load_data();
    return g_admin_address;
}

;; Get factory address
slice get_factory_address() method_id {
    load_data();
    return g_factory_address;
}
