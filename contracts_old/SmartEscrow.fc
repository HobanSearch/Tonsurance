;; SmartEscrow.fc - Conditional Payment with Insurance Protection
;;
;; Combines escrow functionality with depeg insurance for powerful use cases:
;; - Business transactions protected against stablecoin risk
;; - Milestone-based payments with safety net
;; - Cross-border payments with guaranteed value
;; - Freelance contracts with depeg coverage
;; - Supply chain payments with protection
;;
;; How it works:
;; 1. Buyer deposits funds + insurance premium
;; 2. Funds held in escrow until conditions met
;; 3. If depeg occurs, insurance pays out
;; 4. If conditions met, funds released to seller
;; 5. If cancelled, funds returned (minus premium)
;;
;; Key Features:
;; - Multi-party escrow (buyer, seller, arbiter)
;; - Milestone-based release
;; - Automatic depeg insurance
;; - Dispute resolution
;; - Time-locked release
;; - Partial releases

#include "imports/stdlib.fc";

;; Storage layout
;; escrow_count:uint64
;; policy_manager_address:MsgAddress
;; beneficiary_policy_address:MsgAddress
;; admin_address:MsgAddress

global int storage::escrow_count;
global slice storage::policy_manager_address;
global slice storage::beneficiary_policy_address;
global slice storage::admin_address;

;; Escrow structure
;; escrow_id:uint64
;; buyer:MsgAddress
;; seller:MsgAddress
;; arbiter:MsgAddress (optional - can be null)
;; escrow_amount:Coins
;; insurance_premium:Coins
;; insurance_policy_id:uint64 (from BeneficiaryPolicy)
;; trigger_price:uint32 (for insurance)
;; floor_price:uint32
;; release_conditions:uint8 (0=manual, 1=time-based, 2=oracle-based, 3=milestone)
;; release_timestamp:uint32 (for time-based)
;; milestone_count:uint8
;; milestones_completed:uint8
;; status:uint8
;; created_time:uint32
;; expiry_time:uint32
;; dispute_raised:bool
;; partial_releases_enabled:bool

const int STATUS_PENDING = 0;        ;; Awaiting conditions
const int STATUS_ACTIVE = 1;         ;; Conditions being evaluated
const int STATUS_RELEASED = 2;       ;; Funds released to seller
const int STATUS_DISPUTED = 3;       ;; Dispute raised
const int STATUS_RESOLVED = 4;       ;; Dispute resolved
const int STATUS_CANCELLED = 5;      ;; Cancelled by buyer
const int STATUS_EXPIRED = 6;        ;; Expired without release
const int STATUS_INSURED_PAYOUT = 7; ;; Insurance paid out due to depeg

const int RELEASE_MANUAL = 0;        ;; Buyer manually releases
const int RELEASE_TIME_BASED = 1;    ;; Auto-release after timestamp
const int RELEASE_ORACLE_BASED = 2;  ;; Oracle confirms condition
const int RELEASE_MILESTONE = 3;     ;; N of M milestones completed

const int OP_CREATE_ESCROW = 0x40;
const int OP_RELEASE_FUNDS = 0x41;
const int OP_CANCEL_ESCROW = 0x42;
const int OP_RAISE_DISPUTE = 0x43;
const int OP_RESOLVE_DISPUTE = 0x44;
const int OP_COMPLETE_MILESTONE = 0x45;
const int OP_PARTIAL_RELEASE = 0x46;
const int OP_EXTEND_EXPIRY = 0x47;

;; Load storage
() load_data() impure {
    var ds = get_data().begin_parse();

    storage::escrow_count = ds~load_uint(64);
    storage::policy_manager_address = ds~load_msg_addr();
    storage::beneficiary_policy_address = ds~load_msg_addr();
    storage::admin_address = ds~load_msg_addr();

    ds.end_parse();
}

;; Save storage
() save_data() impure {
    set_data(
        begin_cell()
            .store_uint(storage::escrow_count, 64)
            .store_slice(storage::policy_manager_address)
            .store_slice(storage::beneficiary_policy_address)
            .store_slice(storage::admin_address)
        .end_cell()
    );
}

;; Load escrow
(int, slice, slice, slice, int, int, int, int, int, int, int, int, int, int, int, int, int, int) load_escrow(int escrow_id) {
    var escrow_cell = get_data_from_key(escrow_id);

    if (cell_null?(escrow_cell)) {
        return (0, null(), null(), null(), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }

    var es = escrow_cell.begin_parse();

    int escrow_id = es~load_uint(64);
    slice buyer = es~load_msg_addr();
    slice seller = es~load_msg_addr();
    slice arbiter = es~load_msg_addr();
    int escrow_amount = es~load_coins();
    int insurance_premium = es~load_coins();
    int insurance_policy_id = es~load_uint(64);
    int trigger_price = es~load_uint(32);
    int floor_price = es~load_uint(32);
    int release_conditions = es~load_uint(8);
    int release_timestamp = es~load_uint(32);
    int milestone_count = es~load_uint(8);
    int milestones_completed = es~load_uint(8);
    int status = es~load_uint(8);
    int created_time = es~load_uint(32);
    int expiry_time = es~load_uint(32);
    int dispute_raised = es~load_uint(1);
    int partial_releases_enabled = es~load_uint(1);

    es.end_parse();

    return (escrow_id, buyer, seller, arbiter, escrow_amount, insurance_premium,
            insurance_policy_id, trigger_price, floor_price, release_conditions,
            release_timestamp, milestone_count, milestones_completed, status,
            created_time, expiry_time, dispute_raised, partial_releases_enabled);
}

;; Save escrow
() save_escrow(int escrow_id, slice buyer, slice seller, slice arbiter,
               int escrow_amount, int insurance_premium, int insurance_policy_id,
               int trigger_price, int floor_price, int release_conditions,
               int release_timestamp, int milestone_count, int milestones_completed,
               int status, int created_time, int expiry_time, int dispute_raised,
               int partial_releases_enabled) impure {

    var escrow_cell = begin_cell()
        .store_uint(escrow_id, 64)
        .store_slice(buyer)
        .store_slice(seller)
        .store_slice(arbiter)
        .store_coins(escrow_amount)
        .store_coins(insurance_premium)
        .store_uint(insurance_policy_id, 64)
        .store_uint(trigger_price, 32)
        .store_uint(floor_price, 32)
        .store_uint(release_conditions, 8)
        .store_uint(release_timestamp, 32)
        .store_uint(milestone_count, 8)
        .store_uint(milestones_completed, 8)
        .store_uint(status, 8)
        .store_uint(created_time, 32)
        .store_uint(expiry_time, 32)
        .store_uint(dispute_raised, 1)
        .store_uint(partial_releases_enabled, 1)
    .end_cell();

    set_data_to_key(escrow_id, escrow_cell);
}

;; Check if release conditions are met
int are_conditions_met(int release_conditions, int release_timestamp,
                       int milestone_count, int milestones_completed) inline {

    if (release_conditions == RELEASE_MANUAL) {
        return false; ;; Must be manually released
    }

    if (release_conditions == RELEASE_TIME_BASED) {
        return now() >= release_timestamp;
    }

    if (release_conditions == RELEASE_MILESTONE) {
        return milestones_completed >= milestone_count;
    }

    ;; RELEASE_ORACLE_BASED requires external message
    return false;
}

;; Send payment to seller
() send_to_seller(slice seller, int amount) impure {
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(seller)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x4001, 32) ;; OP_ESCROW_RELEASE
    .end_cell();

    send_raw_message(msg, 1);
}

;; Refund to buyer
() refund_to_buyer(slice buyer, int amount) impure {
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(buyer)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x4002, 32) ;; OP_ESCROW_REFUND
    .end_cell();

    send_raw_message(msg, 1);
}

;; Create insurance policy for escrow
() create_insurance_policy(slice seller, int asset_type, int escrow_amount,
                          int trigger_price, int floor_price,
                          int duration_seconds, int premium_amount) impure {

    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(storage::beneficiary_policy_address)
        .store_coins(premium_amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0x30, 32) ;; OP_CREATE_BENEFICIARY_POLICY
        .store_slice(seller) ;; Seller is beneficiary
        .store_uint(asset_type, 8)
        .store_coins(escrow_amount)
        .store_coins(premium_amount)
        .store_uint(trigger_price, 32)
        .store_uint(floor_price, 32)
        .store_uint(duration_seconds, 32)
        .store_uint(0, 1) ;; Not transferable
        .store_uint(0, 8) ;; Immediate activation
        .store_uint(0, 32) ;; No delay
        .store_ref(begin_cell().end_cell()) ;; Empty metadata
    .end_cell();

    send_raw_message(msg, 1);
}

;; ========== MESSAGE HANDLERS ==========

;; Create escrow with insurance
() handle_create_escrow(slice sender, slice in_msg) impure {
    slice buyer = sender;
    slice seller = in_msg~load_msg_addr();
    slice arbiter = in_msg~load_msg_addr(); ;; Can be null
    int escrow_amount = in_msg~load_coins();
    int insurance_premium = in_msg~load_coins();
    int asset_type = in_msg~load_uint(8);
    int trigger_price = in_msg~load_uint(32);
    int floor_price = in_msg~load_uint(32);
    int release_conditions = in_msg~load_uint(8);
    int release_delay_seconds = in_msg~load_uint(32); ;; For time-based
    int milestone_count = in_msg~load_uint(8); ;; For milestone-based
    int duration_seconds = in_msg~load_uint(32);
    int partial_releases_enabled = in_msg~load_uint(1);

    ;; Validate
    throw_unless(100, escrow_amount > 0);
    throw_unless(101, insurance_premium > 0);
    throw_unless(102, trigger_price > floor_price);
    throw_unless(103, duration_seconds > 0);

    ;; Check total payment
    int total_amount = escrow_amount + insurance_premium;
    int msg_value = in_msg~load_coins();
    throw_unless(104, msg_value >= total_amount);

    ;; Create escrow
    storage::escrow_count += 1;
    int escrow_id = storage::escrow_count;

    int created_time = now();
    int expiry_time = created_time + duration_seconds;
    int release_timestamp = 0;

    if (release_conditions == RELEASE_TIME_BASED) {
        release_timestamp = created_time + release_delay_seconds;
    }

    ;; Save escrow
    save_escrow(
        escrow_id,
        buyer,
        seller,
        arbiter,
        escrow_amount,
        insurance_premium,
        0, ;; insurance_policy_id (will be set later)
        trigger_price,
        floor_price,
        release_conditions,
        release_timestamp,
        milestone_count,
        0, ;; milestones_completed
        STATUS_PENDING,
        created_time,
        expiry_time,
        false, ;; dispute_raised
        partial_releases_enabled
    );

    ;; Create insurance policy (seller is beneficiary)
    create_insurance_policy(
        seller,
        asset_type,
        escrow_amount,
        trigger_price,
        floor_price,
        duration_seconds,
        insurance_premium
    );

    save_data();
}

;; Release funds to seller
() handle_release_funds(slice sender, slice in_msg) impure {
    int escrow_id = in_msg~load_uint(64);

    ;; Load escrow
    var (eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
         insurance_policy_id, trigger_price, floor_price, release_conditions,
         release_timestamp, milestone_count, milestones_completed, status,
         created_time, expiry_time, dispute_raised, partial_releases_enabled) = load_escrow(escrow_id);

    throw_unless(200, eid > 0);
    throw_unless(201, status == STATUS_PENDING);
    throw_unless(202, ~ dispute_raised);

    ;; Check authorization
    int is_buyer = equal_slices(sender, buyer);
    int is_arbiter = equal_slices(sender, arbiter);
    throw_unless(203, is_buyer | is_arbiter);

    ;; Check conditions
    if (release_conditions != RELEASE_MANUAL) {
        throw_unless(204, are_conditions_met(release_conditions, release_timestamp,
                                              milestone_count, milestones_completed));
    }

    ;; Release funds
    status = STATUS_RELEASED;

    save_escrow(eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
               insurance_policy_id, trigger_price, floor_price, release_conditions,
               release_timestamp, milestone_count, milestones_completed, status,
               created_time, expiry_time, dispute_raised, partial_releases_enabled);

    ;; Send to seller
    send_to_seller(seller, escrow_amount);
}

;; Cancel escrow (only if pending and by buyer)
() handle_cancel_escrow(slice sender, slice in_msg) impure {
    int escrow_id = in_msg~load_uint(64);

    var (eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
         insurance_policy_id, trigger_price, floor_price, release_conditions,
         release_timestamp, milestone_count, milestones_completed, status,
         created_time, expiry_time, dispute_raised, partial_releases_enabled) = load_escrow(escrow_id);

    throw_unless(300, eid > 0);
    throw_unless(301, equal_slices(sender, buyer));
    throw_unless(302, status == STATUS_PENDING);
    throw_unless(303, ~ dispute_raised);

    ;; Update status
    status = STATUS_CANCELLED;

    save_escrow(eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
               insurance_policy_id, trigger_price, floor_price, release_conditions,
               release_timestamp, milestone_count, milestones_completed, status,
               created_time, expiry_time, dispute_raised, partial_releases_enabled);

    ;; Refund escrow amount (premium is non-refundable)
    refund_to_buyer(buyer, escrow_amount);
}

;; Raise dispute
() handle_raise_dispute(slice sender, slice in_msg) impure {
    int escrow_id = in_msg~load_uint(64);

    var (eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
         insurance_policy_id, trigger_price, floor_price, release_conditions,
         release_timestamp, milestone_count, milestones_completed, status,
         created_time, expiry_time, dispute_raised, partial_releases_enabled) = load_escrow(escrow_id);

    throw_unless(400, eid > 0);
    throw_unless(401, status == STATUS_PENDING);

    ;; Either buyer or seller can raise dispute
    int is_buyer = equal_slices(sender, buyer);
    int is_seller = equal_slices(sender, seller);
    throw_unless(402, is_buyer | is_seller);

    ;; Update status
    status = STATUS_DISPUTED;
    dispute_raised = true;

    save_escrow(eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
               insurance_policy_id, trigger_price, floor_price, release_conditions,
               release_timestamp, milestone_count, milestones_completed, status,
               created_time, expiry_time, dispute_raised, partial_releases_enabled);
}

;; Resolve dispute (by arbiter)
() handle_resolve_dispute(slice sender, slice in_msg) impure {
    int escrow_id = in_msg~load_uint(64);
    int release_to_seller = in_msg~load_uint(1); ;; 1=seller, 0=buyer

    var (eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
         insurance_policy_id, trigger_price, floor_price, release_conditions,
         release_timestamp, milestone_count, milestones_completed, status,
         created_time, expiry_time, dispute_raised, partial_releases_enabled) = load_escrow(escrow_id);

    throw_unless(500, eid > 0);
    throw_unless(501, status == STATUS_DISPUTED);
    throw_unless(502, equal_slices(sender, arbiter)); ;; Only arbiter

    ;; Update status
    status = STATUS_RESOLVED;

    save_escrow(eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
               insurance_policy_id, trigger_price, floor_price, release_conditions,
               release_timestamp, milestone_count, milestones_completed, status,
               created_time, expiry_time, dispute_raised, partial_releases_enabled);

    ;; Release based on arbiter decision
    if (release_to_seller) {
        send_to_seller(seller, escrow_amount);
    } else {
        refund_to_buyer(buyer, escrow_amount);
    }
}

;; Complete milestone
() handle_complete_milestone(slice sender, slice in_msg) impure {
    int escrow_id = in_msg~load_uint(64);

    var (eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
         insurance_policy_id, trigger_price, floor_price, release_conditions,
         release_timestamp, milestone_count, milestones_completed, status,
         created_time, expiry_time, dispute_raised, partial_releases_enabled) = load_escrow(escrow_id);

    throw_unless(600, eid > 0);
    throw_unless(601, release_conditions == RELEASE_MILESTONE);
    throw_unless(602, status == STATUS_PENDING);

    ;; Only buyer or arbiter can confirm milestones
    int is_buyer = equal_slices(sender, buyer);
    int is_arbiter = equal_slices(sender, arbiter);
    throw_unless(603, is_buyer | is_arbiter);

    ;; Increment milestones
    milestones_completed += 1;

    ;; Check if all milestones done
    if (milestones_completed >= milestone_count) {
        status = STATUS_ACTIVE; ;; Ready for release
    }

    save_escrow(eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
               insurance_policy_id, trigger_price, floor_price, release_conditions,
               release_timestamp, milestone_count, milestones_completed, status,
               created_time, expiry_time, dispute_raised, partial_releases_enabled);
}

;; Partial release
() handle_partial_release(slice sender, slice in_msg) impure {
    int escrow_id = in_msg~load_uint(64);
    int release_amount = in_msg~load_coins();

    var (eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
         insurance_policy_id, trigger_price, floor_price, release_conditions,
         release_timestamp, milestone_count, milestones_completed, status,
         created_time, expiry_time, dispute_raised, partial_releases_enabled) = load_escrow(escrow_id);

    throw_unless(700, eid > 0);
    throw_unless(701, partial_releases_enabled);
    throw_unless(702, status == STATUS_PENDING);
    throw_unless(703, equal_slices(sender, buyer)); ;; Only buyer
    throw_unless(704, release_amount <= escrow_amount);

    ;; Update escrow amount
    escrow_amount -= release_amount;

    save_escrow(eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
               insurance_policy_id, trigger_price, floor_price, release_conditions,
               release_timestamp, milestone_count, milestones_completed, status,
               created_time, expiry_time, dispute_raised, partial_releases_enabled);

    ;; Send to seller
    send_to_seller(seller, release_amount);
}

;; ========== MAIN RECEIVER ==========

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    var cs = in_msg_cell.begin_parse();
    var flags = cs~load_uint(4);
    slice sender = cs~load_msg_addr();

    load_data();

    int op = in_msg~load_uint(32);

    if (op == OP_CREATE_ESCROW) {
        handle_create_escrow(sender, in_msg);
        return ();
    }

    if (op == OP_RELEASE_FUNDS) {
        handle_release_funds(sender, in_msg);
        return ();
    }

    if (op == OP_CANCEL_ESCROW) {
        handle_cancel_escrow(sender, in_msg);
        return ();
    }

    if (op == OP_RAISE_DISPUTE) {
        handle_raise_dispute(sender, in_msg);
        return ();
    }

    if (op == OP_RESOLVE_DISPUTE) {
        handle_resolve_dispute(sender, in_msg);
        return ();
    }

    if (op == OP_COMPLETE_MILESTONE) {
        handle_complete_milestone(sender, in_msg);
        return ();
    }

    if (op == OP_PARTIAL_RELEASE) {
        handle_partial_release(sender, in_msg);
        return ();
    }

    throw(0xffff);
}

;; ========== GET METHODS ==========

(int, slice, slice, slice, int, int, int, int, int, int, int, int, int, int, int, int, int, int) get_escrow(int escrow_id) method_id {
    load_data();
    return load_escrow(escrow_id);
}

int get_escrow_count() method_id {
    load_data();
    return storage::escrow_count;
}

int get_escrow_status(int escrow_id) method_id {
    load_data();
    var (eid, buyer, seller, arbiter, escrow_amount, insurance_premium,
         insurance_policy_id, trigger_price, floor_price, release_conditions,
         release_timestamp, milestone_count, milestones_completed, status,
         created_time, expiry_time, dispute_raised, partial_releases_enabled) = load_escrow(escrow_id);
    return status;
}
