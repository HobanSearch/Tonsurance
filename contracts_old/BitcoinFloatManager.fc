;; BitcoinFloatManager.fc - Bitcoin Float Strategy for Sustainable Yields
;;
;; The Innovation:
;; Traditional model: USD reserves → Pay BTC yields → Yields fall as BTC price rises
;; Bitcoin Float model: USD reserves + BTC float → BTC float appreciates → Constant yields forever
;;
;; Strategy:
;; 1. Target 40% USD / 60% BTC allocation
;; 2. When surplus premiums accumulate → Buy BTC
;; 3. When BTC appreciates → Float grows in USD terms
;; 4. Use float appreciation to fund yield payments
;; 5. Maintain constant 6% BTC yields indefinitely
;;
;; Key Features:
;; - Automatic rebalancing when drift >10%
;; - Dollar-cost averaging for BTC purchases
;; - Min float requirement (50 BTC safety buffer)
;; - Emergency controls for extreme volatility
;; - Performance tracking and reporting

#include "imports/stdlib.fc";

;; Storage layout
;; btc_float_sats:uint64 (Bitcoin in satoshis)
;; btc_cost_basis:Coins (USD cost basis of BTC holdings)
;; usd_reserves:Coins
;; target_usd_pct:uint32 (basis points, e.g., 4000 = 40%)
;; rebalance_threshold:uint32 (basis points, e.g., 1000 = 10% drift)
;; min_float_btc_sats:uint64 (minimum BTC to maintain)
;; dca_enabled:bool
;; dca_frequency_seconds:uint32
;; last_rebalance_time:uint32
;; vault_address:MsgAddress
;; oracle_address:MsgAddress
;; admin_address:MsgAddress

global int storage::btc_float_sats;
global int storage::btc_cost_basis;
global int storage::usd_reserves;
global int storage::target_usd_pct;
global int storage::rebalance_threshold;
global int storage::min_float_btc_sats;
global int storage::dca_enabled;
global int storage::dca_frequency_seconds;
global int storage::last_rebalance_time;
global slice storage::vault_address;
global slice storage::oracle_address;
global slice storage::admin_address;

const int BASIS_POINTS = 10000;
const int SATS_PER_BTC = 100000000; ;; 1 BTC = 100M sats

const int OP_REBALANCE = 0x20;
const int OP_BUY_BTC = 0x21;
const int OP_SELL_BTC = 0x22;
const int OP_UPDATE_ALLOCATION = 0x23;
const int OP_EMERGENCY_PAUSE = 0x24;
const int OP_CALCULATE_SIGNAL = 0x25;
const int OP_UPDATE_BTC_PRICE = 0x26;

;; Rebalancing urgency levels
const int URGENCY_NONE = 0;
const int URGENCY_LOW = 1;
const int URGENCY_MEDIUM = 2;
const int URGENCY_HIGH = 3;
const int URGENCY_CRITICAL = 4;

;; Load storage
() load_data() impure {
    var ds = get_data().begin_parse();

    storage::btc_float_sats = ds~load_uint(64);
    storage::btc_cost_basis = ds~load_coins();
    storage::usd_reserves = ds~load_coins();
    storage::target_usd_pct = ds~load_uint(32);
    storage::rebalance_threshold = ds~load_uint(32);
    storage::min_float_btc_sats = ds~load_uint(64);
    storage::dca_enabled = ds~load_uint(1);
    storage::dca_frequency_seconds = ds~load_uint(32);
    storage::last_rebalance_time = ds~load_uint(32);
    storage::vault_address = ds~load_msg_addr();
    storage::oracle_address = ds~load_msg_addr();
    storage::admin_address = ds~load_msg_addr();

    ds.end_parse();
}

;; Save storage
() save_data() impure {
    set_data(
        begin_cell()
            .store_uint(storage::btc_float_sats, 64)
            .store_coins(storage::btc_cost_basis)
            .store_coins(storage::usd_reserves)
            .store_uint(storage::target_usd_pct, 32)
            .store_uint(storage::rebalance_threshold, 32)
            .store_uint(storage::min_float_btc_sats, 64)
            .store_uint(storage::dca_enabled, 1)
            .store_uint(storage::dca_frequency_seconds, 32)
            .store_uint(storage::last_rebalance_time, 32)
            .store_slice(storage::vault_address)
            .store_slice(storage::oracle_address)
            .store_slice(storage::admin_address)
        .end_cell()
    );
}

;; Calculate BTC value in USD
int calculate_btc_value_usd(int btc_sats, int btc_price_usd_cents) inline {
    ;; btc_value = (sats / SATS_PER_BTC) × price_in_cents
    return (btc_sats * btc_price_usd_cents) / SATS_PER_BTC;
}

;; Calculate total reserves (USD + BTC in USD terms)
int calculate_total_reserves(int btc_price_usd_cents) inline {
    int btc_value = calculate_btc_value_usd(storage::btc_float_sats, btc_price_usd_cents);
    return storage::usd_reserves + btc_value;
}

;; Calculate current USD percentage
int calculate_current_usd_pct(int btc_price_usd_cents) inline {
    int total_reserves = calculate_total_reserves(btc_price_usd_cents);

    if (total_reserves == 0) {
        return BASIS_POINTS; ;; 100% USD if no reserves
    }

    ;; Return as basis points
    return (storage::usd_reserves * BASIS_POINTS) / total_reserves;
}

;; Calculate allocation drift
int calculate_drift(int current_usd_pct) inline {
    int drift = current_usd_pct - storage::target_usd_pct;

    if (drift < 0) {
        drift = - drift; ;; Absolute value
    }

    return drift;
}

;; Determine rebalancing urgency
int calculate_urgency(int drift) inline {
    if (drift > 2000) { return URGENCY_CRITICAL; }  ;; >20% drift
    if (drift > 1500) { return URGENCY_HIGH; }      ;; >15% drift
    if (drift > 1000) { return URGENCY_MEDIUM; }    ;; >10% drift (threshold)
    if (drift > 500) { return URGENCY_LOW; }        ;; >5% drift
    return URGENCY_NONE;
}

;; Calculate unrealized gains/losses on BTC float
int calculate_unrealized_pnl(int btc_price_usd_cents) inline {
    int current_btc_value = calculate_btc_value_usd(storage::btc_float_sats, btc_price_usd_cents);
    return current_btc_value - storage::btc_cost_basis;
}

;; Generate trade signal (buy or sell BTC)
;; Returns: (action, amount_usd_cents)
;;   action: 0 = hold, 1 = buy BTC, 2 = sell BTC
(int, int) generate_trade_signal(int btc_price_usd_cents) inline {
    int current_usd_pct = calculate_current_usd_pct(btc_price_usd_cents);
    int drift = calculate_drift(current_usd_pct);

    ;; Check if rebalancing needed
    if (drift < storage::rebalance_threshold) {
        return (0, 0); ;; HOLD
    }

    int total_reserves = calculate_total_reserves(btc_price_usd_cents);

    if (current_usd_pct > storage::target_usd_pct) {
        ;; Too much USD → Buy BTC
        int excess_usd_pct = current_usd_pct - storage::target_usd_pct;
        int excess_usd = (total_reserves * excess_usd_pct) / BASIS_POINTS;

        ;; If DCA enabled, only trade 1/N of excess
        if (storage::dca_enabled) {
            excess_usd = excess_usd / 4; ;; Buy 25% of excess per trade
        }

        return (1, excess_usd); ;; BUY_BTC
    } else {
        ;; Too much BTC → Sell BTC
        int excess_btc_pct = storage::target_usd_pct - current_usd_pct;
        int excess_btc_value = (total_reserves * excess_btc_pct) / BASIS_POINTS;

        ;; Check minimum float requirement
        int btc_value_after_sale = calculate_btc_value_usd(storage::btc_float_sats, btc_price_usd_cents) - excess_btc_value;
        int min_float_value = calculate_btc_value_usd(storage::min_float_btc_sats, btc_price_usd_cents);

        if (btc_value_after_sale < min_float_value) {
            ;; Would breach minimum → adjust sale amount
            excess_btc_value = calculate_btc_value_usd(storage::btc_float_sats, btc_price_usd_cents) - min_float_value;

            if (excess_btc_value <= 0) {
                return (0, 0); ;; HOLD - at minimum
            }
        }

        ;; If DCA enabled, only trade 1/N of excess
        if (storage::dca_enabled) {
            excess_btc_value = excess_btc_value / 4;
        }

        return (2, excess_btc_value); ;; SELL_BTC
    }
}

;; Calculate years of yield coverage from float
;; Given: annual_yield_requirement (in USD), btc_appreciation_rate (basis points)
int calculate_years_of_coverage(int annual_yield_requirement, int btc_price_usd_cents, int btc_appreciation_rate) inline {
    int current_btc_value = calculate_btc_value_usd(storage::btc_float_sats, btc_price_usd_cents);

    if (annual_yield_requirement == 0) {
        return 999; ;; Infinite coverage
    }

    ;; Simple approximation: years = float_value / annual_requirement
    ;; (Ignores compounding effects of BTC appreciation)
    return current_btc_value / annual_yield_requirement;
}

;; Execute BTC purchase
() execute_buy_btc(int usd_amount, int btc_price_usd_cents) impure {
    throw_unless(100, usd_amount > 0);
    throw_unless(101, usd_amount <= storage::usd_reserves);

    ;; Calculate BTC to receive (in sats)
    ;; btc_sats = (usd_amount × SATS_PER_BTC) / btc_price_usd_cents
    int btc_sats_to_buy = (usd_amount * SATS_PER_BTC) / btc_price_usd_cents;

    ;; Update reserves
    storage::usd_reserves -= usd_amount;
    storage::btc_float_sats += btc_sats_to_buy;
    storage::btc_cost_basis += usd_amount;
    storage::last_rebalance_time = now();

    save_data();

    ;; Send trade execution message (to DEX or OTC desk)
    ;; In production, this would integrate with TON DEX contracts
}

;; Execute BTC sale
() execute_sell_btc(int usd_value, int btc_price_usd_cents) impure {
    ;; Calculate BTC to sell (in sats)
    int btc_sats_to_sell = (usd_value * SATS_PER_BTC) / btc_price_usd_cents;

    throw_unless(200, btc_sats_to_sell > 0);
    throw_unless(201, btc_sats_to_sell <= storage::btc_float_sats);

    ;; Check minimum float
    int remaining_btc = storage::btc_float_sats - btc_sats_to_sell;
    throw_unless(202, remaining_btc >= storage::min_float_btc_sats);

    ;; Calculate cost basis reduction (proportional)
    int cost_basis_reduction = (storage::btc_cost_basis * btc_sats_to_sell) / storage::btc_float_sats;

    ;; Update reserves
    storage::btc_float_sats -= btc_sats_to_sell;
    storage::btc_cost_basis -= cost_basis_reduction;
    storage::usd_reserves += usd_value;
    storage::last_rebalance_time = now();

    save_data();

    ;; Send trade execution message
}

;; ========== MESSAGE HANDLERS ==========

;; Handle rebalancing request
() handle_rebalance(slice sender, slice in_msg) impure {
    ;; Can be called by admin or keeper bot
    int btc_price_usd_cents = in_msg~load_coins();

    throw_unless(300, btc_price_usd_cents > 0);

    ;; Generate trade signal
    var (action, amount) = generate_trade_signal(btc_price_usd_cents);

    if (action == 1) {
        ;; Buy BTC
        execute_buy_btc(amount, btc_price_usd_cents);
    }

    if (action == 2) {
        ;; Sell BTC
        execute_sell_btc(amount, btc_price_usd_cents);
    }

    ;; If action == 0, do nothing (HOLD)
}

;; Handle manual BTC purchase
() handle_buy_btc(slice sender, slice in_msg) impure {
    ;; Only admin can execute manual trades
    throw_unless(400, equal_slices(sender, storage::admin_address));

    int usd_amount = in_msg~load_coins();
    int btc_price_usd_cents = in_msg~load_coins();

    execute_buy_btc(usd_amount, btc_price_usd_cents);
}

;; Handle manual BTC sale
() handle_sell_btc(slice sender, slice in_msg) impure {
    ;; Only admin can execute manual trades
    throw_unless(500, equal_slices(sender, storage::admin_address));

    int usd_value = in_msg~load_coins();
    int btc_price_usd_cents = in_msg~load_coins();

    execute_sell_btc(usd_value, btc_price_usd_cents);
}

;; Handle allocation update
() handle_update_allocation(slice sender, slice in_msg) impure {
    ;; Only admin can update allocation
    throw_unless(600, equal_slices(sender, storage::admin_address));

    int new_target_usd_pct = in_msg~load_uint(32);
    int new_rebalance_threshold = in_msg~load_uint(32);

    throw_unless(601, new_target_usd_pct <= BASIS_POINTS);
    throw_unless(602, new_rebalance_threshold <= BASIS_POINTS);

    storage::target_usd_pct = new_target_usd_pct;
    storage::rebalance_threshold = new_rebalance_threshold;

    save_data();
}

;; Handle emergency pause
() handle_emergency_pause(slice sender, slice in_msg) impure {
    ;; Only admin can pause
    throw_unless(700, equal_slices(sender, storage::admin_address));

    ;; Disable DCA and increase rebalance threshold to prevent automatic trades
    storage::dca_enabled = false;
    storage::rebalance_threshold = 5000; ;; 50% - very conservative

    save_data();
}

;; ========== MAIN RECEIVER ==========

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    ;; Parse message
    var cs = in_msg_cell.begin_parse();
    var flags = cs~load_uint(4);
    slice sender = cs~load_msg_addr();

    ;; Load storage
    load_data();

    ;; Parse operation
    int op = in_msg~load_uint(32);

    if (op == OP_REBALANCE) {
        handle_rebalance(sender, in_msg);
        return ();
    }

    if (op == OP_BUY_BTC) {
        handle_buy_btc(sender, in_msg);
        return ();
    }

    if (op == OP_SELL_BTC) {
        handle_sell_btc(sender, in_msg);
        return ();
    }

    if (op == OP_UPDATE_ALLOCATION) {
        handle_update_allocation(sender, in_msg);
        return ();
    }

    if (op == OP_EMERGENCY_PAUSE) {
        handle_emergency_pause(sender, in_msg);
        return ();
    }

    throw(0xffff); ;; Unknown operation
}

;; ========== GET METHODS ==========

;; Get current BTC float (in sats)
int get_btc_float_sats() method_id {
    load_data();
    return storage::btc_float_sats;
}

;; Get USD reserves
int get_usd_reserves() method_id {
    load_data();
    return storage::usd_reserves;
}

;; Get total reserves at current BTC price
int get_total_reserves(int btc_price_usd_cents) method_id {
    load_data();
    return calculate_total_reserves(btc_price_usd_cents);
}

;; Get current USD allocation percentage
int get_current_usd_pct(int btc_price_usd_cents) method_id {
    load_data();
    return calculate_current_usd_pct(btc_price_usd_cents);
}

;; Get allocation drift
int get_allocation_drift(int btc_price_usd_cents) method_id {
    load_data();
    int current_usd_pct = calculate_current_usd_pct(btc_price_usd_cents);
    return calculate_drift(current_usd_pct);
}

;; Get rebalancing urgency
int get_rebalancing_urgency(int btc_price_usd_cents) method_id {
    load_data();
    int current_usd_pct = calculate_current_usd_pct(btc_price_usd_cents);
    int drift = calculate_drift(current_usd_pct);
    return calculate_urgency(drift);
}

;; Get trade signal
(int, int) get_trade_signal(int btc_price_usd_cents) method_id {
    load_data();
    return generate_trade_signal(btc_price_usd_cents);
}

;; Get unrealized P&L on BTC float
int get_unrealized_pnl(int btc_price_usd_cents) method_id {
    load_data();
    return calculate_unrealized_pnl(btc_price_usd_cents);
}

;; Get BTC cost basis
int get_btc_cost_basis() method_id {
    load_data();
    return storage::btc_cost_basis;
}

;; Get years of yield coverage
int get_years_of_coverage(int annual_yield_requirement, int btc_price_usd_cents, int btc_appreciation_rate) method_id {
    load_data();
    return calculate_years_of_coverage(annual_yield_requirement, btc_price_usd_cents, btc_appreciation_rate);
}

;; Get allocation settings
(int, int, int) get_allocation_settings() method_id {
    load_data();
    return (storage::target_usd_pct, storage::rebalance_threshold, storage::min_float_btc_sats);
}
